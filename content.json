[{"title":"WebSocket Java API指南","date":"2017-06-23T02:16:27.190Z","path":"2017/06/23/WebSocket Java API指南/","text":"1. 概述WebSocket提供了通过提供双向，全双工，实时客户端/服务器通信来限制服务器和Web浏览器之间的有效通信的备选方案。服务器可以随时向客户端发送数据。因为它运行在TCP上，它还提供低延迟低级别通信，并减少每个消息的开销。 2. JSR 356JSR 356或Java API for WebSocket指定了Java开发人员可以将WebSockets与其应用程序集成在一起的API，无论是在服务器端还是Java客户端。 该Java API提供了服务器端和客户端组件： 服务器：一切都在javax.websocket.server包。 客户端：javax.websocket包的内容，由客户端API组成，也是服务器端和客户端的公共库。 3.使用WebSockets构建聊天我们将构建一个非常简单的聊天应用程序。任何用户都可以从任何浏览器打开聊天，输入他的名字，登录聊天，并开始与所有连接聊天的人进行通信。 12345&lt;dependency&gt; &lt;groupId&gt;javax.websocket&lt;/groupId&gt; &lt;artifactId&gt;javax.websocket-api&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt;&lt;/dependency&gt; 为了将Java对象转换成JSON表示，反之亦然，我们将使用Gson： 12345&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt;&lt;/dependency&gt; 3.1。端点配置配置端点有两种方法：基于注释和扩展。您可以扩展javax.websocket.Endpoint类或使用专用的方法级注释。由于与编程模型相比，注释模型导致更清晰的代码，注释已经成为常规的编码选择。在这种情况下，WebSocket端点生命周期事件由以下注释处理： @ServerEndpoint：如果使用@ServerEndpoint进行装饰，容器可以确保该类作为侦听特定URI空间的WebSocket服务器的可用性 @ClientEndpoint：使用此注释装饰的类被视为WebSocket客户端 @OnOpen：当启动新的WebSocket连接时，容器调用带有@OnOpen的Java方法 @OnMessage：使用@OnMessage注释的Java方法在将消息发送到端点时从WebSocket容器接收信息 @OnError：当通信出现问题时，会调用带有@OnError的方法 @OnClose：用于装饰WebSocket连接关闭时由容器调用的Java方法 3.2。编写服务器端点我们通过用@ServerEndpoint注释它来声明一个Java类WebSocket服务器端点。我们还指定端点部署的URI。 URI相对于服务器容器的根目录定义，必须以正斜杠开头： 1234567891011121314151617181920212223@ServerEndpoint(value = \"/chat/&#123;username&#125;\")public class ChatEndpoint &#123; @OnOpen public void onOpen(Session session) throws IOException &#123; // Get session and WebSocket connection &#125; @OnMessage public void onMessage(Session session, Message message) throws IOException &#123; // Handle new messages &#125; @OnClose public void onClose(Session session) throws IOException &#123; // WebSocket connection closes &#125; @OnError public void onError(Session session, Throwable throwable) &#123; // Do error handling here &#125;&#125; 上面的代码是我们类似聊天的应用程序的服务器端点骨架。如您所见，我们有4个注释映射到各自的方法。下面你可以看到这样的方法的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@ServerEndpoint(value=\"/chat/&#123;username&#125;\")public class ChatEndpoint &#123; private Session session; private static Set&lt;ChatEndpoint&gt; chatEndpoints = new CopyOnWriteArraySet&lt;&gt;(); private static HashMap&lt;String, String&gt; users = new HashMap&lt;&gt;(); @OnOpen public void onOpen( Session session, @PathParam(\"username\") String username) throws IOException &#123; this.session = session; chatEndpoints.add(this); users.put(session.getId(), username); Message message = new Message(); message.setFrom(username); message.setContent(\"Connected!\"); broadcast(message); &#125; @OnMessage public void onMessage(Session session, Message message) throws IOException &#123; message.setFrom(users.get(session.getId())); broadcast(message); &#125; @OnClose public void onClose(Session session) throws IOException &#123; chatEndpoints.remove(this); Message message = new Message(); message.setFrom(users.get(session.getId())); message.setContent(\"Disconnected!\"); broadcast(message); &#125; @OnError public void onError(Session session, Throwable throwable) &#123; // Do error handling here &#125; private static void broadcast(Message message) throws IOException, EncodeException &#123; chatEndpoints.forEach(endpoint -&gt; &#123; synchronized (endpoint) &#123; try &#123; endpoint.session.getBasicRemote(). sendObject(message); &#125; catch (IOException | EncodeException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125;&#125; 当新用户登录时（@OnOpen）立即映射到活动用户的数据结构。然后，使用广播方法创建一条消息并发送到所有端点。 当任何连接的用户发送新消息（@OnMessage）时，也会使用此方法 - 这是聊天的主要目的。 如果在某些时候发生错误，则使用注释@OnError处理它的方法。您可以使用此方法记录有关错误的信息并清除端点。 最后，当用户不再连接到聊天时，方法@OnClose清除端点并广播给用户已断开连接的所有用户。 4. 消息类型WebSocket规范支持两种在线数据格式 - 文本和二进制。 API支持这两种格式，增加了使用Java对象的功能和规范中定义的运行状况检查消息（ping-pong）： 文本：任何文本数据（java.lang.String，primitives或其等价的包装器类） 二进制：由java.nio.ByteBuffer或byte []（字节数组）表示的二进制数据（例如音频，图像等） Java对象：API使您可以在代码中使用本机（Java对象）表示，并使用自定义变换器（编码器/解码器）将其转换为WebSocket协议允许的兼容在线格式（文本，二进制） Ping-Pong：一个javax.websocket.PongMessage是由一个WebSocket对等体响应健康检查（ping）请求发送的确认 对于我们的应用程序，我们将使用Java对象。我们将创建用于编码和解码消息的类。 ###4.1. Encoder 编码器采用Java对象，并产生适合作为消息（如JSON，XML或二进制表示）传输的典型表示形式。可以通过实现Encoder.Text 或Encoder.Binary 接口来使用编码器。 在下面的代码中，我们定义要编码的类Message，在编码方法中，我们使用Gson将Java对象编码为JSON 1234567class Message &#123; private String from; private String to; private String content; //standard constructors, getters, setters&#125; 12345678910111213141516171819public class MessageEncoder implements Encoder.Text&lt;Message&gt; &#123; private static Gson gson = new Gson(); @Override public String encode(Message message) throws EncodeException &#123; return gson.toJson(message); &#125; @Override public void init(EndpointConfig endpointConfig) &#123; // Custom initialization logic &#125; @Override public void destroy() &#123; // Close resources &#125;&#125; 4.2. Decoder解码器与编码器相反，用于将数据转换回Java对象。解码器可以使用Decoder.Text 或Decoder.Binary 接口来实现。 正如我们用编码器所看到的那样，解码方法是我们在发送到端点的消息中检索JSON，并使用Gson将其转换为一个名为Message的Java类： 123456789101112131415161718192021222324public class MessageDecoder implements Decoder.Text&lt;Message&gt; &#123; private static Gson gson = new Gson(); @Override public Message decode(String s) throws DecodeException &#123; return gson.fromJson(s, Message.class); &#125; @Override public boolean willDecode(String s) &#123; return (s != null); &#125; @Override public void init(EndpointConfig endpointConfig) &#123; // Custom initialization logic &#125; @Override public void destroy() &#123; // Close resources &#125;&#125; 4.3。在服务器端点设置编码器和解码器让我们把所有的东西放在一起，在类级别注释@ServerEndpoint中添加为编码和解码数据而创建的类： 1234@ServerEndpoint( value=\"/chat/&#123;username&#125;\", decoders = MessageDecoder.class, encoders = MessageEncoder.class ) 每次将消息发送到端点时，它们将自动转换为JSON或Java对象。 5. Conclusion在本文中，我们研究了WebSockets的Java API以及如何帮助我们构建诸如此实时聊天之类的应用程序。 我们看到了用于创建端点的两个编程模型：注释和编程。我们使用我们的应用程序的注释模型以及生命周期方法定义了一个端点。 此外，为了能够在服务器和客户端之间进行通信，我们看到需要编码器和解码器将Java对象转换为JSON，反之亦然。 JSR 356 API非常简单，并且基于注释的编程模型使构建WebSocket应用程序变得非常简单。 要运行我们在示例中构建的应用程序，我们需要做的是将war文件部署在Web服务器中，并转到URL：http：// localhost：8080 / java-websocket /。您可以在这里找到存储库的链接here。","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Building a REST API","date":"2017-06-23T01:35:23.944Z","path":"2017/06/23/Building a REST API/","text":"Build a REST API with Spring 4 and Java Config目录 1.概述 2.Understanding REST in Spring 3. The Java configuration 4.Testing the Spring context 5The Controller 6Mapping the HTTP response codes 7Additional Maven dependencies 8Conclusion Overview本文介绍如何在Spring中设置REST - 控制器和HTTP响应代码，有效载荷编组和内容协商的配置。Spring框架支持创建RESTful服务的两种方式： using MVC with ModelAndView using HTTP message converters Understanding REST in SpringModelAndView方法更旧，更好的记录，而且更详细并且它尝试将REST模式推向旧模式，这不是没有问题。 Spring团队了解了这一点，并从Spring 3.0开始提供了一流的REST支持。新方法基于HttpMessageConverter**和annotations**，更轻便，易于实施。配置是最小的，它为您提供RESTful服务所期望的默认设置。然而，关于文件，它是较新的，有点轻那是什么呢，这个参考并不排除在这两种方法之间作出区分和权衡的方式，就应该是明确的。然而，这是在Spring 3.0之后构建RESTful服务的方式。 The Java configuration12345@Configuration@EnableWebMvcpublic class WebConfig&#123; //&#125; 新的@EnableWebMvc注释有许多有用的东西 - 特别是在REST的情况下，它会检测到类路径中存在Jackson和JAXB 2，并自动创建和注册默认的JSON和XML转换器。注释的功能等同于XML版本： 1&lt;mvc:annotation-driven /&gt; 这是一个捷径，虽然在许多情况下可能有用，但并不完美。当需要更复杂的配置时，删除注释并直接扩展WebMvcConfigurationSupport。 Testing the Spring context从Spring 3.1开始，我们为@Configuration类提供了一流的测试支持： 12345678910@RunWith( SpringJUnit4ClassRunner.class )@ContextConfiguration( classes = &#123; ApplicationConfig.class, PersistenceConfig.class &#125;, loader = AnnotationConfigContextLoader.class )public class SpringTest&#123; @Test public void whenSpringContextIsInstantiated_thenNoExceptions()&#123; // When &#125;&#125; Java配置类仅用@ContextConfiguration注释指定，新的AnnotationConfigContextLoader从@Configuration类加载bean定义。 请注意，WebConfig配置类未包含在测试中，因为它需要在未提供的Servlet上下文中运行。 The Controller@Controller是RESTful API整个Web层中的中心工件。为了这个帖子的目的，控制器正在建模一个简单的REST资源 - Foo： 123456789101112131415161718192021222324252627282930313233343536373839404142@Controller@RequestMapping( value = \"/foos\" )class FooController&#123; @Autowired IFooService service; @RequestMapping( method = RequestMethod.GET ) @ResponseBody public List&lt; Foo &gt; findAll()&#123; return service.findAll(); &#125; @RequestMapping( value = \"/&#123;id&#125;\", method = RequestMethod.GET ) @ResponseBody public Foo findOne( @PathVariable( \"id\" ) Long id )&#123; return RestPreconditions.checkFound( service.findOne( id ) ); &#125; @RequestMapping( method = RequestMethod.POST ) @ResponseStatus( HttpStatus.CREATED ) @ResponseBody public Long create( @RequestBody Foo resource )&#123; Preconditions.checkNotNull( resource ); return service.create( resource ); &#125; @RequestMapping( value = \"/&#123;id&#125;\", method = RequestMethod.PUT ) @ResponseStatus( HttpStatus.OK ) public void update( @PathVariable( \"id\" ) Long id, @RequestBody Foo resource )&#123; Preconditions.checkNotNull( resource ); RestPreconditions.checkNotNull( service.getById( resource.getId() ) ); service.update( resource ); &#125; @RequestMapping( value = \"/&#123;id&#125;\", method = RequestMethod.DELETE ) @ResponseStatus( HttpStatus.OK ) public void delete( @PathVariable( \"id\" ) Long id )&#123; service.deleteById( id ); &#125; &#125; 你可能已经注意到我正在使用一个非常简单的类似guava风格的RestPreconditions实用程序： 12345678public class RestPreconditions &#123; public static &lt;T&gt; T checkFound(final T resource) &#123; if (resource == null) &#123; throw new MyResourceNotFoundException(); &#125; return resource; &#125;&#125; 控制器实现是非公开的 - 这是因为它不需要。通常，控制器是依赖关系链中的最后一个 - 它接收来自Spring前端控制器（DispathcerServlet）的HTTP请求，并将它们转发到服务层。如果没有使用情况，控制器必须通过直接引用注入或操纵，那么我不喜欢将其声明为公开的。 请求映射是直接的 - 与任何控制器一样，映射的实际值以及HTTP方法都用于确定请求的目标方法。 @RequestBody会将方法的参数绑定到HTTP请求的正文，而@ResponseBody对响应和返回类型执行相同的操作。他们还确保使用正确的HTTP转换器对资源进行编组和解组。将进行内容协商，以选择将使用哪个主动转换器，主要基于Accept标头，尽管也可以使用其他HTTP标头来确定表示。 Mapping the HTTP response codesHTTP响应的状态代码是REST服务的最重要部分之一，并且主题可以快速变得非常复杂。获得这些权利可以是什么造成或破坏了服务。 1.Unmapped requests如果Spring MVC接收到没有映射的请求，则认为该请求不被允许，并返回一个405 METHOD NOT ALLOWED回到客户端。在向客户端返回405时，包含Allow HTTP头也是一个很好的做法，以便指定允许的操作。这是Spring MVC的标准行为，不需要任何其他配置。 2. Valid, mapped requests 对于任何具有映射的请求，如果没有指定其他状态代码，则Spring MVC将请求有效并以200 OK作为响应。正因为如此，控制器为创建，更新和删除操作声明不同的@ResponseStatus，而不是为get声明，这应该确实返回默认的200 OK。 2.Client error在客户端错误的情况下，自定义异常被定义并映射到相应的错误代码。简单地从Web层的任何层中抛出这些异常将确保Spring映射HTTP响应的相应状态代码。 12345678@ResponseStatus( value = HttpStatus.BAD_REQUEST )public class BadRequestException extends RuntimeException&#123; //&#125;@ResponseStatus( value = HttpStatus.NOT_FOUND )public class ResourceNotFoundException extends RuntimeException&#123; //&#125; 这些异常是REST API的一部分，因此应该仅在与REST相应的适当层中使用;如果存在DAO / DAL层，则不应直接使用该异常。还要注意，这些不是检查异常，而是运行时异常 - 符合Spring实践和习语。 4. Using @ExceptionHandler将自定义异常映射到特定状态代码的另一个选项是在控制器中使用@ExceptionHandler注释。该方法的问题是注释仅适用于定义在其中的控制器，而不适用于整个Spring Container，这意味着需要在每个控制器中单独声明。这很快变得麻烦，特别是在更复杂的应用程序中，许多控制器。此时与Spring打开的几个JIRA问题正在处理这个和其他相关的限制：SPR-8124，SPR-7278，SPR-8406。 Additional Maven dependencies除了标准Web应用程序所需的spring-webmvc依赖之外，还需要为REST API设置内容编组和解组合： 123456789101112131415161718&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt; &lt;version&gt;$&#123;jaxb-api.version&#125;&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; &lt;properties&gt; &lt;jackson.version&gt;2.4.0&lt;/jackson.version&gt; &lt;jaxb-api.version&gt;2.2.11&lt;/jaxb-api.version&gt;&lt;/properties&gt; 这些是用于将REST资源的表示转换为JSON或XML的库。 Conclusion本教程介绍了如何使用Spring 4和基于Java的配置来实现和配置REST服务，讨论HTTP响应代码，基本内容协商和编组。 在本系列的下一篇文章中，我将重点介绍API的可发现性，高级内容协商以及使用资源的附加表示。 在Github项目中可以找到一些这些例外示例的实现这是一个基于Eclipse的项目，所以应该很容易导入和运行。","tags":[{"name":"rest with spring","slug":"rest-with-spring","permalink":"http://yoursite.com/tags/rest-with-spring/"}]},{"title":"Top Spring Framework Interview Questions","date":"2017-06-23T01:35:11.845Z","path":"2017/06/23/Top Spring Framework Interview Questions/","text":"1. Introduction在本文中，我们将介绍在面试过程中可能出现的一些最常见的Spring相关问题 2. Spring CoreQ1. What is Spring Framework? Spring是Java Enterprise Edition应用程序开发中最广泛使用的框架。 Spring的核心功能可用于开发任何Java应用程序 我们可以使用其扩展来构建Java EE平台之上的各种Web应用程序，或者我们可以在简单的独立应用程序中使用其依赖注入的功能 Q2. What are the benefits of using Spring? Spring的目标是使Java EE开发更容易。以下是使用它的优点： Lightweight（轻量级）在开发中使用框架只有一个轻微的开销 Inversion of Control (IoC): Spring容器负责各种对象的依赖管理关系，而不是创建或查找依赖对象 Aspect Oriented Programming (AOP): Spring支持AOP将业务逻辑与系统服务分开 MVC framework: 用于创建能够返回XML / JSON响应的Web应用程序或RESTful Web服务 Transaction management: 通过使用Java注释或Spring Bean XML配置文件来减少JDBC操作，文件上传等中的相同代码量 Exception Handling: Spring提供了一种方便的API来将技术特定的异常转换为未检查的异常 Q3. What Spring sub-projects do you know? Describe them briefly. Core -提供框架的基本部分的关键模块，如IoC或DI JDBC - 该模块支持JDBC抽象层，无需为特定的供应商数据库执行JDBC编码 ORM integration - 为流行的对象关系映射API（如JPA，JDO和Hibernate）提供集成层 Web - 面向Web的集成模块，提供多文件上传，Servlet监听器和面向Web的应用程序上下文功能 MVC framework - 实现模型视图控制器设计模式的Web模块 AOP module - 面向方面的编程实现，允许定义清除方法拦截器和切入点 Q4. What is Dependency Injection? 依赖注入是控制反转（IoC）的一个方面，它是一个通用概念，说明您不是手动创建对象，而是描述如何创建对象。如果需要，IoC容器将实例化所需的类。 Q5. How can we inject beans in Spring? 存在几个不同的选择： Setter Injection Constructor Injection Field Injection 可以使用XML文件或注释来完成配置。 Q6. Which is the best way of injecting beans and why?推荐的方法是使用构造函数参数作为强制依赖关系和setters候选. 。构造器注入允许将值注入到不可变字段，并使测试更容易。 Q7. What is the difference between BeanFactory and ApplicationContext? BeanFactory是一个表示提供和管理bean实例的容器的接口。 getBean（）被调用时默认实现实例化bean。 ApplicationContext是一个表示容器中的所有信息，元数据和bean的容器的接口。它还扩展了BeanFactory接口，但默认实现在应用程序启动时实时实例化bean。可以针对自己的单个bean覆盖此行为。 Q8. What is a Spring Bean? Spring Bean是由Spring IoC容器初始化的Java对象。 Q9. What is the default bean scope in Spring framework? 默认情况下，Spring Bean被初始化为单例。 Q10. How to define the scope of a bean? 要设置Spring Bean的范围，我们可以在XML配置文件中使用@Scope注释或“scope”属性。有五个支持的范围： singleton prototype request session global-session Q11. Are singleton beans thread-safe? 不，单例bean不是线程安全的，因为线程安全性是关于执行的，而单例是一种专注于创建的设计模式。线程安全性只取决于bean实现本身。 Q12. What does the Spring bean lifecycle look like? 首先，需要根据Java或XML bean定义实例化一个Spring bean。还可能需要执行一些初始化以使其进入可用状态。之后，当bean不再需要时，它将从IoC容器中删除 所有初始化方法的整个周期都显示在图像（源）上： Q13. What is the Spring Java-Based Configuration? 它是以类型安全的方式配置基于Spring的应用程序的方法之一。这是基于XML的配置的替代方法。 Q14. Can we have multiple Spring configuration files in one project? 是的，在大型项目中，建议使用多个Spring配置来提高可维护性和模块性。 您可以加载多个基于Java的配置文件: 123 @Configuration@Import(&#123;MainConfig.class, SchedulerConfig.class&#125;)public class AppConfig &#123; 或加载一个将包含所有其他配置的XML文件： 1ApplicationContext context = new ClassPathXmlApplicationContext(\"spring-all.xml\"); 在这个XML文件里面你可以包含： 12&lt;import resource=\"main.xml\"/&gt;&lt;import resource=\"scheduler.xml\"/&gt; Q15. What is Spring Security? Spring Security是Spring框架的一个单独的模块，专注于在Java应用程序中提供身份验证和授权方法。它还特别关注了了大多数常见的安全漏洞，如CSRF攻击。 要在Web应用程序中使用Spring Security，您可以开始使用简单的注释：@EnableWebSecurity。 您可以在Baeldung找到与安全有关的一系列文章。 Q16. What is Spring Boot? Spring Boot是一个项目，它提供了一组预先配置的框架，以减少样板配置，以便您可以使用最小的代码来启动和运行Spring应用程序。 Q17. Name some of the Design Patterns used in the Spring Framework? Singleton Pattern: Singleton-scoped beans Factory Pattern: Bean Factory classes Prototype Pattern: Prototype-scoped beans Adapter Pattern: Spring Web and Spring MVC Proxy Pattern: Spring Aspect Oriented Programming support Template Method Pattern: dbcTemplate, HibernateTemplate, etc. Front Controller: Spring MVC DispatcherServlet Data Access Object: Spring DAO support Model View Controller: Spring MVC Q18. How does the scope Prototype work? 范围原型意味着每次调用Bean的实例时，Spring将创建一个新的实例并返回。这与默认单例范围不同，其中每个Spring IoC容器实例化一个对象实例。 3. Spring MVC Q19. How to Get ServletContext and ServletConfig Objects in a Spring Bean? 你可以这么做： Implementing Spring-aware interfaces. The complete list is available here. Using @Autowired annotation on those beans: 12345@AutowiredServletContext servletContext; @AutowiredServletConfig servletConfig; Q20. What is the role of the @Required annotation? @Required注释用于setter方法，它表示具有此注释的bean属性必须在配置时填充。否则，Spring容器将抛出一个BeanInitializationException异常。 另外@Required与@Autowired不同，因为它仅限于setter，而@Autowired不是。 @Autowired可以用于连接构造函数和字段，而@Required只检查属性是否设置。我们来看一个例子： 12345678public class Person &#123; private String name; @Required public void setName(String name) &#123; this.name = name; &#125;&#125; 现在，需要在XML配置中设置Person bean的名称，如下所示： 123&lt;bean id=\"person\" class=\"com.baeldung.Person\"&gt; &lt;property name=\"name\" value=\"Joe\" /&gt;&lt;/bean&gt; 请注意，@Required默认情况下不支持基于Java的@Configuration类。如果您需要确保所有属性都已设置，您可以在@Bean注释方法中创建bean时执行此操作。 Q21. What is the role of the @Autowired annotation? @Autowired注释可以用于通过类型注入bean的字段或方法。此注释允许Spring解析并将bean注入到bean中。有关详细信息，请参阅本教程。 Q22. What is the Role of the @Qualifier Annotation? 它与@Autowired注释同时使用，以避免在存在多个bean类型的实例时出现混淆。我们来看一个例子。我们在XML配置中声明了两个类似的bean： 123456&lt;bean id=\"person1\" class=\"com.baeldung.Person\" &gt; &lt;property name=\"name\" value=\"Joe\" /&gt;&lt;/bean&gt;&lt;bean id=\"person2\" class=\"com.baeldung.Person\" &gt; &lt;property name=\"name\" value=\"Doe\" /&gt;&lt;/bean&gt; 当我们尝试连接bean时，我们将得到一个org.springframework.beans.factory.NoSuchBeanDefinitionException。要解决它，我们需要使用@Qualifier来告诉Spring应该连接哪个bean： Q23. How to handle exceptions in Spring MVC environment? Spring MVC中有三种处理异常的方法： 在控制器级别使用@ExceptionHandler - 此方法具有一个主要功能 - @ExceptionHandler注释方法仅对该特定控制器有效，而不是整个应用程序的全局 使用HandlerExceptionResolver - 这将解决应用程序抛出的任何异常 使用@ControllerAdvice - Spring 3.2为带有@ControllerAdvice注释的全局@ExceptionHandler提供了支持，该注释启用了一种从旧的MVC模型中脱离出来的机制，并利用ResponseEntity以及@ExceptionHandler的类型安全性和灵活性 Q24. How to validate if the bean was initialized using valid values? Spring支持基于JSR-303注释的验证。 JSR-303是用于bean验证的Java API的规范，它是JavaEE和JavaSE的一部分，它确保bean的属性符合特定条件，使用注释（如@NotNull，@Min和@Max）。关于JSR-303的文章可在这里找到。此外，Spring提供了用于创建自定义验证器的验证器界面。例如，你可以看看这里。 Q25. What is Spring MVC Interceptor and how to use it? Spring MVC拦截器允许我们拦截一个客户端请求并在处理，处理或完成之后（视图呈现时）处理三个请求。 拦截器可用于交叉切换问题，并避免重复的处理程序代码，如日志记录，更改Spring模型中的全局使用参数等。 有关详细信息和各种实现，请查看本系列。 Q26. What is a Controller in Spring MVC? 简单地说，DispatcherServlet处理的所有请求都被定向到用@Controller注释的类。每个控制器类将一个或多个请求映射到使用提供的输入来处理和执行请求的方法。如果您需要退后一步，我们建议您在典型的Spring MVC架构中查看Front Controller的概念。 4. Spring Web Q27. How does the @RequestMapping annotation work? @RequestMapping注释用于将Web请求映射到Spring Controller方法。除了简单的用例之外，我们还可以使用它来映射HTTP头，将URI的部分绑定到@PathVariable，并使用URI参数和@RequestParam注释。 Q28. What’s the Difference Between @Controller, @Component, @Repository, and @Service Annotations in Spring? 根据官方的Spring文档，@Component是任何Spring管理的组件的通用构造型。 @Repository，@Service和@Controller分别是针对更多特定用例的@Component的特殊化，例如，在持久性，服务和表示层中。 @Controller - 表示该类用于控制器的角色，并在类中检测@RequestMapping注释 @Service - 表示该类保存业务逻辑，并在存储库层中调用方法 @Repository - 表示该类定义了数据存储库;它的任务是捕获特定于平台的异常，并将其重新抛弃为Spring统一的未经检查的异常之一 Q29. What are DispatcherServlet and ContextLoaderListener? 简单地说，在前端控制器设计模式中，单个控制器负责将传入的HttpRequest引导到所有应用程序的其他控制器和处理程序。 Spring的DispatcherServlet实现了这种模式，因此负责正确地协调HttpRequests到正确的处理程序。 另一方面，ContextLoaderListener启动并关闭Spring的根WebApplicationContext。它将ApplicationContext的生命周期与ServletContext的生命周期联系起来。我们可以使用它来定义在不同的Spring上下文中工作的共享bean。 Q30. What is ViewResolver in Spring? ViewResolver使应用程序能够在浏览器中呈现模型，而不将实现与特定的视图技术相结合 - 通过将视图名称映射到实际视图。 Q31. What is a MultipartResolver and when is it used? MultipartResolver接口用于上传文件。 Spring框架提供了一个MultipartResolver实现，用于Commons FileUpload，另一个用于Servlet 3.0 multipart请求解析。 使用这些，我们可以在我们的Web应用程序中支持文件上传。 5. Spring Data Access Q32. What is Spring JDBCTemplate class and how to use it? Spring JDBC模板是主要API，通过它可以访问我们感兴趣的数据库操作逻辑： creation and closing of connections executing statements and stored procedure calls iterating over the ResultSet and returning results 要使用它，我们需要定义DataSource的简单配置： 1234567891011121314@Configuration@ComponentScan(\"org.baeldung.jdbc\")public class SpringJdbcConfig &#123; @Bean public DataSource mysqlDataSource() &#123; DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\"); dataSource.setUrl(\"jdbc:mysql://localhost:3306/springjdbc\"); dataSource.setUsername(\"guest_user\"); dataSource.setPassword(\"guest_password\"); return dataSource; &#125;&#125; Q33. How would you enable transactions in Spring and what are their benefits? 配置事务有两种不同的方式 - 注释或使用面向对象编程（AOP） - 每个都有其优点。 根据官方文档，使用Spring Transactions的好处是： 在不同的事务API（如JTA，JDBC，Hibernate，JPA和JDO）之间提供一致的编程模型 支持声明式事务管理 为程序化事务管理提供比一些复杂的事务API（如JTA）更简单的API 与Spring的各种数据访问抽象集成很好 Q34. What is Spring DAO? Spring数据访问对象是Spring提供的支持，以一致和简单的方式处理JDBC，Hibernate和JPA等数据访问技术。 6. Spring Aspect-Oriented Programming (AOP) 通过为已经存在的代码添加额外的行为而不修改受影响的类，方面可以实现横向关注的模块化，例如跨多个类型和对象的事务管理。以下是基于方面的执行时间记录的示例 Q36. What are Aspect, Advice, Pointcut, and JoinPoint in AOP? Aspect 一个类实现横切关注点,如事务管理 Advice 在应用程序中达到具有匹配Pointcut的特定JoinPoint时执行的方法 Pointcut 一组与JoinPoint匹配的正则表达式，以确定是否需要执行Advice JoinPoint 在执行程序期间的一点，例如执行方法或处理异常 Q37. What is Weaving?根据官方文档,织入是一个将切面与其他应用程序类型或对象链接以创建建议的对象的过程。可以在编译时,加载时间,或者在运行时。Spring AOP,像其他纯Java的AOP框架,在运行时执行织入。 6. Conclusion在这篇广泛的文章中，我们探讨了关于Spring的一些技术面试的一些最重要的问题。我们希望这篇文章能够在即将到来的Spring面试中帮助您。祝你好运！","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"springboot actuator","date":"2017-06-23T01:35:06.064Z","path":"2017/06/23/springboot actuator/","text":"Spring Boot Actuator: A Complete Guide1. Overview 在本文中，我们将介绍Spring Boot Actuator，并讨论在生产过程中使用它们的一些简单方法。 如果要对端点进行增强的控制，包括调整灵敏度和安全性，则应该熟悉Spring Boot Actuator及其工具。 Spring Boot Actuator是Spring Boot的子项目。它为您的应用程序提供了几个生产级服务开箱即用，一旦您的Spring Boot应用程序中配置了Actuator，您可以通过调用Spring Boot Actuator公开的不同HTTP端点来交互和监视应用程序，例如应用程序运行状况，bean详细信息，版本详细信息，配置，记录器详细信息等。 Spring Boot包括许多内置端点，您还可以添加自己的或甚至配置现有端点，以暴露在您选择的任何自定义端点上。很明显，所有的端点都不能被公开曝光，因为有许多敏感端点，如bean，env等。 因此，Spring Boot还会通过HTTP访问需要用户名/密码的许多端点（或者如果Web安全性未启用，则简单禁用），将敏感默认设置为true。健康和信息默认不敏感。 What is an Actuator?执行器使Spring Boot应用程序的生产就绪功能无需实际自动实现。它们主要用于暴露有关正在运行的应用程序的不同类型的信息 - 健康，指标，信息，转储，环境等。虽然这些信息不能替代生产级监控解决方案 - 它们是一个非常好的起点。 How to Enable Spring Boot Actuator这很容易您只需要在现有的pom.xml文件中包含以下maven依赖关系： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; Different Actuator Endpoints一旦上述Maven依赖关系包含在POM文件中，就会显示16个不同的执行器REST端点，例如执行器，bean，转储，信息，记录器和度量。 端点允许您监视应用程序，在某些情况下也可以与其进行交互。该引导带有许多内置端点，并且像Spring中的任何东西一样，您也可以自己滚动。这里有一些最常见的端点Boot提供开箱即用： /health – Shows application health information (a simple ‘status’ when accessed over an unauthenticated connection or full message details when authenticated). It is not sensitive by default. /info – Displays arbitrary application info. Not sensitive by default. metrics – Shows ‘metrics’ information for the current application. It is also sensitive by default. /trace – Displays trace information (by default the last few HTTP requests). 如果您使用Spring MVC，那么还有四个附加端点 docs，heapdump，jolokia和logfile可以使用。 Customizing Existing EndpointsEach endpoint can be customized with properties using the following format: endpoints.[endpoint name].[property to customize] 有三个属性可用： id - 通过HTTP访问此端点 enabled - 如果为真，那么能够访问否则不能访问 sensitive - 如果为真，则需要授权来通过HTTP显示重要信息的 例如，添加以下属性将自定义/ beans端点： 123endpoints.beans.id=springbeansendpoints.beans.sensitive=falseendpoints.beans.enabled=true /health Endpoint/ health端点用于检查正在运行的应用程序的运行状况。基本的监控软件通常使用它来提醒您，如果生产下降。 默认情况下只有健康信息能被未经授权HTTP进行显示为 123&#123; \"status\" : \"UP\"&#125; 此健康信息是从在应用程序上下文中配置的HealthIndicator接口的所有Bean收集的。HealthIndicator返回的一些信息本质上是敏感的 - 但是您可以配置endpoints.health.sensitive = false来公开其他信息，如磁盘空间，数据源等。 A Custom HealthIndicator您还可以自定义运行状况指示器 - 它可以收集特定于应用程序的任何类型的自定义运行状况数据，并将其提供给/ health端点： 123456789101112131415161718@Componentpublic class HealthCheck implements HealthIndicator &#123; @Override public Health health() &#123; int errorCode = check(); // perform some specific health check if (errorCode != 0) &#123; return Health.down() .withDetail(\"Error Code\", errorCode).build(); &#125; return Health.up().build(); &#125; public int check() &#123; // Your logic to check health return 0; &#125;&#125; 输出如下所示： 12345678910111213&#123; \"status\" : \"DOWN\", \"myHealthCheck\" : &#123; \"status\" : \"DOWN\", \"Error Code\" : 1, \"Description\" : \"You custom MyHealthCheck endpoint is down\" &#125;, \"diskSpace\" : &#123; \"status\" : \"UP\", \"free\" : 209047318528, \"threshold\" : 10485760 &#125;&#125; /info Endpoint您还可以自定义/ info端点显示的数据，例如： 123info.app.name=Spring Sample Applicationinfo.app.description=This is my first spring boot applicationinfo.app.version=1.0.0 输出是： 1234567&#123; \"app\" : &#123; \"version\" : \"1.0.0\", \"description\" : \"This is my first spring boot application\", \"name\" : \"Spring Sample Application\" &#125;&#125; /metrics Endpoint指标端点是收集和发布有关操作系统，JVM和应用程序级度量信息的更重要的端点之一;开箱即用，我们可以得到内存，堆，处理器，线程，加载的类，卸载的类，线程池以及一些HTTP指标。 这个端点的输出看起来像这样： 1234567891011121314151617181920212223242526&#123; \"mem\" : 193024, \"mem.free\" : 87693, \"processors\" : 4, \"instance.uptime\" : 305027, \"uptime\" : 307077, \"systemload.average\" : 0.11, \"heap.committed\" : 193024, \"heap.init\" : 124928, \"heap.used\" : 105330, \"heap\" : 1764352, \"threads.peak\" : 22, \"threads.daemon\" : 19, \"threads\" : 22, \"classes\" : 5819, \"classes.loaded\" : 5819, \"classes.unloaded\" : 0, \"gc.ps_scavenge.count\" : 7, \"gc.ps_scavenge.time\" : 54, \"gc.ps_marksweep.count\" : 1, \"gc.ps_marksweep.time\" : 44, \"httpsessions.max\" : -1, \"httpsessions.active\" : 0, \"counter.status.200.root\" : 1, \"gauge.response.root\" : 37.0&#125; Custom Metric Data这里实际上支持’gauge‘ - 单值数据和’counter‘ - 递增/递减数据类型的度量。我们利用一些这样的支持来将我们自己的自定义数据实现到/ metrics端点。 例如 - 我们将自定义登录流程以记录成功和失败的日志尝试： 123public interface LoginService &#123; public boolean login(String userName, char[] password);&#125; 真正实现的时候，我们来增加相应的计数器： 1234567891011121314151617181920212223@Servicepublic class LoginServiceImpl implements LoginService &#123; private CounterService counterService; @Autowired public LoginServiceImpl(CounterService counterService) &#123; this.counterService = counterService; &#125; public boolean login(String userName, char[] password) &#123; boolean success; if (userName.equals(\"admin\") &amp;&amp; \"secret\".toCharArray().equals(password)) &#123; counterService.increment(\"counter.login.success\"); success = true; &#125; else &#123; counterService.increment(\"counter.login.failure\"); success = false; &#125; return success; &#125;&#125; 以下是输出的内容： 123456&#123; ... \"counter.login.success\" : 105, \"counter.login.failure\" : 12, ...&#125; Create A New Endpoint除了使用Spring Boot提供的现有端点外，您还可以创建一个全新的端点。 首先 - 您需要使新的端点实现实现Endpoint interface: 1234567891011121314151617181920212223@Componentpublic class CustomEndpoint implements Endpoint&lt;List&lt;String&gt;&gt; &#123; public String getId() &#123; return \"customEndpoint\"; &#125; public boolean isEnabled() &#123; return true; &#125; public boolean isSensitive() &#123; return true; &#125; public List&lt;String&gt; invoke() &#123; // Custom logic to build the output List&lt;String&gt; messages = new ArrayList&lt;String&gt;(); messages.add(\"This is message 1\"); messages.add(\"This is message 2\"); return messages; &#125;&#125; 访问此新端点的方式是其id，在/ customEndpoint。 输出： [ “This is message 1”, “This is message 2” ] A New Endpoint To List All Endpoints另一个有趣的定制端点是暴露所有可用端点的定制端点。要实现这个，你需要扩展AbstractEndpoint 类： 1234567891011121314@Componentpublic class ListEndpoints extends AbstractEndpoint&lt;List&lt;Endpoint&gt;&gt; &#123; private List&lt;Endpoint&gt; endpoints; @Autowired public ListEndpoints(List&lt;Endpoint&gt; endpoints) &#123; super(\"listEndpoints\"); this.endpoints = endpoints; &#125; public List&lt;Endpoint&gt; invoke() &#123; return this.endpoints; &#125;&#125; 输出如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152[ &#123; \"id\" : \"customEndpoint\", \"enabled\" : true, \"sensitive\" : true &#125;, &#123; \"id\" : \"mappings\", \"sensitive\" : true, \"enabled\" : true &#125;, &#123; \"id\" : \"env\", \"sensitive\" : true, \"enabled\" : true &#125;, &#123; \"id\" : \"myhealth\", \"sensitive\" : true, \"enabled\" : true, \"timeToLive\" : 1000 &#125;, &#123; \"id\" : \"beans\", \"sensitive\" : true, \"enabled\" : true &#125;, &#123; \"id\" : \"info\", \"sensitive\" : false, \"enabled\" : true &#125;, &#123; \"id\" : \"metrics\", \"sensitive\" : true, \"enabled\" : true &#125;, &#123; \"id\" : \"trace\", \"sensitive\" : true, \"enabled\" : true &#125;, &#123; \"id\" : \"dump\", \"sensitive\" : true, \"enabled\" : true &#125;, &#123; \"id\" : \"autoconfig\", \"sensitive\" : true, \"enabled\" : true &#125;, &#123; \"id\" : \"shutdown\", \"sensitive\" : true, \"enabled\" : true &#125;, &#123; \"id\" : \"configprops\", \"sensitive\" : true, \"enabled\" : true &#125; ] Further Customization为了安全起见，您可以选择通过非标准端口公开执行器端点 - 可以轻松地使用manage.port属性进行配置。 您还可以更改management.address属性以限制通过网络访问端点的位置： 123management.port=8081management.address=127.0.0.1management.security.enabled=false 默认情况下，除/ info之外的所有内置端点都很敏感。如果应用程序使用Spring Security，您可以通过在application.properties文件中定义默认安全属性（用户名，密码和角色）来保护这些端点： 123security.user.name=adminsecurity.user.password=secretmanagement.security.role=SUPERUSER 除此之外，您还可以自定义全局端点。以下示例将所有端点标记为敏感的，信息除外。 12endpoints.sensitive=trueendpoints.info.sensitive=false Securing Actuator Endpoints正如我们所看到的，只有两个端点，健康和信息，默认情况下不敏感。但是其他端点（如记录器和bean）是敏感的，因此需要授权才能访问。要访问这些敏感端点，您可以禁用灵敏度或使用Spring Security进行保护。 要确保加强执行器端点的安全，请在您的pom.xml文件中包含以下maven依赖关系。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 在Spring Boot中，包括上述依赖关系将默认提供内置的基于用户身份的基于表单的身份验证和随机生成的密码。然后需要以下条目来启用敏感端点的基本安全性。 1234management.security.enabled=truesecurity.basic.enabled=truesecurity.user.name=adminsecurity.user.password=admin 要访问执行器限制的端点，必须具有ACTUATOR角色。它是一个默认配置。 除此之外，您还可以通过扩展Spring提供的WebSecurityConfigurerAdapter类来使用AuthenticationManagerBuilder来保护执行器REST端点。以下是使用AuthenticationManagerBuilder的完整实现。 Creating a Custom Actuator EndpointSpring最好的一点是，它总是鼓励开发人员提出自己的配置和实现 - 这也是执行端点的情况。要自定义端点并定义自己的端点，只需实现端点接口并覆盖其方法。就这样，你完成了自己的端点（endpoints） 以下是在Spring Actuator中定义自定义端点的简单代码片段。它可以在/ showendpoints访问 12345678910111213141516import org.springframework.boot.actuate.endpoint.AbstractEndpoint;import org.springframework.boot.actuate.endpoint.Endpoint;import org.springframework.stereotype.Component;import java.util.List;@Componentpublic class ListEndPoints extends AbstractEndpoint&lt;List&lt;Endpoint&gt;&gt; &#123; private List&lt;Endpoint&gt; endpoints; public ListEndPoints(List&lt;Endpoint&gt; endpoints) &#123; super(\"showendpoints\"); this.endpoints = endpoints; &#125; @Override public List&lt;Endpoint&gt; invoke() &#123; return this.endpoints; &#125;&#125;","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"springSecurity for a rest api","date":"2017-06-23T01:35:01.007Z","path":"2017/06/23/springSecurity for a rest api/","text":"Spring Security for a REST API1. Overview 本教程将介绍如何使用基于Java的配置使用Spring和Spring Security 4来保护REST服务。本文将重点介绍如何使用登录和Cookie方法专门为REST API设置安全配置。 2. Spring Security in the web.xml Spring Security的架构完全基于Servlet过滤器，因此在Spring MVC之前就处理HTTP请求而言。考虑到这一点，首先，需要在应用程序的web.xml中声明一个过滤器： 12345678&lt;filter&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 必须将该过滤器命名为“springSecurityFilterChain”以匹配Spring Security在容器中创建的默认bean。 请注意，定义的过滤器不是实现安全逻辑的实际类，而是DelegatingFilterProxy，目的是将Filter的方法委派给内部bean。这样做是为了使目标bean仍然可以从Spring上下文生命周期和灵活性中受益。 用于配置过滤器的URL模式是/ ，即使整个Web服务映射到/ api / ，以便安全配置可以选择在需要时保护其他可能的映射。 3. The Java Security Configuration Java配置将如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Configuration@EnableWebSecurity@ComponentScan(\"org.baeldung.security\")public class SecurityJavaConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private RestAuthenticationEntryPoint restAuthenticationEntryPoint; @Autowired private MySavedRequestAwareAuthenticationSuccessHandler authenticationSuccessHandler; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.inMemoryAuthentication() .withUser(\"temporary\").password(\"temporary\").roles(\"ADMIN\") .and() .withUser(\"user\").password(\"userPass\").roles(\"USER\"); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http .csrf().disable() .exceptionHandling() .authenticationEntryPoint(restAuthenticationEntryPoint) .and() .authorizeRequests() .antMatchers(\"/api/foos\").authenticated() .and() .formLogin() .successHandler(authenticationSuccessHandler) .failureHandler(new SimpleUrlAuthenticationFailureHandler()) .and() .logout(); &#125; @Bean public MySavedRequestAwareAuthenticationSuccessHandler mySuccessHandler()&#123; return new MySavedRequestAwareAuthenticationSuccessHandler(); &#125; @Bean public SimpleUrlAuthenticationFailureHandler myFailureHandler()&#123; return new SimpleUrlAuthenticationFailureHandler(); &#125;&#125; Conclusion 本文介绍了使用Spring Security 4的RESTful Service的基本安全配置和实现，讨论了web.xml，安全配置，身份验证过程的HTTP状态代码以及安全工件的Maven解析。","tags":[{"name":"springSecurity","slug":"springSecurity","permalink":"http://yoursite.com/tags/springSecurity/"}]},{"title":"Spring DataIntegrityViolationException","date":"2017-06-23T01:34:48.649Z","path":"2017/06/23/Spring DataIntegrityViolationException/","text":"SpringDataIntegrityViolationException1.概述在这片文章中，我们会讨论关于Spring的异常： Spring org.springframework.beans.factory.DataIntegrityViolationException 这是处理较低级持久异常时通常由Spring异常转换机制抛出的通用数据异常。 本文将讨论这种异常的最常见原因以及每个解决方案的解决方案 2.DataIntegrityViolationException and Spring Exception TranslationSpring异常转换机制可以透明地应用于用@Repository注释的所有bean - 通过在Context中定义一个异常转换bean后处理器bean 通过在Context中定义一个异常转换bean后处理器bean： 12&lt;bean id=\"persistenceExceptionTranslationPostProcessor\" class=\"org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor\" /&gt; Or in Java: 1234567@Configurationpublic class PersistenceHibernateConfig&#123; @Bean public PersistenceExceptionTranslationPostProcessor exceptionTranslation()&#123; return new PersistenceExceptionTranslationPostProcessor(); &#125;&#125; 默认情况下，在Spring中可用的较旧的持久性模板–HibernateTemplate，JpaTemplate等中也启用异常转换机制。 3.Where is DataIntegrityViolationException thrown3.1. DataIntegrityViolationException with Hibernate当Spring配置为Hibernate时，异常会抛出Spring-SessionFactoryUtils提供的异常转换层 - convertHibernateAccessException。 有三种可能的Hibernate异常可能会导致抛出DataIntegrityViolationException： org.hibernate.exception.ConstraintViolationException org.hibernate.PropertyValueException org.hibernate.exception.DataException 3.2. DataIntegrityViolationException With JPA当Spring配置为JPA作为其持久性提供程序时，DataIntegrityViolationException将抛出异常转换层中的Hibernate类，即EntityManagerFactoryUtils - convertJpaAccessExceptionIfPossible。 有一个JPA异常可能会触发要抛出的DataIntegrityViolationException - javax.persistence.EntityExistsException。 4. Cause: org.hibernate.exception.ConstraintViolationException这是迄今为止抛出DataIntegrityViolationException的最常见原因--Hibernate ConstraintViolationException表示操作违反了数据库完整性约束。 考虑以下示例 - 对于通过Parent和Child实体之间的显式外键列进行一对一映射，以下操作将失败： 12345678910@Test(expected = DataIntegrityViolationException.class)public void whenChildIsDeletedWhileParentStillHasForeignKeyToIt_thenDataException() &#123; Child childEntity = new Child(); childService.create(childEntity); Parent parentEntity = new Parent(childEntity); service.create(parentEntity); childService.delete(childEntity);&#125; 父实体具有子实体的外键 - 因此删除子代将破坏父对象上的外键约束，从而导致ConstraintViolationException由Spring在DataIntegrityViolationException中包装： 12345org.springframework.dao.DataIntegrityViolationException: could not execute statement; SQL [n/a]; constraint [null]; nested exception is org.hibernate.exception.ConstraintViolationException: could not execute statement at o.s.orm.h.SessionFactoryUtils.convertHibernateAccessException(SessionFactoryUtils.java:138)Caused by: org.hibernate.exception.ConstraintViolationException: could not execute statement 要解决这个问题，应该首先删除父项： 1234567891011@Testpublic void whenChildIsDeletedAfterTheParent_thenNoExceptions() &#123; Child childEntity = new Child(); childService.create(childEntity); Parent parentEntity = new Parent(childEntity); service.create(parentEntity); service.delete(parentEntity); childService.delete(childEntity);&#125; 5.Cause: org.hibernate.PropertyValueException这是DataIntegrityViolationException的更常见的一个原因- 在Hibernate中，这将导致一个持续存在问题的实体。实体有一个null属性，它用非空约束来定义。或者实体的关联可能引用了未保存的瞬时实例。 （unsaved, transient instance.） 例如，以下实体具有非空名称属性 - 123456789@Entitypublic class Foo &#123; ... @Column(nullable = false) private String name; ...&#125; 如果以下测试尝试使用空值持久化实体名称： 1234@Test(expected = DataIntegrityViolationException.class)public void whenInvalidEntityIsCreated_thenDataException() &#123; fooService.create(new Foo());&#125; 违反数据库集成约束，因此抛出DataIntegrityViolationException： 123456789101112org.springframework.dao.DataIntegrityViolationException: not-null property references a null or transient value: org.baeldung.spring.persistence.model.Foo.name; nested exception is org.hibernate.PropertyValueException: not-null property references a null or transient value: org.baeldung.spring.persistence.model.Foo.name at o.s.orm.h.SessionFactoryUtils.convertHibernateAccessException(SessionFactoryUtils.java:160)...Caused by: org.hibernate.PropertyValueException: not-null property references a null or transient value: org.baeldung.spring.persistence.model.Foo.name at o.h.e.i.Nullability.checkNullability(Nullability.java:103) 6.Cause: org.hibernate.exception.DataExceptionHibernate DataException表示无效的SQL语句 - 在该特定上下文中，该语句或数据出错。例如，使用之前的Foo实体，以下将触发此异常： 1234@Test(expected = DataIntegrityViolationException.class)public final void whenEntityWithLongNameIsCreated_thenDataException() &#123; service.create(new Foo(randomAlphabetic(2048)));&#125; 持久化数据类型为long的对象的实际异常是： 1234567org.springframework.dao.DataIntegrityViolationException: could not execute statement; SQL [n/a]; nested exception is org.hibernate.exception.DataException: could not execute statement at o.s.o.h.SessionFactoryUtils.convertHibernateAccessException(SessionFactoryUtils.java:143)...Caused by: org.hibernate.exception.DataException: could not execute statement at o.h.e.i.SQLExceptionTypeDelegate.convert(SQLExceptionTypeDelegate.java:71) 在这个特定的例子中，解决方案是指定名称的最大长度： 1@Column(nullable = false, length = 4096) 7.Cause: javax.persistence.EntityExistsException与Hibernate相似的是，EntityExistsException JPA异常也会被Spring异常转换包装成DataIntegrityViolationException。唯一的区别是，JPA本身已经是高级别，这使得JPA异常成为数据完整性违规的唯一潜在原因。 8.Potentially DataIntegrityViolationException在某些可能需要DataIntegrityViolationException的情况下，可能会抛出另一个异常 - 如果类路径中存在一个JSR-303验证器（如hibernate-validator 4或5），则会出现这种情况。在这种情况下，如果以下实体用名称的空值持久化，则不再会由持久层触发的数据完整性违例失败： 123456789@Entitypublic class Foo &#123; ... @Column(nullable = false) @NotNull private String name; ...&#125; 这是因为执行不会到达持久层 - 它会在使用javax.validation.ConstraintViolationException之前失败： javax.validation.ConstraintViolationException:Validation failed for classes [org.baeldung.spring.persistence.model.Foo]during persist time for groups [javax.validation.groups.Default, ]List of constraint violations:[ ConstraintViolationImpl{ interpolatedMessage=’may not be null’, propertyPath=name, rootBeanClass=class org.baeldung.spring.persistence.model.Foo, messageTemplate=’{javax.validation.constraints.NotNull.message}’}] at o.h.c.b.BeanValidationEventListener.validate(BeanValidationEventListener.java:159) at o.h.c.b.BeanValidationEventListener.onPreInsert(BeanValidationEventListener.java:94) 5.总结 …在本文末尾，我们应该有一个清晰的思路来浏览可能导致Spring中DataIntegrityViolationException异常的原因和问题，以及如何解决所有这些问题。 在Github项目中可以找到一些这些例外示例的实现这是一个基于Eclipse的项目，所以应该很容易导入和运行。","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"No bean named ‘springSecurityFilterChain’ is defined","date":"2017-06-23T01:34:43.494Z","path":"2017/06/23/No bean named ‘springSecurityFilterChain’ is defined/","text":"No bean named ‘springSecurityFilterChain’ is defined1. The Problem本文讨论了Spring Security配置问题 - 应用程序引导过程抛出以下异常： 123SEVERE: Exception starting filter springSecurityFilterChainorg.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named 'springSecurityFilterChain' is defined 2. The Cause这个异常的原因很简单 - Spring Security会查找一个名为springSecurityFilterChain（默认情况下）的bean，但是找不到它。这个bean是由web.xml中定义的主要Spring安全过滤器（DelegatingFilterProxy）所必需的： 12345678&lt;filter&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 这只是将其所有逻辑委托给springSecurityFilterChain bean的代理。 3. The Solution上下文中缺少此bean的最常见原因是安全性XML配置没有定义&lt;http&gt;元素： 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans:beans xmlns=\"http://www.springframework.org/schema/security\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:beans=\"http://www.springframework.org/schema/beans\" xmlns:sec=\"http://www.springframework.org/schema/security\" xsi:schemaLocation=\" http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security-3.1.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd\"&gt; &lt;/beans:beans&gt; 如果XML配置正在使用安全命名空间（如上例），则声明一个简单的&lt;http&gt;元素将确保过滤器bean被创建，并且所有启动都正确： 另一个可能的原因是安全配置根本不会导入到Web应用程序的整体上下文中。 如果安全XML配置文件名为springSecurityConfig.xml，请确保资源已导入： 1@ImportResource(&#123;\"classpath:springSecurityConfig.xml\"&#125;) 或在XML中 1&lt;import resource=\"classpath:springSecurityConfig.xml\" /&gt; 最后，可以在web.xml中更改过滤器bean的默认名称 - 通常使用Spring Security的现有过滤器： 12345678910&lt;filter&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;filter-class&gt; org.springframework.web.filter.DelegatingFilterProxy &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;targetBeanName&lt;/param-name&gt; &lt;param-value&gt;customFilter&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt; 4. Conclusion本文讨论了一个非常具体的Spring Security问题 - 缺少的过滤器链bean - 并显示了这个常见问题的解决方案。","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"Guide to Spring NonTransientDataAccessException","date":"2017-06-23T01:34:38.735Z","path":"2017/06/23/Guide to Spring NonTransientDataAccessException/","text":"Guide to Spring NonTransientDataAccessException1.概述在这个快速教程中，我们将介绍常见的NonTransientDataAccessException的最重要类型，并用示例来说明它们。 2.The Base Exception Class这个主异常类的子类表示被认为是非瞬时的或永久的与数据访问有关的异常。简单地说，这意味着，直到根本原因被解决——否则所有导致异常的方法的未来尝试都将失败。 3. DataIntegrityViolationException尝试修改数据时会引发NonTransientDataAccessException的这个子类型导致违反完整性约束 在我们的Foo类的例子中，name列被定义为不允许空值： 12@Column(nullable = false)private String name; 如果我们尝试保存一个实例而不设置名称的值，那么我们可以期待抛出一个DataIntegrityViolationException： 12345@Test(expected = DataIntegrityViolationException.class)public void whenSavingNullValue_thenDataIntegrityException() &#123; Foo fooEntity = new Foo(); fooService.create(fooEntity);&#125; 3.1. DuplicateKeyExceptionDataIntegrityViolationException的子类之一是DuplicateKeyException，当尝试使用已存在的主键或已经存在于具有唯一约束的列中的值（例如尝试插入两行）尝试保存记录时，会抛出此异常在foo表中，id为1： 123456@Test(expected = DuplicateKeyException.class)public void whenSavingDuplicateKeyValues_thenDuplicateKeyException() &#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(restDataSource); jdbcTemplate.execute(\"insert into foo(id,name) values (1,'a')\"); jdbcTemplate.execute(\"insert into foo(id,name) values (1,'b')\");&#125; 4. DataRetrievalFailureException当检索数据出现问题时，例如查找具有数据库中不存在的标识符的对象时，会抛出此异常。 例如，我们将使用JdbcTemplate类，该类具有抛出此异常的方法： 123456@Test(expected = DataRetrievalFailureException.class)public void whenRetrievingNonExistentValue_thenDataRetrievalException() &#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(restDataSource); jdbcTemplate.queryForObject(\"select * from foo where id = 3\", Integer.class);&#125; 4.1 IncorrectResultSetColumnCountException当尝试从表中检索多个列而不创建适当的RowMapper时，会抛出此异常子类： 123456@Test(expected = IncorrectResultSetColumnCountException.class)public void whenRetrievingMultipleColumns_thenIncorrectResultSetColumnCountException() &#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(restDataSource); jdbcTemplate.execute(\"insert into foo(id,name) values (1,'a')\"); jdbcTemplate.queryForList(\"select id,name from foo where id=1\", Foo.class); 4.2 IncorrectResultSizeDataAccessException当许多检索的记录与预期记录不同时，抛出此异常，例如，当期望单个整数值，但为查询检索两行时： 123456789@Test(expected = IncorrectResultSizeDataAccessException.class)public void whenRetrievingMultipleValues_thenIncorrectResultSizeException() &#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(restDataSource); jdbcTemplate.execute(\"insert into foo(name) values ('a')\"); jdbcTemplate.execute(\"insert into foo(name) values ('a')\"); jdbcTemplate.queryForObject(\"select id from foo where name='a'\", Integer.class);&#125; 5. DataSourceLookupFailureException无法获取指定的数据源时抛出此异常。例如，我们将使用JndiDataSourceLookup类来查找不存在的数据源： 123456@Test(expected = DataSourceLookupFailureException.class)public void whenLookupNonExistentDataSource_thenDataSourceLookupFailureException() &#123; JndiDataSourceLookup dsLookup = new JndiDataSourceLookup(); dsLookup.setResourceRef(true); DataSource dataSource = dsLookup.getDataSource(\"java:comp/env/jdbc/example_db\");&#125; 6. InvalidDataAccessResourceUsageException当资源访问不正确时，例如当用户缺少SELECT权限时，会抛出此异常。 为了测试这个异常，我们需要撤消用户的SELECT权限，然后运行一个SELECT查询： 1234567891011@Test(expected = InvalidDataAccessResourceUsageException.class)public void whenRetrievingDataUserNoSelectRights_thenInvalidResourceUsageException() &#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(restDataSource); jdbcTemplate.execute(\"revoke select from tutorialuser\"); try &#123; fooService.findAll(); &#125; finally &#123; jdbcTemplate.execute(\"grant select to tutorialuser\"); &#125;&#125; 请注意，我们正在恢复finally块中用户的权限。 6.1 BadSqlGrammarExceptionInvalidDataAccessResourceUsageException的一个非常常见的子类型是BadSqlGrammarException，当尝试运行具有无效SQL的查询时，它将抛出： 12345@Test(expected = BadSqlGrammarException.class)public void whenIncorrectSql_thenBadSqlGrammarException() &#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(restDataSource); jdbcTemplate.queryForObject(\"select * fro foo where id=3\", Integer.class);&#125; 7. CannotGetJdbcConnectionException当连接尝试通过JDBC失败时，例如数据库url不正确时，会抛出此异常。如果我们写下如下的URL： 1jdbc.url=jdbc:mysql:3306://localhost/spring_hibernate4_exceptions?createDatabaseIfNotExist=true 然后在尝试执行语句时将抛出CannotGetJdbcConnectionException： 12345@Test(expected = CannotGetJdbcConnectionException.class)public void whenJdbcUrlIncorrect_thenCannotGetJdbcConnectionException() &#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(restDataSource); jdbcTemplate.execute(\"select * from foo\");&#125; 8. Conclusion在这个非常到点的教程中，我们看了一些NonTransientDataAccessException类最常见的子类型。 在Github项目中可以找到一些这些例外示例的实现这是一个基于Eclipse的项目，所以应该很容易导入和运行。","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"Spring NoSuchBeanDefinitionException","date":"2017-06-23T01:34:33.660Z","path":"2017/06/23/Spring NoSuchBeanDefinitionException/","text":"Spring NoSuchBeanDefinitionException1.概述在这片文章中，我们会讨论关于Spring的异常： Spring org.springframework.beans.factory.NoSuchBeanDefinitionException 这是BeanFactory在尝试解析一个简单地在Spring Context中未定义的bean时抛出的常见异常。我们将说明这个问题和可用解决方案的可能原因。 2.Cause: No qualifying bean of type […] found for dependency这个异常最常见的原因是试图注入一个未定义的bean。例如 - BeanB是在一个协作者的连线–BanA： 1234567@Componentpublic class BeanA &#123; @Autowired private BeanB dependency; //...&#125; 现在，如果在Spring Context中没有定义依赖关系BeanB，引导过程将失败，并且产生the no such bean definition exception： 1234567org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [org.baeldung.packageB.BeanB] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: &#123;@org.springframework.beans.factory.annotation.Autowired(required=true)&#125; Spring已经很清楚的说明了原因：“expected at least 1 bean which qualifies as autowire candidate for this dependency“” BeanB在上下文中可能不存在的一个原因 - 如果通过类路径扫描自动获取bean，并且如果BeanB被正确地注解为bean（@Component，@Repository，@Service，@Controller等），那么它可能是在未被Spring扫描的包中定义： 123package org.baeldung.packageB;@Componentpublic class BeanB &#123; ...&#125; 然而类路径扫描可能配置如下： 12345@Configuration@ComponentScan(\"org.baeldung.packageA\")public class ContextWithJavaConfig &#123; ...&#125; 如果bean不是通过手动定义自动扫描，那么BeanB在当前的Spring Context中根本就没有定义。 3.Cause:No qualifying bean of type […] is defined异常的另一个原因是在上下文中存在两个bean定义，而不是一个。例如，如果接口 - IBeanB由两个Bean（BeanB1和BeanB2）实现： 12345678@Componentpublic class BeanB1 implements IBeanB &#123; //&#125;@Componentpublic class BeanB2 implements IBeanB &#123; //&#125; 现在，如果BeanA自动注入这个接口，Spring将不知道要注入的两个实现中的哪一个： 1234567@Componentpublic class BeanA &#123; @Autowired private IBeanB dependency; ...&#125; 再次，这将导致BeanFactory抛出NoSuchBeanDefinitionException 1234Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type [org.baeldung.packageB.IBeanB] is defined: expected single matching bean but found 2: beanB1,beanB2 同样，Spring明确指出了错误的原因：“希望一个bean 但是却发现了两个”。但是请注意，在这种情况下，抛出的确切异常不是NoSuchBeanDefinitionException，而是一个子类 - NoUniqueBeanDefinitionException。 在Spring 3.2.1中引入了这个新的异常，正是由于这个原因 - 区分了没有找到bean定义和在上下文中找到几个定义。 Before this change, the exception above was: 123Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [org.baeldung.packageB.IBeanB] is defined: expected single matching bean but found 2: beanB1,beanB2 这个问题的一个解决方案是使用@Qualifier注释来精确地指定要连接的bean的名称： 12345678@Componentpublic class BeanA &#123; @Autowired @Qualifier(\"beanB2\") private IBeanB dependency; ...&#125; 现在，Spring有足够的信息来决定要注入哪个bean - BeanB1或BeanB2（BeanB2的默认名称是beanB2）。 4. Cause: No Bean Named […] is defined4.1 自定义异常当从Spring上下文中的名称请求未定义的bean时，也可以抛出NoSuchBeanDefinitionException：1234567891011@Componentpublic class BeanA implements InitializingBean &#123; @Autowired private ApplicationContext context; @Override public void afterPropertiesSet() &#123; context.getBean(\"someBeanName\"); &#125;&#125; 在这种情况下，“someBeanName”没有bean定义，导致以下异常： 12Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named 'someBeanName' is defined Spring清楚简明地说明了失败的原因：“没有定义名为X的bean”。 5.Cause: Proxied Beans当使用JDK动态代理机制代理上下文中的bean时，代理将不会扩展目标bean（然而，它将实现相同的接口）。 因此，如果bean由一个接口注入，那么它将被正确地连接。但是，如果bean被实际的类注入，那么Spring将不会找到与该类匹配的bean定义 - 因为代理实际上并不是继承类 bean可能被代理的一个很常见的原因是Spring事务支持 - 即使用@Transactional注释的bean。 例如，如果ServiceA注入ServiceB，并且这两个服务都是事务性的，则类定义的注入将不起作用： 1234567891011121314@Service@Transactionalpublic class ServiceA implements IServiceA&#123; @Autowired private ServiceB serviceB; ...&#125; @Service@Transactionalpublic class ServiceB implements IServiceB&#123; ...&#125; 同样的两个服务，这个时候正确的注入接口就可以了： 1234567891011121314@Service@Transactionalpublic class ServiceA implements IServiceA&#123; @Autowired private IServiceB serviceB; ...&#125; @Service@Transactionalpublic class ServiceB implements IServiceB&#123; ...&#125; 5.总结 …本教程讨论了常见的NoSuchBeanDefinitionException的可能原因的示例，重点是如何在实践中解决这些异常 在Github项目中可以找到一些这些例外示例的实现这是一个基于Eclipse的项目，所以应该很容易导入和运行。","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"Dependency Injection with Spring","date":"2017-06-23T01:34:23.423Z","path":"2017/06/23/Dependency Injection with Spring/","text":"Intro to Inversion Control and Dependency Injection with Spring1. Overview在本文中，我们将介绍IoC（控制反转）和DI（依赖注入）的概念，然后我们将介绍如何在Spring框架中实现这些概念。 2. What is Inversion of Control?控制反转是软件工程中的一个原理，通过该原理将程序的对象或部分的控制转移到容器或框架。它最常用于面向对象编程的上下文中。 与传统的编程相比，我们的自定义代码调用库，IoC使框架能够控制程序的流程，并调用我们的自定义代码。为了使之成为可能，框架是通过抽象定义的，其中附加了一些行为。 如果我们想添加自己的行为，我们需要扩展我们自己的类的框架或插件的类。 这种架构的优点是： decoupling the execution of a task from its implementation 将任务的执行与其实现分离 making it easier to switch between different implementations 使其更容易在不同的实现之间切换 greater modularity of a program 更大的程序模块化 greater ease in testing a program by isolating a component or mocking its dependencies and allowing components to communicate through contracts 通过隔离组件或模仿假数据其依赖性并允许组件通过约定进行通信来更容易地测试程序 可以通过各种机制实现控制反转：策略设计模式，服务定位器模式，工厂模式和依赖注入（DI）。 3. What is Dependency Injection?依赖注入是实现IoC的一种模式，其中控制被反转是设置对象的依赖关系。将对象与其他对象连接的行为，或将对象“注入”到其他对象中，由汇编程序而不是对象本身完成。以下是传统编程中创建对象依赖关系的方法： 1234567public class Store &#123; private Item item; public Store() &#123; item = new ItemImpl1(); &#125;&#125; 在上面的示例中，您可以看到，为了实例化Store对象的项依赖关系，您必须指定在Store类本身中将使用的接口Item的实现。 通过使用DI，我们可以重写示例而不指定我们想要的Item的实现： 123456public class Store &#123; private Item item; public Store(Item item) &#123; this.item = item; &#125;&#125; 然后将通过元数据提供要注入的项目的实现，我们将在下面的示例中看到。IoC和DI都是简单的概念，但是对我们系统构建的方式有深刻的影响，所以理解他们是非常有价值的。 4. The Spring IoC ContainerIoC容器是实现IoC的框架的常见特征。 在Spring框架中，IoC容器由ApplicationContext接口表示。 Spring容器负责实例化，配置和组装称为bean的对象，以及管理其生命周期。 Spring框架提供了ApplicationContext接口的几个实现 用于独立应用程序的ClassPathXmlApplicationContext和FileSystemXmlApplicationContext，Web应用程序的WebApplicationContext。 为了组装bean，容器使用配置元数据，其可以是XML配置或注释的形式。 以下是手动实例化容器的一种方式： 12ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); 5. Dependency Injection in Spring为了在上面的例子中设置item属性，我们可以使用将在运行时由Spring容器组装对象的元数据 Spring中的依赖注入可以通过构造函数或设置器（setters）完成。 5.1. Constructor-Based Dependency Injection 在基于构造函数的依赖注入的情况下，容器将调用一个构造函数，其中每个变量都表示我们要设置的依赖关系。解析每个参数主要由参数的类型，后跟名称的属性和索引消歧。 bean的配置及其依赖关系可以使用注释来完成： 12345678910111213@Configurationpublic class AppConfig &#123; @Bean public Item item1() &#123; return new ItemImpl1(); &#125; @Bean public Store store() &#123; return new Store(item1()); &#125;&#125; @Configuration注释表明该类是一个bean定义的源，可以在多个配置类中使用。 @Bean注释用于定义一个bean的方法。如果不指定自定义名称，将使用方法名称。 如果使用Bean的默认单例范围，则每次调用使用@Bean注释的方法时，Spring首先检查该bean的缓存实例是否已存在，并且仅在不存在的情况下创建一个新的实例。如果指定了原型范围，则为该方法的每次调用返回一个新的bean实例。 创建bean的另一种方法是通过XML配置： 1234&lt;bean id=\"item1\" class=\"org.baeldung.store.ItemImpl1\" /&gt; &lt;bean id=\"store\" class=\"org.baeldung.store.Store\"&gt; &lt;constructor-arg type=\"ItemImpl1\" index=\"0\" name=\"item\" ref=\"item1\" /&gt; &lt;/bean&gt; 5.2. Setter-Based Dependency Injection 对于基于setter的DI，容器将在调用无参数构造函数或无参数静态工厂方法来实例化bean之后调用类的setter方法。让我们用注释创建这个配置： 123456@Beanpublic Store store() &#123; Store store = new Store(); store.setItem(item1()); return store;&#125; 我们也可以使用XML来进行相同的Bean配置： 123&lt;bean id=\"store\" class=\"org.baeldung.store.Store\"&gt; &lt;property name=\"item\" ref=\"item1\" /&gt;&lt;/bean&gt; 基于构造器和基于setter的注射类型可以组合为同一个bean。 Spring文档建议使用基于构造函数的注入用于强制依赖，以及基于setter的注入为可选的注入。 5.3. Autowiring Dependencies 装配允许Spring容器通过检查已定义的bean来自动解决协作bean之间的依赖关系。 使用XML配置自动连接一个bean的四种模式： no：默认值 - 这意味着没有自动连接用于bean，并且必须明确命名依赖关系 byName：根据属性的名称完成自动装配，因此Spring将寻找与需要设置的属性具有相同名称的bean byType： 类似于byName的自动装配，只能基于属性的类型，这意味着Spring会寻找一个具有相同属性类型的bean来设置;如果找到多个这种类型的bean，框架会引发异常 constructor：自动装配是基于构造函数参数完成的，这意味着Spring将寻找与构造函数参数相同类型的bean 例如，让我们通过类型将上面定义的item1 bean自动连接到store bean： 123456789@Bean(autowire = Autowire.BY_TYPE)public class Store &#123; private Item item; public setItem(Item item)&#123; this.item = item; &#125;&#125; 您还可以使用@Autowired注释来自动注册bean，方法是输入以下类型： 12345public class Store &#123; @Autowired private Item item;&#125; 如果有多个同一类型的bean，您可以添加@Qualifier注释以通过名称引用bean： 123456public class Store &#123; @Autowired @Qualifier(\"item1\") private Item item;&#125; 让我们通过XML配置按类型自动连接bean： 1&lt;bean id=\"store\" class=\"org.baeldung.store.Store\" autowire=\"byType\"&gt; &lt;/bean&gt; 现在让我们通过XML将名为item的bean注入到store bean的item属性中： 1234&lt;bean id=\"item\" class=\"org.baeldung.store.ItemImpl1\" /&gt; &lt;bean id=\"store\" class=\"org.baeldung.store.Store\" autowire=\"byName\"&gt;&lt;/bean&gt; 还可以通过使用构造函数参数或设置器明确定义依赖关系来覆盖自动装配。 5.4. Lazy Initialized Beans 默认情况下，容器在初始化期间创建并配置所有单例Bean。为了避免这种情况，您可以在bean配置中指定值为true的lazy-init属性： 1&lt;bean id=\"item1\" class=\"org.baeldung.store.ItemImpl1\" lazy-init=\"true\" /&gt; 因此，item1 bean只有在首次被请求时才被初始化，而不是在启动时被初始化。其优点是更快的初始化时间，但是权衡之处在于，只有在请求Bean之后才能发现配置错误，这可能是在应用程序已经运行几个小时甚至几天之后。 6. Conclusion 在本文中，我们介绍了控制反转和依赖注入的概念，并在Spring框架中作了例证。","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"Guide to Spring @Autowired","date":"2017-06-23T01:34:17.907Z","path":"2017/06/23/Guide to Spring @Autowired/","text":"1.Overview从Spring 2.5开始，该框架引入了由@Autowired注释驱动的新型依赖注入。此注释允许Spring解析并将bean注入到bean中。 在本教程中，我们将介绍如何启用自动装配，以多种方式连接bean，使bean可选，使用@Qualifier注释解决bean冲突以及潜在的异常情况。 2. Enabling @Autowired Annotations如果您在应用程序中使用基于Java的配置，则可以通过使用AnnotationConfigApplicationContext来加载spring配置来启用注释驱动的注入，如下所示： 123@Configuration@ComponentScan(\"com.baeldung.autowire.sample\")public class AppConfig &#123;&#125; 或者，在Spring XML中，可以通过在Spring XML文件中声明它来实现： 3. Using @Autowired注释注入启用后，可以在属性，设置器和构造函数上使用自动装配。 3.1. @Autowired on Properties注释可以直接用于属性，因此不需要getter和setter： 1234567@Component(\"fooFormatter\")public class FooFormatter &#123; public String format() &#123; return \"foo\"; &#125;&#125; 1234567@Componentpublic class FooService &#123; @Autowired private FooFormatter fooFormatter; &#125; 在上面的例子中，Spring创建FooService时，寻找并注入fooFormatter。 3.2. @Autowired on Setters@Autowired注释可以用于setter方法。在下面的示例中，当在setter方法上使用注释时，在创建FooService时，setter方法将使用FooFormatter的实例调用： 123456789public class FooService &#123; private FooFormatter fooFormatter; @Autowired public void setFooFormatter(FooFormatter fooFormatter) &#123; this.fooFormatter = fooFormatter; &#125;&#125; 3.3. @Autowired on Constructors@Autowired注释也可以在构造函数上使用。在下面的示例中，当在构造函数上使用注释时，当创建FooService时，FooFormatter的实例将作为参数注入构造函数中： 123456789public class FooService &#123; private FooFormatter fooFormatter; @Autowired public FooService(FooFormatter fooFormatter) &#123; this.fooFormatter = fooFormatter; &#125;&#125; 4. @Autowired and Optional DependenciesSpring希望在构建依赖bean时可以使用@Autowired依赖关系。如果框架无法解决用于装配的bean，它将抛出以下引用的异常并阻止Spring容器成功启动： 12345Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [com.autowire.sample.FooDAO] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: &#123;@org.springframework.beans.factory.annotation.Autowired(required=true)&#125; 为了避免这种情况发生，可以通过以下指定bean： 123456public class FooService &#123; @Autowired(required = false) private FooDAO dataAccessor; &#125; 5. Autowire Disambiguation(5.自动消除歧义)默认情况下，Spring按类型解析@Autowired条目。如果同一类型的多个bean在容器中可用，则框架将抛出​​一个致命的异常，指示有多个bean可用于自动装配。 5.1. Autowiring by @Qualifier@Qualifier注释可用于提示和缩小所需的bean： 1234567891011121314151617181920@Component(\"fooFormatter\")public class FooFormatter implements Formatter &#123; public String format() &#123; return \"foo\"; &#125;&#125;@Component(\"barFormatter\")public class BarFormatter implements Formatter &#123; public String format() &#123; return \"bar\"; &#125;&#125;public class FooService &#123; @Autowired private Formatter formatter; &#125; 由于Spring容器可以使用两种格式化的实现，所以在构建FooService时，Spring会抛出一个NoUniqueBeanDefinitionException异常： 123Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type [com.autowire.sample.Formatter] is defined: expected single matching bean but found 2: barFormatter,fooFormatter 这可以通过使用@Qualifier注释来缩小实现来避免： 1234567public class FooService &#123; @Autowired @Qualifier(\"fooFormatter\") private Formatter formatter; &#125; 通过使用具体实现的名称指定@Qualifier，在这种情况下，作为fooFormatter，当Spring找到同一类型的多个bean时，我们可以避免歧义。请注意，@Qualifier注释的值与我们的FooFormatter实现的@Component注释中声明的名称相匹配。 5.2。自定义限定符自动装配 5.2. Autowiring by Custom Qualifier (自定义限定符自动装配) Spring允许我们创建我们自己的@Qualifier注释。要创建自定义限定符，请定义注释，并在定义中提供@Qualifier注释，如下所示 123456789@Qualifier@Target(&#123; ElementType.FIELD, ElementType.METHOD, ElementType.TYPE, ElementType.PARAMETER&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface FormatterType &#123; String value(); &#125; 一旦定义，可以在各种实现中使用FormatterType来指定自定义值： 12345678@FormatterType(\"Foo\")@Componentpublic class FooFormatter implements Formatter &#123; public String format() &#123; return \"foo\"; &#125;&#125; 12345678@FormatterType(\"Bar\")@Componentpublic class BarFormatter implements Formatter &#123; public String format() &#123; return \"bar\"; &#125;&#125; 一旦实现注释，自定义限定符注释可以如下使用： 12345678@Componentpublic class FooService &#123; @Autowired @FormatterType(\"Foo\") private Formatter formatter; &#125; @Target注释中指定的值限制限定词可用于标记注入点的位置。 在上面的代码片段中，限定符可以用于消除Spring可以将bean注入到字段，方法，类型和参数中的点。 5.2. Autowiring by Name作为回馈，Spring使用bean名称作为默认限定符值。 因此，通过定义bean属性名称，在这种情况下为fooFormatter，Spring与FooFormatter实现相匹配，并在构建FooService时注入该特定实现： 123456public class FooService &#123; @Autowired private Formatter fooFormatter; &#125; 6. Conclusion虽然@Qualifier和bean名称的后备匹配都可以用来缩小到一个特定的bean，但是自动装配实际上是关于按类型注入的，这是最好的方式来使用这个容器功能。","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"Error Handling for REST with Spring","date":"2017-06-23T01:34:12.538Z","path":"2017/06/23/Error Handling for REST with Spring/","text":"1. Overview本文将说明如何使用Spring为REST API实现异常处理。我们将在Spring 3.2和4.x中查看推荐的解决方案，但也可以使用较旧的选项。 在Spring 3.2之前，在Spring MVC应用程序中处理异常的两种主要方法是：HandlerExceptionResolver或@ExceptionHandler注释。这两个都有一些明显的缺点。 3.2之后，我们现在有了新的@ControllerAdvice注释来解决前面两个解决方案的局限性。 所有这些都有一个共同点 - 他们处理分离问题非常好。应用程序可以正常抛出异常以指示某种类型的异常 - 然后将单独处理异常。 2. Solution 1 – The Controller level @ExceptionHandler第一个解决方案在@Controller级别工作 - 我们将定义一个方法来处理异常，并用@ExceptionHandler注释它： 12345678public class FooController&#123; //... @ExceptionHandler(&#123; CustomException1.class, CustomException2.class &#125;) public void handleException() &#123; // &#125;&#125; 这种方法有一个主要的缺点 - @ExceptionHandler注释方法只对该特定的Controller有效，而不是整个应用程序的全局。当然，将它添加到每个控制器中使得它不适合一般的异常处理机制。 通过让所有的控制器扩展一个基本控制器类，这个限制通常会被解决 - 但是，无论何种原因，控制器都不能从这样一个类扩展，这可能是一个问题。例如，控制器可能已经从可能在另一个jar中的另一个基类扩展或者不可直接修改，或者本身不能直接修改。 接下来，我们将看另一种方法来解决异常处理问题 - 一个是全局的，不包括对现有工件（如Controllers）的任何更改。 3. Solution 2 – The HandlerExceptionResolver 第二个解决方案是定义一个HandlerExceptionResolver - 这将解决应用程序抛出的任何异常。它还将允许我们在REST API中实现一个统一的异常处理机制。 在进行自定义解析器之前，我们来看看现有的实现。 3.1. ExceptionHandlerExceptionResolver 该解析器在Spring 3.1中引入，默认情况下在DispatcherServlet中启用。这实际上是前面介绍的@ExceptionHandler机制的核心组件。 3.2. DefaultHandlerExceptionResolver 该解析器在Spring 3.0中引入，默认情况下在DispatcherServlet中启用。它用于将标准Spring异常解析为相应的HTTP状态代码，即客户端错误 - 4xx和服务器错误 - 5xx状态代码。以下是它处理的Spring异常的完整列表，以及它们如何映射到状态代码。 虽然它正确地设置了响应的状态代码，但一个限制是它没有对响应的正文设置任何内容。对于REST API，状态代码实际上还没有足够的信息呈现给客户端 - 响应也必须拥有一个机构，以允许应用程序提供关于故障的其他信息。 这可以通过使用ModelAndView配置View分辨率和渲染错误内容来解决，但解决方案显然不是最佳的 - 这就是Spring 3.2中提供了更好的选择的原因 - 我们将在本文的后半部分中讨论。 3.3. ResponseStatusExceptionResolver 此解析器也在Spring 3.0中引入，默认情况下在DispatcherServlet中启用。它的主要职责是使用可用于自定义异常的@ResponseStatus注释，并将这些异常映射到HTTP状态代码。 这样的自定义异常可能如下所示： 123456789101112131415@ResponseStatus(value = HttpStatus.NOT_FOUND)publi class ResourceNotFoundException extends RuntimeException &#123; public ResourceNotFoundException() &#123; super(); &#125; public ResourceNotFoundException(String message, Throwable cause) &#123; super(message, cause); &#125; public ResourceNotFoundException(String message) &#123; super(message); &#125; public ResourceNotFoundException(Throwable cause) &#123; super(cause); &#125;&#125; 与DefaultHandlerExceptionResolver相同，该解析器的处理方式受到响应的正文的限制 - 它会将状态代码映射到响应中，但主体仍为空。 3.4. SimpleMappingExceptionResolver and AnnotationMethodHandlerExceptionResolver SimpleMappingExceptionResolver已经存在了一段时间 - 它来自较早的Spring MVC模型，并且与REST服务不是非常相关。它用于映射异常类名称以查看名称。 AnnotationMethodHandlerExceptionResolver在Spring 3.0中引入，通过@ExceptionHandler注释来处理异常，但是从Spring 3.2开始，ExceptionHandlerExceptionResolver已经不推荐使用。 3.5. Custom HandlerExceptionResolver DefaultHandlerExceptionResolver和ResponseStatusExceptionResolver的组合对于为Spring RESTful服务提供一个很好的错误处理机制有很大的帮助。如前所述，缺点是无法控制响应的内容。 理想情况下，我们希望能够输出JSON或XML，具体取决于客户端要求的格式（通过Accept标头）。 下面来证明创建一个新的，自定义的异常解决 1234567891011121314151617181920212223242526@Componentpublic class RestResponseStatusExceptionResolver extends AbstractHandlerExceptionResolver &#123; @Override protected ModelAndView doResolveException (HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; try &#123; if (ex instanceof IllegalArgumentException) &#123; return handleIllegalArgument((IllegalArgumentException) ex, response, handler); &#125; ... &#125; catch (Exception handlerException) &#123; logger.warn(\"Handling of [\" + ex.getClass().getName() + \"] resulted in Exception\", handlerException); &#125; return null; &#125; private ModelAndView handleIllegalArgument (IllegalArgumentException ex, HttpServletResponse response) throws IOException &#123; response.sendError(HttpServletResponse.SC_CONFLICT); String accept = request.getHeader(HttpHeaders.ACCEPT); ... return new ModelAndView(); &#125;&#125; 要注意的一个细节是请求本身可用，因此应用程序可以考虑客户端发送的Accept标头的值。例如，如果客户端要求application / json，则在出现错误的情况下，应用程序仍然应该返回用application / json编码的响应主体。 另一个重要的实现细节是返回一个ModelAndView - 这是响应的正文，它将允许应用程序设置它所需的任何内容。 这种方法是用于Spring REST服务的错误处理的一致且易于配置的机制。然而，它有限制：它与低级别的HtttpServletResponse进行交互，它适合使用ModelAndView的旧MVC模型，因此仍有改进的余地。 4. New Solution 3 – The New @ControllerAdvice (Spring 3.2 And Above) Spring 3.2使用新的@ControllerAdvice注释来支持全局@ExceptionHandler。这使得能够脱离旧的MVC模型的机制，并使用ResponseEntity以及@ExceptionHandler的类型安全性和灵活性： 12345678910@ControllerAdvicepublic class RestResponseEntityExceptionHandler extends ResponseEntityExceptionHandler &#123; @ExceptionHandler(value = &#123; IllegalArgumentException.class, IllegalStateException.class &#125;) protected ResponseEntity&lt;Object&gt; handleConflict(RuntimeException ex, WebRequest request) &#123; String bodyOfResponse = \"This should be application specific\"; return handleExceptionInternal(ex, bodyOfResponse, new HttpHeaders(), HttpStatus.CONFLICT, request); &#125;&#125; 新的注释允许从之前的多个分散的@ExceptionHandler合并到一个单一的全局错误处理组件中。 实际机制非常简单，但也非常灵活： 它允许完全控制响应的body以及状态代码 它允许将几个异常映射到相同的方法，一起处理 它很好地利用了较新的RESTful ResposeEntity响应 需要注意的一件事是匹配用@ExceptionHandler声明的异常，并将异常用作该方法的参数。如果这些不匹配，编译器就不会抱怨 - 没有理由，Spring也不会抱怨。 但是，当运行时实际抛出异常时，异常解析机制将失败 12java.lang.IllegalStateException: No suitable resolver for argument [0] [type=...]HandlerMethod details: ... 5. Handle the Access Denied in Spring Security 访问被拒绝发生在经过身份验证的用户尝试访问他没有足够权限访问的资源时。 5.1. MVC – Custom Error Page 首先，让我们来看看解决方案的MVC风格，看看如何自定义访问被拒绝的错误页面： XML配置： 12345&lt;http&gt; &lt;intercept-url pattern=\"/admin/*\" access=\"hasAnyRole('ROLE_ADMIN')\"/&gt; ... &lt;access-denied-handler error-page=\"/my-error-page\" /&gt;&lt;/http&gt; And the Java configuration: 12345678@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .antMatchers(\"/admin/*\").hasAnyRole(\"ROLE_ADMIN\") ... .and() .exceptionHandling().accessDeniedPage(\"/my-error-page\");&#125; 当用户尝试访问资源而没有足够的权限时，他们将被重定向到“/ my-error-page”。 15.2. Custom AccessDeniedHandler Next, let’s see how to write our custom AccessDeniedHandler: 12345678910@Componentpublic class CustomAccessDeniedHandler implements AccessDeniedHandler &#123; @Override public void handle (HttpServletRequest request, HttpServletResponse response, AccessDeniedException ex) throws IOException, ServletException &#123; response.sendRedirect(\"/my-error-page\"); &#125;&#125; And now let’s configure it using XML Configuration: 12345&lt;http&gt; &lt;intercept-url pattern=\"/admin/*\" access=\"hasAnyRole('ROLE_ADMIN')\"/&gt; ... &lt;access-denied-handler ref=\"customAccessDeniedHandler\" /&gt;&lt;/http&gt; 或使用Java配置：@Autowiredprivate CustomAccessDeniedHandler accessDeniedHandler; 12345678@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .antMatchers(\"/admin/*\").hasAnyRole(\"ROLE_ADMIN\") ... .and() .exceptionHandling().accessDeniedHandler(accessDeniedHandler)&#125; 请注意，在我们的CustomAccessDeniedHandler中，我们可以通过重定向或显示自定义错误消息来自定义响应。 5.3. REST and Method Level Security 最后，我们来看看如何处理方法级别的安全性@PreAuthorize，@PostAuthorize和@Secure访问被拒绝。 我们当然会使用前面讨论过的全局异常处理机制来处理新的AccessDeniedException： 1234567891011@ControllerAdvicepublic class RestResponseEntityExceptionHandler extends ResponseEntityExceptionHandler &#123; @ExceptionHandler(&#123; AccessDeniedException.class &#125;) public ResponseEntity&lt;Object&gt; handleAccessDeniedException(Exception ex, WebRequest request) &#123; return new ResponseEntity&lt;Object&gt;( \"Access denied message here\", new HttpHeaders(), HttpStatus.FORBIDDEN); &#125; ...&#125; 6. Conclusion 本教程讨论了在Spring中实现REST API的异常处理机制的几种方法，从旧的机制开始，继续使用Spring 3.2支持，并进入4.0和4.1。","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"Introduction to Spring MVC HandlerInterceptor","date":"2017-06-23T01:34:05.000Z","path":"2017/06/23/Introduction to Spring MVC HandlerInterceptor/","text":"1. Introduction在本教程中，我们将专注于了解Spring MVC HandlerInterceptor以及如何正确使用它。 2. Spring MVC Handler为了了解拦截器，让我们退一步，看看HandlerMapping。这将一个方法映射到URL，以便DispatcherServlet在处理请求时能够调用它。 DispatcherServlet使用HandlerAdapter来真正的调用该方法。 现在我们了解整体上下文 - 这就是处理程序拦截器所在的位置。我们将在处理之前使用HandlerInterceptor，在处理完成之后或完成后（当视图呈现时）执行操作。 拦截器可用于交叉切换的问题，并避免重复的处理程序代码，如：日志记录，在Spring模型中更改全局使用的参数。 在接下来的几节中，正是我们将要看的 - 各种拦截器实现之间的差异。 3. Maven Dependencies为了使用Interceptor，您需要在pom.xml文件的依赖项部分中包含以下部分： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.3.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; 4. Spring Handler Interceptor在框架上使用HandlerMapping的拦截器必须实现HandlerInterceptor接口。 此接口包含三个主要方法： prehandle（） - 在执行实际处理程序之前调用，但视图尚未生成 postHandle（） - 执行处理程序后调用 afterCompletion（） - 在完成请求完成并生成视图后调用 这三种方法提供了各种前后处理的灵活性。 一个简单的说明 - HandlerInterceptor和HandlerInterceptorAdapter之间的主要区别在于，在第一个方面，我们需要覆盖所有三种方法：preHandle（），postHandle（）和afterCompletion（），而在第二种情况下，我们可以只实现自己需要的方法。 以下是一个简单的preHandle（）实现： 12345678@Overridepublic boolean preHandle( HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // your code return true;&#125; 注意，该方法返回一个布尔值 - 它告诉Spring是否应该由处理程序（true）或（false）进一步处理该请求。 接下来，我们有一个postHandle（）的实现： 12345678@Overridepublic void postHandle( HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; // your code&#125; 在HandlerAdapter处理请求之后，在生成视图之前，立即调用此方法。 它当然可以以许多方式使用 - 例如，我们可以将一个记录的用户的头像添加到模型中。 我们需要在自定义HandlerInterceptor实现中实现的最终方法是afterCompletion（）： 1234567@Overridepublic void afterCompletion( HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; // your code&#125; 当视图成功生成时，我们可以使用此钩子来处理与请求相关的附加统计信息。 最后要注意的是，HandlerInterceptor注册到DefaultAnnotationHandlerMapping bean，该bean负责将拦截器应用于任何标有@Controller注释的类。此外，您可以在Web应用程序中指定任意数量的拦截器。 5. Custom Logger Interceptor在这个例子中，我们将专注于登录我们的Web应用程序。首先，我们的类需要扩展HandlerInterceptorAdapter： 123public class LoggerInterceptor extends HandlerInterceptorAdapter &#123; ...&#125; 我们还需要在拦截器中启用日志记录： 1private static Logger log = LoggerFactory.getLogger(LoggerInterceptor.class); 这允许Log4J显示日志，以及指示当前哪个类将信息记录到指定的输出。 接下来，我们关注自定义拦截器实现： 5.1. Method preHandle()1234567891011@Overridepublic boolean preHandle( HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; log.info(\"[preHandle][\" + request + \"]\" + \"[\" + request.getMethod() + \"]\" + request.getRequestURI() + getParameters(request)); return true;&#125; 我们可以看到，我们正在记录有关请求的一些基本信息。 如果我们在这里遇到密码，我们需要确保我们不记录。 一个简单的选择是用*号替换密码和任何其他敏感类型的数据。 这是一个快速实现如何做到这一点： 这是一个快速实现如何做到这一点： 123456789101112131415161718192021222324252627private String getParameters(HttpServletRequest request) &#123; StringBuffer posted = new StringBuffer(); Enumeration&lt;?&gt; e = request.getParameterNames(); if (e != null) &#123; posted.append(\"?\"); &#125; while (e.hasMoreElements()) &#123; if (posted.length() &gt; 1) &#123; posted.append(\"&amp;\"); &#125; String curr = (String) e.nextElement(); posted.append(curr + \"=\"); if (curr.contains(\"password\") || curr.contains(\"pass\") || curr.contains(\"pwd\")) &#123; posted.append(\"*****\"); &#125; else &#123; posted.append(request.getParameter(curr)); &#125; &#125; String ip = request.getHeader(\"X-FORWARDED-FOR\"); String ipAddr = (ip == null) ? getRemoteAddr(request) : ip; if (ipAddr!=null &amp;&amp; !ipAddr.equals(\"\")) &#123; posted.append(\"&amp;_psip=\" + ipAddr); &#125; return posted.toString();&#125; 最后，我们的目标是获取HTTP请求的源IP地址。 这是一个简单的实现： 12345678private String getRemoteAddr(HttpServletRequest request) &#123; String ipFromHeader = request.getHeader(\"X-FORWARDED-FOR\"); if (ipFromHeader != null &amp;&amp; ipFromHeader.length() &gt; 0) &#123; log.debug(\"ip from proxy - X-FORWARDED-FOR : \" + ipFromHeader); return ipFromHeader; &#125; return request.getRemoteAddr();&#125; 5.2. Method postHandle()当HandlerAdapter被调用处理程序但DispatcherServlet尚未呈现视图时，此钩子将运行。 我们可以使用此方法向ModelAndView添加附加属性，或者确定处理方法处理客户端请求所花费的时间。 在我们的例子中，我们只需要在DispatcherServlet渲染视图之前记录一个请求。 123456789@Overridepublic void postHandle( HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; log.info(\"[postHandle][\" + request + \"]\");&#125; 5.3. Method afterCompletion()当请求完成并且呈现视图时，我们可以获得请求和响应数据以及有关异常的信息（如果有）： 123456789@Overridepublic void afterCompletion( HttpServletRequest request, HttpServletResponse response,Object handler, Exception ex) throws Exception &#123; if (ex != null)&#123; ex.printStackTrace(); &#125; log.info(\"[afterCompletion][\" + request + \"][exception: \" + ex + \"]\");&#125; 6. Configuration要将拦截器添加到Spring配置中，我们需要覆盖扩展WebMvcConfigurerAdapter的WebConfig类中的addInterceptors（）方法: 1234@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoggerInterceptor());&#125; 我们可以通过编辑我们的XML Spring配置文件来实现相同的配置： 123&lt;mvc:interceptors&gt; &lt;bean id=\"loggerInterceptor\" class=\"org.baeldung.web.interceptor.LoggerInterceptor\"/&gt;&lt;/mvc:interceptors&gt; 在此配置为活动状态下，拦截器将处于活动状态，并且应用程序中的所有请求都将被正确记录。 请注意，如果配置了多个Spring拦截器，则以配置顺序执行preHandle（）方法，而以相反的顺序调用postHandle（）和afterCompletion（）方法。 7. Conclusion本教程是使用Spring MVC Handler Interceptor拦截HTTP请求的快速介绍。 所有示例和配置可在GitHub上获得。","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"Quick Guide to Spring Controllers","date":"2017-06-23T01:33:57.421Z","path":"2017/06/23/Quick Guide to Spring Controllers/","text":"1. Introduction在本文中，我们将重点介绍Spring MVC - 控制器中的核心概念。 2. Overview我们先来看一下典型的Spring Model View Controller架构中Front Controller的概念。 在高的层次上，我们正在研究的主要职责是： 拦截传入请求 将请求的有效内容转换为数据的内部结构 将数据发送到模型进行进一步处理 从模型获取处理后的数据，并将该数据提升到视图进行渲染 以下是Spring MVC中高层次流程图： 您可以看到，DispatcherServlet在架构中扮演前端控制器的角色。 该图适用于典型的MVC控制器以及RESTful控制器 - 具有一些小的差异（如下所述）。 在传统的方法中，MVC应用程序不是面向服务的，因此有一个View Resolver，它根据从Controller获得的数据呈现最终的视图。 RESTful应用程序旨在面向服务，并返回原始数据（通常为JSON / XML）。由于这些应用程序不执行任何视图呈现，因此没有View Resolvers - 通常希望Controller通过HTTP响应直接发送数据。 让我们从MVC0风格的控制器开始吧。 3. Maven Dependencies 为了能够与Spring MVC一起使用，我们先来处理Maven依赖项： 12345 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.1.RELEASE&lt;/version&gt;&lt;dependency&gt; 要获取最新版本的库，请查看Maven Central上的spring-webmvc。 4. Project Web Config现在，在查看控制器本身之前，我们首先需要设置一个简单的Web项目并执行一个快速的Servlet配置。 我们首先看看如何在不使用web.xml的情况下设置DispatcherServlet - 而是使用初始化程序： 123456789101112131415161718192021public class StudentControllerConfig implements WebApplicationInitializer &#123; @Override public void onStartup(ServletContext sc) throws ServletException &#123; AnnotationConfigWebApplicationContext root = new AnnotationConfigWebApplicationContext(); root.register(WebConfig.class); root.refresh(); root.setServletContext(sc); sc.addListener(new ContextLoaderListener(root)); DispatcherServlet dv = new DispatcherServlet(new GenericWebApplicationContext()); ServletRegistration.Dynamic appServlet = sc.addServlet(\"test-mvc\", dv); appServlet.setLoadOnStartup(1); appServlet.addMapping(\"/test/*\"); &#125;&#125; 要设置没有XML的东西，请确保在您的类路径中具有servlet-api 3.1.0。 web.xml将如下所示： web.xml将如下所示： 1234567891011&lt;servlet&gt; &lt;servlet-name&gt;test-mvc&lt;/servlet-name&gt; &lt;servlet-class&gt; org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/test-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt; 我们正在设置contextConfigLocation属性，指向用于加载Spring上下文的XML文件。如果该属性不存在，Spring将搜索名为{servlet_name} -servlet.xml的文件。 在我们的例子中，servlet_name是test-mvc，所以在这个例子中，DispatcherServlet会搜索一个名为test-mvc-servlet.xml的文件。 最后，我们设置DispatcherServlet并将其映射到特定的URL - 以完成我们的基于Front Controller的系统： 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;test-mvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/test/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 因此在这种情况下，DispatcherServlet将拦截pattern / test中的所有请求。 5. Spring MVC Web Config现在让我们看看如何使用Spring Config来设置Dispatcher Servlet： 12345678910111213141516171819202122@Configuration@EnableWebMvc@ComponentScan(basePackages= &#123; \"org.baeldung.controller.controller\", \"org.baeldung.controller.config\" &#125;) public class WebConfig extends WebMvcConfigurerAdapter &#123; @Override public void configureDefaultServletHandling( DefaultServletHandlerConfigurer configurer) &#123; configurer.enable(); &#125; @Bean public ViewResolver viewResolver() &#123; InternalResourceViewResolver bean = new InternalResourceViewResolver(); bean.setPrefix(\"/WEB-INF/\"); bean.setSuffix(\".jsp\"); return bean; &#125;&#125; 现在我们来看看使用XML设置Dispatcher Servlet。 DispatcherServlet XML文件的快照 - DispatcherServlet用于加载自定义控制器和其他Spring实体的XML文件如下所示： 12345678910&lt;context:component-scan base-package=\"com.baledung.controller\" /&gt;&lt;mvc:annotation-driven /&gt;&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\"&gt; &lt;value&gt;/WEB-INF/&lt;/value&gt; &lt;/property&gt; &lt;property name=\"suffix\"&gt; &lt;value&gt;.jsp&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; 基于这种简单的配置，框架当然会初始化它将在类路径中找到的任何控制器bean。 请注意，我们还定义了View Resolver，负责视图呈现 - 我们将在这里使用Spring的InternalResourceViewResolver。这意味着要解析的视图的名称，这意味着通过使用前缀和后缀（两者都在XML配置中定义）来找到相应的页面。 因此，例如，如果Controller返回一个名为“welcome”的视图，则视图解析器将尝试解析WEB-INF文件夹中名为“welcome.jsp”的页面。 6. The MVC Controller让我们最后不实现MVC风格的控制器。 注意我们如何返回一个ModelAndView对象 - 其中包含模型映射和视图对象; View Resolver将使用这两种方式进行数据呈现： 12345678910111213@Controller@RequestMapping(value = \"/test\")public class TestController &#123; @GetMapping public ModelAndView getTestData() &#123; ModelAndView mv = new ModelAndView(); mv.setViewName(\"welcome\"); mv.getModel().put(\"data\", \"Welcome home man\"); return mv; &#125;&#125; 那么，我们在这里设置了什么呢？ 首先，我们创建了一个名为TestController的控制器，并将其映射到“/ test”路径。在类中，我们创建了一个返回ModelAndView对象并映射到GET请求的方法，因此以“test”结尾的任何URL调用将由DispatcherServlet路由到TestController中的getTestData方法 当然，我们返回的ModelAndView对象有一些模型数据很好的措施。 视图对象的名称设置为“welcome”。如上所述，View Resolver将在WEB-INF文件夹中搜索名为“welcome.jsp”的页面。 下面你可以看到GET操作的结果： 请注意，URL以“test”结尾。 URL的模式是“/ test / test”。 第一个“/ test”来自Servlet，第二个来自控制器的映射。 7. More Spring Dependencies for REST现在开始看一个RESTful控制器。当然，一个好的开始是我们需要的额外的Maven依赖关系： 1234567891011121314151617&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.3.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 有关这些依赖关系的最新版本，请参考jackson-core，spring-webmvc和spring-web链接。 Jackson 当然不是强制性的，但它肯定是启用JSON支持的好方法。如果您有兴趣深入了解该支持，请看这里的消息转换器文章。 8. The REST ControllerSpring RESTful应用程序的设置与MVC应用程序的设置相同，唯一的区别是没有View Resolver，没有模型映射。 API通常会简单地将原始数据返回给客户端 - 通常使用XML和JSON表示形式，因此DispatcherServlet绕过视图解析器，并在HTTP响应正文中返回数据。 我们来看看一个简单的RESTful控制器实现： 123456789101112@Controllerpublic class RestController &#123; @GetMapping(value = \"/student/&#123;studentId&#125;\") public @ResponseBody Student getTestData(@PathVariable Integer studentId) &#123; Student student = new Student(); student.setName(\"Peter\"); student.setId(studentId); return student; &#125;&#125; 请注意该方法上的@ResponseBody注释 - 它指示Spring绕过视图解析器，并基本上将输出直接写入HTTP响应的正文。 上述输出是将GET请求发送到学生ID为1的API的结果。 这里一个简单的说法是 - @RequestMapping注释是这些中心注释之一，您将需要深入研究才能充分发挥其潜力。 9. Spring Boot and the @RestController Annotation来自Spring Boot的@RestController注释基本上是一个快捷的快捷方式，可以帮助我们避免一定要定义@ResponseBody 现在我们使用@RestController来写先前的例子，现在像这样： 1234567891011@RestControllerpublic class RestAnnotatedController &#123; @GetMapping(value = \"/annotated/student/&#123;studentId&#125;\") public Student getData(@PathVariable Integer studentId) &#123; Student student = new Student(); student.setName(\"Peter\"); student.setId(studentId); return student; &#125;&#125; 10. Conclusion在本指南中，我们将从Spring中了解到使用控制器的基础知识，无论是从典型的MVC应用程序的角度还是RESTful API。","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"Spring @RequestMapping New Shortcut Annotations","date":"2017-06-23T01:33:51.766Z","path":"2017/06/23/Spring @RequestMapping New Shortcut Annotations/","text":"1. Overviewspring4.3。介绍了一些非常酷的方法级组合注释，以更优雅的处理典型的Spring MVC项目中的@RequestMapping。 2. New Annotations通常，如果我们要使用传统的@RequestMapping注释来实现URL处理程序，那么它将是这样的： @RequestMapping(value = “/get/{id}”, method = RequestMethod.GET) 新的方法可以简化为： @GetMapping(“/get/{id}”) Spring目前支持五种类型的内置注释，用于处理GET，POST，PUT，DELETE和PATCH等不同类型的传入HTTP请求方法。这些注释是： @GetMapping @PostMapping @PutMapping @DeleteMapping @PatchMapping 从命名约定可以看出，每个注解都是为了处理各自的传入请求方法类型，即@GetMapping用于处理请求方法的GET类型，@PostMapping用于处理POST类型的请求方法等。 3. How It Works所有上述注释已经在内部使用@RequestMapping进行注释，并且在方法元素中设置了相应的值。 例如，如果我们来看看@GetMapping注解的源代码，我们可以看到它已经通过RequestMethod.GET以下列方式注释： 1234567@Target(&#123; java.lang.annotation.ElementType.METHOD &#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@RequestMapping(method = &#123; RequestMethod.GET &#125;)public @interface GetMapping &#123; // abstract codes&#125; 所有其他注释以相同的方式创建，即@PostMapping用RequestMethod.POST注释，@PutMapping用RequestMethod.PUT等注释。 4. Implementation我们尝试使用这些注释构建一个快速的REST应用程序。 请注意，由于我们将使用Maven构建项目和Spring MVC来创建我们的应用程序，所以我们需要在pom.xml中添加必要的依赖项： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.6.RELEASE&lt;/version&gt;&lt;/dependency&gt; 现在，我们需要创建控制器来映射传入的请求URL。在这个控制器中，我们将逐个使用所有这些注释。 4.1. @GetMapping123456789101112@GetMapping(\"/get\")public @ResponseBody ResponseEntity&lt;String&gt; get() &#123; return new ResponseEntity&lt;String&gt;(\"GET Response\", HttpStatus.OK);&#125;@GetMapping(\"/get/&#123;id&#125;\")public @ResponseBody ResponseEntity&lt;String&gt; getById(@PathVariable String id) &#123; return new ResponseEntity&lt;String&gt;(\"GET Response : \" + id, HttpStatus.OK);&#125; 4.2. @PostMapping1234@PostMapping(\"/post\")public @ResponseBody ResponseEntity&lt;String&gt; post() &#123; return new ResponseEntity&lt;String&gt;(\"POST Response\", HttpStatus.OK);&#125; 4.3. @PutMapping1234@PutMapping(\"/put\")public @ResponseBody ResponseEntity&lt;String&gt; put() &#123; return new ResponseEntity&lt;String&gt;(\"PUT Response\", HttpStatus.OK);&#125; 4.4. @DeleteMapping1234@DeleteMapping(\"/delete\")public @ResponseBody ResponseEntity&lt;String&gt; delete() &#123; return new ResponseEntity&lt;String&gt;(\"DELETE Response\", HttpStatus.OK);&#125; 4.5. @PatchMapping1234@PatchMapping(\"/patch\")public @ResponseBody ResponseEntity&lt;String&gt; patch() &#123; return new ResponseEntity&lt;String&gt;(\"PATCH Response\", HttpStatus.OK);&#125; 注意事项： 我们已经使用必要的注释来处理适当的传入HTTP方法与URI。例如，@GetMapping处理“/ get”URI，@PostMapping处理“/ post”URI等 由于我们正在制作一个基于REST的应用程序，所以我们用200个响应代码返回一个常量字符串（每个请求类型唯一），以简化应用程序。在这种情况下，我们使用了Spring的@ResponseBody注释。 如果我们不得不处理任何URL路径变量,我们可以用少得多的方式使用@RequestMapping用来做的。 5. Testing the Application要测试应用程序，我们需要使用JUnit创建几个测试用例。我们将使用SpringJUnit4ClassRunner启动测试类。我们将创建五个不同的测试用例来测试每个注释和我们在控制器中声明的每个处理程序。 让我们来简单了解一下测试@GetMapping的例子 1234567891011121314@Testpublic void giventUrl_whenGetRequest_thenFindGetResponse() throws Exception &#123; MockHttpServletRequestBuilder builder = MockMvcRequestBuilders .get(\"/get\"); ResultMatcher contentMatcher = MockMvcResultMatchers.content() .string(\"GET Response\"); this.mockMvc.perform(builder).andExpect(contentMatcher) .andExpect(MockMvcResultMatchers.status().isOk()); &#125; 我们可以看到，一旦我们点击GET URL“/ get”，我们期待着一个恒定的字符串“GET Response”。 现在，我们创建测试用例来测试@PostMapping： 1234567891011121314@Testpublic void givenUrl_whenPostRequest_thenFindPostResponse() throws Exception &#123; MockHttpServletRequestBuilder builder = MockMvcRequestBuilders .post(\"/post\"); ResultMatcher contentMatcher = MockMvcResultMatchers.content() .string(\"POST Response\"); this.mockMvc.perform(builder).andExpect(contentMatcher) .andExpect(MockMvcResultMatchers.status().isOk()); &#125; 以同样的方式，我们创建了其余的测试用例来测试所有的HTTP方法。 或者，我们可以随时使用任何常见的REST客户端，例如PostMan，RESTClient等来测试我们的应用程序。在这种情况下，我们需要在使用其余的客户端时仔细选择正确的HTTP方法类型。否则会抛出405错误状态。 6. Conclusion在本文中，我们快速介绍了使用传统Spring MVC框架进行快速Web开发的不同类型的@RequestMapping快捷方式。我们可以利用这些快捷方式创建一个干净的代码库。","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"Spring MVC and the @ModelAttribute Annotation","date":"2017-06-23T01:33:46.580Z","path":"2017/06/23/Spring MVC and the @ModelAttribute Annotation/","text":"1. Overview最重要的Spring-MVC注释之一是@ModelAttribute注释。 @ModelAttribute是将方法参数或方法返回值绑定到命名模型属性的注释，然后将其公开到Web视图。 在下面的例子中，我们将通过一个共同的概念来证明注释的可用性和功能：从公司员工提交的表单。 2. The @ModelAttribute in Depth如介绍性段落所示，@ModelAttribute可以用作方法参数或方法级别。 2.1 At the Method Level当在方法级别使用注释时，它表示该方法的目的是添加一个或多个模型属性。这样的方法支持与@RequestMapping方法相同的参数类型，但不能直接映射到请求。 让我们来看看一个快速的例子，开始了解它的工作原理： 1234@ModelAttributepublic void addAttributes(Model model) &#123; model.addAttribute(\"msg\", \"Welcome to the Netherlands!\");&#125; 在这个例子中，我们展示了一个方法，它将一个名为msg的属性添加到控制器类中定义的所有模型中。 当然，我们会在文章中稍后再看到这一点。 一般来说，在调用任何请求处理程序方法之前，Spring-MVC将始终先调用该方法。也就是说，@ModelAttribute方法在使用@RequestMapping注释的控制器方法被调用之前被调用。序列之后的逻辑是，必须在控制器方法中开始任何处理之前创建模型对象。 您也可以将相应的类注释为@ControllerAdvice也很重要。因此，您可以在Model中添加将被标识为全局的值。这实际上意味着对于每个请求，存在默认值，对于响应部分中的每个方法。 2.2 As a Method Argument当用作方法参数时，它表示应该从模型检索参数。当不存在时，应首先实例化，然后添加到模型中，一旦出现在模型中，参数字段应从具有匹配名称的所有请求参数中填充。 在员工模型属性之后的代码片段中填充了从提交到addEmployee端点的表单中的数据。在调用提交方法之前，Spring MVC在幕后执行此操作： 123456@RequestMapping(value = \"/addEmployee\", method = RequestMethod.POST)public String submit(@ModelAttribute(\"employee\") Employee employee) &#123; // Code that uses the employee object return \"employeeView\";&#125; 稍后在本文中，我们将看到如何使用employee对象来填充employeeView模板的完整示例。 因此，它将表单数据与bean绑定。用@RequestMapping注释的控制器可以使用@ModelAttribute注释自定义类参数。 这通常被称为Spring-MVC中的数据绑定，这是一种常见的机制，可以使您不必单独解析每个表单域。 3. Form Example在本节中，我们将提供概述部分中提到的示例：提供用户（在我们具体的例子中的公司的雇员）输入一些个人信息（特别是名称和身份证件）的非常基本的形式。提交完成后，没有任何错误，用户期望看到先前提交的数据，显示在另一个屏幕上。 3.1 The View我们首先创建一个带有id和name字段的简单表单： 12345678910&lt;form:form method=\"POST\" action=\"/spring-mvc-java/addEmployee\" modelAttribute=\"employee\"&gt; &lt;form:label path=\"name\"&gt;Name&lt;/form:label&gt; &lt;form:input path=\"name\" /&gt; &lt;form:label path=\"id\"&gt;Id&lt;/form:label&gt; &lt;form:input path=\"id\" /&gt; &lt;input type=\"submit\" value=\"Submit\" /&gt;&lt;/form:form&gt; 3.2 The Controller这是控制器类，上面提到的视图的逻辑正在实现： 1234567891011121314151617181920212223242526@Controller@ControllerAdvicepublic class EmployeeController &#123; private Map&lt;Long, Employee&gt; employeeMap = new HashMap&lt;&gt;(); @RequestMapping(value = \"/addEmployee\", method = RequestMethod.POST) public String submit( @ModelAttribute(\"employee\") Employee employee, BindingResult result, ModelMap model) &#123; if (result.hasErrors()) &#123; return \"error\"; &#125; model.addAttribute(\"name\", employee.getName()); model.addAttribute(\"id\", employee.getId()); employeeMap.put(employee.getId(), employee); return \"employeeView\"; &#125; @ModelAttribute public void addAttributes(Model model) &#123; model.addAttribute(\"msg\", \"Welcome to the Netherlands!\"); &#125;&#125; 在submit（）方法中，我们有一个Employee对象绑定到我们的View。你能看到这个注释的力量吗？您可以简单地将表单域映射到对象模型。在该方法中，我们从表单中获取值并将其设置为ModelMap。 最后我们返回employeeView，这意味着相应的JSP文件将被称为View代理。 此外，还有一个addAttributes（）方法。其目的是增加将在全球范围内识别的模型中的价值。也就是说，默认值将作为对每个控制器方法的每个请求的响应返回。我们还必须将特定类注释为@ControllerAdvice。 3.3 The Model如前所述，Model对象非常简单，包含“前端”属性所需的所有内容。现在，我们来看一个例子： 12345678910111213@XmlRootElementpublic class Employee &#123; private long id; private String name; public Employee(long id, String name) &#123; this.id = id; this.name = name; &#125; // standard getters and setters removed&#125; 3.4 Wrap Up@ControllerAdvice协助控制器，特别是@ModelAttribute方法适用于所有@RequestMapping方法。当然，在其余的@RequestMapping方法之前，我们的addAttributes（）方法将是最先运行的方法。 保持这一点，并且在运行submit（）和addAttributes（）之后，我们可以在Controller类中返回的View中引用它们，通过提及它们在美元化的花括号中的给定名称，例如$ {name}。 3.5 Results View现在我们来打印我们从表单中收到的内容： 123&lt;h3&gt;$&#123;msg&#125;&lt;/h3&gt;Name : $&#123;name&#125;ID : $&#123;id&#125; 4. Conclusion在本教程中，我们调查了@ModelAttribute注释的用法，用于方法参数和方法级使用情况。","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"Http Message Converters with the Spring Framework","date":"2017-06-23T01:33:40.433Z","path":"2017/06/23/Http Message Converters with the Spring Framework/","text":"1. Overview本文介绍如何在Spring中配置HttpMessageConverter。简单地说，消息转换器用于通过HTTP来对Java对象进行和从JSON，XML等进行编组和解组。 2. The BasicsWeb应用程序需要配置Spring MVC支持 - 一个方便且非常可定制的方法是使用@EnableWebMvc注释： 123456@EnableWebMvc@Configuration@ComponentScan(&#123; \"org.baeldung.web\" &#125;)public class WebConfig extends WebMvcConfigurerAdapter &#123; ...&#125; 请注意，此类扩展了WebMvcConfigurerAdapter - 这将允许我们使用我们自己的Http转换器的默认列表。 2.2. The Default Message Converters默认情况下，以下HttpMessageConverters实例已预启用： ByteArrayHttpMessageConverter - 字节数组转换 StringHttpMessageConverter - 转换字符串 ResourceHttpMessageConverter - 转换任何类型的八位字节流的org.springframework.core.io.Resource SourceHttpMessageConverter - 转换javax.xml.transform.Source FormHttpMessageConverter - 将表单数据转换为/从MultiValueMap 转换。 Jaxb2RootElementHttpMessageConverter - 将Java对象转换为/从XML转换（仅在类路径中存在JAXB2时添加） MappingJackson2HttpMessageConverter - 转换JSON（仅在类路径中存在Jackson 2时才添加） MappingJacksonHttpMessageConverter - 转换JSON（仅当Jackson 2存在于类路径时才添加） AtomFeedHttpMessageConverter - 转换Atom订阅源（仅当 Rome在类路径中存在时添加） RssChannelHttpMessageConverter - RSS源（只加了，如果Rome存在的类路径上）转换 3. Client-Server Communication – JSON only3.1. High Level Content Negotiation每个HttpMessageConverter实现都有一个或多个关联的MIME类型。 当接收到新的请求时，Spring将使用“Accept”头来确定需要响应的媒体类型。 然后，它将尝试找到一个能够处理该特定媒体类型的注册转换器 - 它将使用它转换实体并发回响应。 该过程类似于接收包含JSON信息的请求 - 框架将使用“Content-Type”头来确定请求体的媒体类型。 然后，它将搜索可以将客户端发送的身体转换为Java对象的HttpMessageConverter。 让我们用一个简单的例子来阐明一下： 客户端向/ foos发送一个GET请求，将Accept标头设置为application / json，以获取所有Foo资源为Json Foo Spring控制器被命中并返回相应的Foo Java实体 然后，Spring然后使用Jackson消息转换器之一将实体编组到json 现在来看看这个工作原理的具体细节，以及我们如何利用@ResponseBody和@RequestBody注释。 3.2. @ResponseBodyController上的@ResponseBody方法向Spring表示方法的返回值直接序列化到HTTP响应的主体。如上所述，客户端指定的“Accept”标头将用于选择适当的Http Converter来组织实体。 我们来看一个简单的例子： 1234@RequestMapping(method=RequestMethod.GET, value=\"/foos/&#123;id&#125;\")public @ResponseBody Foo findById(@PathVariable long id) &#123; return fooService.get(id);&#125; 现在，客户端将在request-example curl命令中指定application / json中的“Accept”标头： 12curl --header \"Accept: application/json\" http://localhost:8080/spring-rest/foos/1 The Foo class: 1234public class Foo &#123; private long id; private String name;&#125; 和Http响应body： 1234&#123; \"id\": 1, \"name\": \"Paul\",&#125; 3.3. @RequestBody@RequestBody是用于Controller方法的参数 - 它向Spring指出，HTTP请求的正文反序列化到该特定的Java实体。如前所述，由客户端指定的“Content-Type”头将用于确定适当的转换器。 我们来看一个例子： 12345@RequestMapping(method=RequestMethod.PUT, value=\"/foos/&#123;id&#125;\")public @ResponseBody void updateFoo( @RequestBody Foo foo, @PathVariable String id) &#123; fooService.update(foo);&#125; 现在，让我们用JSON对象来使用它 - 我们将“Content-Type”指定为application / json： 12curl -i -X PUT -H \"Content-Type: application/json\" -d '&#123;\"id\":\"83\",\"name\":\"klik\"&#125;' http://localhost:8080/spring-rest/foos/1 我们得到200 OK - 一个成功的回应： 1234HTTP/1.1 200 OKServer: Apache-Coyote/1.1Content-Length: 0Date: Fri, 10 Jan 2014 11:18:54 GMT 4. Custom Converters Configuration我们可以通过扩展WebMvcConfigurerAdapter类并覆盖configureMessageConverters方法来自定义消息转换器： 12345678910111213141516171819202122232425@EnableWebMvc@Configuration@ComponentScan(&#123; \"org.baeldung.web\" &#125;)public class WebConfig extends WebMvcConfigurerAdapter &#123; @Override public void configureMessageConverters( List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; messageConverters.add(createXmlHttpMessageConverter()); messageConverters.add(new MappingJackson2HttpMessageConverter()); super.configureMessageConverters(converters); &#125; private HttpMessageConverter&lt;Object&gt; createXmlHttpMessageConverter() &#123; MarshallingHttpMessageConverter xmlConverter = new MarshallingHttpMessageConverter(); XStreamMarshaller xstreamMarshaller = new XStreamMarshaller(); xmlConverter.setMarshaller(xstreamMarshaller); xmlConverter.setUnmarshaller(xstreamMarshaller); return xmlConverter; &#125;&#125; 这里是相应的XML配置： 123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd\"&gt; &lt;context:component-scan base-package=\"org.baeldung.web\" /&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"/&gt; &lt;bean class=\"org.springframework.http.converter.xml.MarshallingHttpMessageConverter\"&gt; &lt;property name=\"marshaller\" ref=\"xstreamMarshaller\" /&gt; &lt;property name=\"unmarshaller\" ref=\"xstreamMarshaller\" /&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;bean id=\"xstreamMarshaller\" class=\"org.springframework.oxm.xstream.XStreamMarshaller\" /&gt; &lt;/beans&gt; 请注意，XStream库现在需要存在于类路径中。 还要注意，通过扩展这个支持类，我们正在丢失以前预先注册的默认消息转换器 - 我们只有我们定义的。 我们来看一下这个例子 - 我们正在创建一个新的转换器–MarshallingHttpMessageConverter，我们使用Spring XStream支持来配置它。因为我们使用底层编组框架的低级API（在这种情况下是XStream），因此我们可以非常灵活地进行配置，但是我们可以配置这些。 我们当然可以为Jackson做同样的事情 - 通过定义我们自己的MappingJackson2HttpMessageConverter，我们现在可以在此转换器上设置一个自定义的ObjectMapper，并根据需要进行配置。 在这种情况下，XStream是选定的编组器/解组器实现，但是可以使用其他类似CastorMarshaller的方法来引用Spring api文档，以获取可用编组器的完整列表。 在这一点上 - 在后端启用了XML - 我们可以使用XML表示形式使用API​​： 12curl --header \"Accept: application/xml\" http://localhost:8080/spring-rest/foos/1 5. Using Spring’s RestTemplate with Http Message Converters除了服务器端，Http消息转换可以在客户端在Spring RestTemplate上进行配置。 我们将在适当的时候使用“Accept”和“Content-Type”标头来配置模板，我们将尝试使用完整的编组和解组Foo资源来消费REST API，包括JSON和XML 。 5.1. Retrieving the Resource with no Accept Header1234567@Testpublic void testGetFoo() &#123; String URI = “http://localhost:8080/spring-rest/foos/&#123;id&#125;\"; RestTemplate restTemplate = new RestTemplate(); Foo foo = restTemplate.getForObject(URI, Foo.class, \"1\"); Assert.assertEquals(new Integer(1), foo.getId());&#125; 5.3. Retrieving a Resource with application/json Accept header1234567891011121314151617181920212223@Testpublic void givenConsumingJson_whenReadingTheFoo_thenCorrect() &#123; String URI = BASE_URI + \"foos/&#123;id&#125;\"; RestTemplate restTemplate = new RestTemplate(); restTemplate.setMessageConverters(getMessageConverters()); HttpHeaders headers = new HttpHeaders(); headers.setAccept(Arrays.asList(MediaType.APPLICATION_JSON)); HttpEntity&lt;String&gt; entity = new HttpEntity&lt;String&gt;(headers); ResponseEntity&lt;Foo&gt; response = restTemplate.exchange(URI, HttpMethod.GET, entity, Foo.class, \"1\"); Foo resource = response.getBody(); assertThat(resource, notNullValue());&#125;private List&lt;HttpMessageConverter&lt;?&gt;&gt; getMessageConverters() &#123; List&lt;HttpMessageConverter&lt;?&gt;&gt; converters = new ArrayList&lt;HttpMessageConverter&lt;?&gt;&gt;(); converters.add(new MappingJackson2HttpMessageConverter()); return converters;&#125; 6. Conclusion在本教程中，我们研究了Spring MVC如何使我们能够指定和完全自定义Http消息转换器来自动将Java实体与XML或JSON进行编组/解组。这当然是一个简单的定义，消息转换机制可以做得更多，从上一个测试示例可以看出。 我们还研究了如何利用与RestTemplate客户端相同的强大机制 - 导致完全类型安全的消费API","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"A Guide to the ViewResolver in Spring MVC","date":"2017-06-23T01:33:35.297Z","path":"2017/06/23/A Guide to the ViewResolver in Spring MVC/","text":"1. Overview所有MVC框架都提供了一种处理视图的方法。 Spring通过视图解析器执行此操作，使您能够在浏览器中呈现模型，而不将实现与特定视图技术相结合。 ViewResolver将视图名称映射到实际视图。 而且Spring框架还有很多视图解析器。 InternalResourceViewResolver，XmlViewResolver，ResourceBundleViewResolver等几个。 这是一个简单的教程，介绍如何设置最常见的视图解析器，以及如何在同一配置中使用多个ViewResolver。 2. The Spring Web Configuration我们从Web配置开始吧！我们将使用@EnableWebMvc，@Configuration和@ComponentScan来注释它： 123456@EnableWebMvc@Configuration@ComponentScan(\"org.baeldung.web\")public class WebConfig extends WebMvcConfigurerAdapter &#123; // All web configuration will go here&#125; 在这里，我们将在配置中设置视图解析器。 3. Add an InternalResourceViewResolver此ViewResolver允许我们为视图名称设置诸如前缀或后缀的属性以生成最终视图页面URL： 12345678@Beanpublic ViewResolver internalResourceViewResolver() &#123; InternalResourceViewResolver bean = new InternalResourceViewResolver(); bean.setViewClass(JstlView.class); bean.setPrefix(\"/WEB-INF/view/\"); bean.setSuffix(\".jsp\"); return bean;&#125; 为了实例的这种简单性，我们不需要一个控制器来处理请求。 我们只需要一个简单的jsp页面，放置在/ WEB-INF / view文件夹中，如配置中所定义： 123456&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;This is the body of the sample view&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 4. Add a ResourceBundleViewResolver由于此解析器的名称建议ResourceBundleViewResolver在ResourceBundle中使用bean定义。 首先，我们将ResourceBundleViewResolver添加到以前的配置中： 123456@Beanpublic ViewResolver resourceBundleViewResolver() &#123; ResourceBundleViewResolver bean = new ResourceBundleViewResolver(); bean.setBasename(\"views\"); return bean;&#125; bundle 通常在属性文件中定义，位于类路径中。以下是views.properties文件： 12sample.(class)=org.springframework.web.servlet.view.JstlViewsample.url=/WEB-INF/view/sample.jsp 我们可以使用上述示例中定义的简单jsp页面进行此配置。 5. Add an XmlViewResolverViewResolver的这种实现使用与Spring的XML bean工厂相同的DTD来接受用XML编写的配置文件： 123456@Beanpublic ViewResolver xmlViewResolver() &#123; XmlViewResolver bean = new XmlViewResolver(); bean.setLocation(new ClassPathResource(\"views.xml\")); return bean;&#125; 下面是配置文件，views.xml： 12345678910&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd\"&gt; &lt;bean id=\"xmlConfig\" class=\"org.springframework.web.servlet.view.JstlView\"&gt; &lt;property name=\"url\" value=\"/WEB-INF/view/xmlSample.jsp\" /&gt; &lt;/bean&gt; &lt;/beans&gt; 对于前面的例子，我们可以使用我们以前定义的简单的jsp页面。 6. Chaining ViewResolvers and Define an Order PrioritySpring MVC还支持多个视图解析器。这允许您在某些情况下覆盖特定视图。我们可以通过向配置添加多个解析器来简单地链接视图解析器。 一旦这样做，我们需要为这些解析器定义一个顺序。 order属性用于定义链中调用顺序。order属性（最大order号）越高，视图解析器在链中的位置越晚。 要定义顺序，我们可以将以下代码行添加到我们的视图解析器的配置中： bean.setOrder(0); 要注意order优先级，因为InternalResourceViewResolver应该有更高的order - 因为它的目的是表示非常明确的映射。如果其他解析程序具有更高的顺序，那么可能永远不会调用InternalResourceViewResolver。 7. Conclusion在本教程中，我们使用Java配置配置了一组视图解析器。通过玩优先顺序，我们可以设置它们的调用顺序。","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"Spring MVC Custom Validation","date":"2017-06-23T01:33:29.759Z","path":"2017/06/23/Spring MVC Custom Validation/","text":"1. Overview通常，当我们需要验证用户输入时，Spring MVC提供了标准的预定义验证器。 但是，当我们需要验证一个更具体的类型输入时，我们有可能创建自己的定制验证逻辑。 在本文中，我们将这样做 - 我们将创建一个自定义验证器来验证具有电话号码字段的表单，然后显示多个字段的自定义验证器. 2. Setup要从获得API，请将依赖关系添加到您的pom.xml文件中： 12345678910&lt;dependency&gt; &lt;groupId&gt;javax.validation&lt;/groupId&gt; &lt;artifactId&gt;validation-api&lt;/artifactId&gt; &lt;version&gt;1.1.0.Final&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.4.1.Final&lt;/version&gt;&lt;/dependency&gt; 3. Custom Validation创建自定义验证器需要我们自己的注释，并在我们的模型中使用它来强制验证规则。 所以，我们来创建我们的自定义验证器 - 它检查电话号码。电话号码必须是数字超过8位，但不能超过11位数字 4. The New Annotation让我们创建一个新的@interface来定义我们的注释： 123456789@Documented@Constraint(validatedBy = ContactNumberValidator.class)@Target( &#123; ElementType.METHOD, ElementType.FIELD &#125;)@Retention(RetentionPolicy.RUNTIME)public @interface ContactNumberConstraint &#123; String message() default \"Invalid phone number\"; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;&#125; 使用@Constraint注释，我们定义了要验证我们的字段的类，message（）是在用户界面中显示的错误消息，附加代码是符合Spring标准的大多数样板代码。 5. Creating a Validator现在让我们创建一个验证器类来强制验证规则： 123456789101112131415public class ContactNumberValidator implements ConstraintValidator&lt;ContactNumberConstraint, String&gt; &#123; @Override public void initialize(ContactNumberConstraint contactNumber) &#123; &#125; @Override public boolean isValid(String contactField, ConstraintValidatorContext cxt) &#123; return contactField != null &amp;&amp; contactField.matches(\"[0-9]+\") &amp;&amp; (contactField.length() &gt; 8) &amp;&amp; (contactField.length() &lt; 14); &#125; &#125; 验证类实现ConstraintValidator接口，必须实现isValid方法;我们在这种方法中定义了我们的验证规则。 当然，我们将在这里提供一个简单的验证规则，以显示验证器的工作原理。 ConstraintValidator定义用于验证给定对象的给定约束的逻辑。实施必须遵守以下限制： 该对象必须解析为非参数类型 对象的通用参数必须是无界通配符类型 6. Applying Validation Annotation在我们的例子中，我们创建了一个简单的类，其中包含一个字段来应用验证规则。在这里，我们正在设置要验证的注释字段： 12@ContactNumberConstraintprivate String phone; 我们定义了一个字符串字段，并用我们的自定义注释@ContactNumberConstraint对它进行了注释。在我们的控制器中，我们创建了我们的映射，并处理了错误： 1234567891011121314151617181920@Controllerpublic class ValidatedPhoneController &#123; @GetMapping(\"/validatePhone\") public String loadFormPage(Model m) &#123; m.addAttribute(\"validatedPhone\", new ValidatedPhone()); return \"phoneHome\"; &#125; @PostMapping(\"/addValidatePhone\") public String submitForm(@Valid ValidatedPhone validatedPhone, BindingResult result, Model m) &#123; if(result.hasErrors()) &#123; return \"phoneHome\"; &#125; m.addAttribute(\"message\", \"Successfully saved phone: \" + validatedPhone.toString()); return \"phoneHome\"; &#125; &#125; 我们定义了具有单个JSP页面的简单控制器，并使用submitForm方法来强制验证我们的电话号码。 7. The View我们的视图是一个基本的JSP页面，其窗体具有单个字段。当用户提交表单时，该字段将被我们的自定义验证器验证，并重定向到同一页面，并显示验证成功或失败的消息： 12345678&lt;form:form action=\"/$&#123;pageContext.request.contextPath&#125;/addValidatePhone\" modelAttribute=\"validatedPhone\"&gt; &lt;label for=\"phoneInput\"&gt;Phone: &lt;/label&gt; &lt;form:input path=\"phone\" id=\"phoneInput\" /&gt; &lt;form:errors path=\"phone\" cssClass=\"error\" /&gt; &lt;input type=\"submit\" value=\"Submit\" /&gt;&lt;/form:form&gt; 8. Tests现在让我们测试我们的控制器，并检查它是否给我们适当的响应和视图： 12345@Testpublic void givenPhonePageUri_whenMockMvc_thenReturnsPhonePage()&#123; this.mockMvc. perform(get(\"/validatePhone\")).andExpect(view().name(\"phoneHome\"));&#125; 另外，我们根据用户输入测试我们的字段是否被验证： 12345678910111213@Testpublic void givenPhoneURIWithPostAndFormData_whenMockMVC_thenVerifyErrorResponse() &#123; this.mockMvc.perform(MockMvcRequestBuilders.post(\"/addValidatePhone\"). accept(MediaType.TEXT_HTML). param(\"phoneInput\", \"123\")). andExpect(model().attributeHasFieldErrorCode( \"validatedPhone\",\"phone\",\"ContactNumberConstraint\")). andExpect(view().name(\"phoneHome\")). andExpect(status().isOk()). andDo(print());&#125; 在测试中，我们为用户提供“123”的输入，并且 - 正如我们预期的那样 - 一切正常，我们在客户端看到错误。 9. Custom Class Level Validation也可以在类级别定义自定义验证注释，以验证该类的多个属性。 这种情况的常见用例是验证类中的两个字段是否具有匹配值。 9.1. Creating the Annotation我们添加一个名为FieldsValueMatch的新注释，可以稍后在类中应用。注释将具有两个参数field和fieldMatch，它们表示要比较的字段的名称： 1234567891011121314151617@Constraint(validatedBy = FieldsValueMatchValidator.class)@Target(&#123; ElementType.TYPE &#125;)@Retention(RetentionPolicy.RUNTIME)public @interface FieldsValueMatch &#123; String message() default \"Fields values don't match!\"; String field(); String fieldMatch(); @Target(&#123; ElementType.TYPE &#125;) @Retention(RetentionPolicy.RUNTIME) @interface List &#123; FieldsValueMatch[] value(); &#125;&#125; 我们可以看到我们的自定义注释还包含一个List子界面，用于在类上定义多个FieldsValueMatch注释。 9.2. Creating the Validator接下来，我们需要添加将包含实际验证逻辑的FieldsValueMatchValidator类： 1234567891011121314151617181920212223242526public class FieldsValueMatchValidator implements ConstraintValidator&lt;FieldsValueMatch, Object&gt; &#123; private String field; private String fieldMatch; public void initialize(FieldsValueMatch constraintAnnotation) &#123; this.field = constraintAnnotation.field(); this.fieldMatch = constraintAnnotation.fieldMatch(); &#125; public boolean isValid(Object value, ConstraintValidatorContext context) &#123; Object fieldValue = new BeanWrapperImpl(value) .getPropertyValue(field); Object fieldMatchValue = new BeanWrapperImpl(value) .getPropertyValue(fieldMatch); if (fieldValue != null) &#123; return fieldValue.equals(fieldMatchValue); &#125; else &#123; return fieldMatchValue == null; &#125; &#125;&#125; isValid（）方法检索两个字段的值，并检查它们是否相等。 9.3. Applying the Annotation我们创建一个NewUserForm模型类，用于用户注册所需的数据，它具有两个电子邮件和密码属性，以及两个verifyEmail和verifyPassword属性，以重新输入两个值。 由于我们有两个字段来检查其对应的匹配字段，所以我们在NewUserForm类上添加两个@FieldsValueMatch注释，一个用于电子邮件值，一个用于密码值： 1234567891011121314151617181920@FieldsValueMatch.List(&#123; @FieldsValueMatch( field = \"password\", fieldMatch = \"verifyPassword\", message = \"Passwords do not match!\" ), @FieldsValueMatch( field = \"email\", fieldMatch = \"verifyEmail\", message = \"Email addresses do not match!\" )&#125;)public class NewUserForm &#123; private String email; private String verifyEmail; private String password; private String verifyPassword; // standard constructor, getters, setters&#125; 为了在Spring MVC中验证模型，让我们创建一个带有/ user POST映射的控制器，该控件接收一个用@Valid注释的NewUserForm对象，并验证是否有任何验证错误： 12345678910111213141516171819@Controllerpublic class NewUserController &#123; @GetMapping(\"/user\") public String loadFormPage(Model model) &#123; model.addAttribute(\"newUserForm\", new NewUserForm()); return \"userHome\"; &#125; @PostMapping(\"/user\") public String submitForm(@Valid NewUserForm newUserForm, BindingResult result, Model model) &#123; if (result.hasErrors()) &#123; return \"userHome\"; &#125; model.addAttribute(\"message\", \"Valid form\"); return \"userHome\"; &#125;&#125; 9.4. Testing the Annotatio要验证我们的自定义类级别注释，让我们编写一个JUnit测试，它将匹配信息发送到/ user端点，然后验证响应是否包含错误： 1234567891011121314151617181920212223public class ClassValidationMvcTest &#123; private MockMvc mockMvc; @Before public void setup()&#123; this.mockMvc = MockMvcBuilders .standaloneSetup(new NewUserController()).build(); &#125; @Test public void givenMatchingEmailPassword_whenPostNewUserForm_thenOk() throws Exception &#123; this.mockMvc.perform(MockMvcRequestBuilders .post(\"/user\") .accept(MediaType.TEXT_HTML). .param(\"email\", \"john@yahoo.com\") .param(\"verifyEmail\", \"john@yahoo.com\") .param(\"password\", \"pass\") .param(\"verifyPassword\", \"pass\")) .andExpect(model().errorCount(0)) .andExpect(status().isOk()); &#125;&#125; 接下来，我们还添加一个JUnit测试，它将不匹配的信息发送到/ user端点，并声明结果将包含两个错误： 12345678910111213@Testpublic void givenNotMatchingEmailPassword_whenPostNewUserForm_thenOk() throws Exception &#123; this.mockMvc.perform(MockMvcRequestBuilders .post(\"/user\") .accept(MediaType.TEXT_HTML) .param(\"email\", \"john@yahoo.com\") .param(\"verifyEmail\", \"john@yahoo.commmm\") .param(\"password\", \"pass\") .param(\"verifyPassword\", \"passsss\")) .andExpect(model().errorCount(2)) .andExpect(status().isOk()); &#125; 10. Summary在这篇快速的文章中，我们展示了如何创建自定义验证器来验证一个字段或类，并将它们连接到Spring MVC中。","tags":[{"name":"spring,springmvc","slug":"spring-springmvc","permalink":"http://yoursite.com/tags/spring-springmvc/"}]},{"title":"An Intro to the Spring DispatcherServlet","date":"2017-06-23T01:33:23.838Z","path":"2017/06/23/An Intro to the Spring DispatcherServlet/","text":"1. Introduction简单地说，在前端控制器设计模式中，单个控制器负责将传入的HttpRequest引导到所有应用程序的其他控制器和处理程序。 Spring的DispatcherServlet实现了这种模式，因此负责正确地协调HttpRequests到他们的右边处理程序。 在本文中，我们将检查Spring DispatcherServlet的请求处理工作流程以及如何实现参与此工作流程的多个接口。 2. DispatcherServlet Request ProcessingDispatcherServlet本质上处理传入的HttpRequest，委托请求，并根据在Spring应用程序中实现的配置的HandlerAdapter接口以及指定处理程序，控制器端点和响应对象的附注进行处理。 让我们深入了解DispatcherServlet如何处理组件： 在DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE下关联到DispatcherServlet的WebApplicationContext被搜索并提供给进程的所有元素 DispatcherServlet发现使用getHandler（）为您的调度程序配置的HandlerAdapter接口的所有实现 - 每个发现和配置的实现都通过handle（）方法通过该进程的其余部分来处理请求 LocaleResolver可选地绑定到请求，以使进程中的元素能够解析该区域设置 ThemeResolver可选地绑定到请求，让元素（如视图）确定要使用哪个主题 如果指定了MultipartResolver，则会为MultipartFiles检查该请求 - 任何找到的都包含在MultipartHttpServletRequest中以进一步处理 在WebApplicationContext中声明的HandlerExceptionResolver实现在处理请求期间提取异常 3. HandlerAdapter InterfacesHandlerAdapter接口有助于通过几个特定接口使用控制器，servlet，HttpRequests和HTTP路径。 HandlerAdapter接口因此通过DispatcherServlet请求处理工作流程的许多阶段起着至关重要的作用 首先，每个HandlerAdapter实现都从调度器的getHandler（）方法放入HandlerExecutionChain中。然后，随着执行链的进行，这些实现中的每个实现都会处理（）HttpServletRequest对象。 在以下部分中，我们将更详细地探讨一些最重要和最常用的HandlerAdapter。 3.1. Mappings要了解映射，我们需要先看看如何注释控制器，因为控制器对于HandlerMapping接口是至关重要的。 SimpleControllerHandlerAdapter允许在没有@Controller注释的情况下显式地实现控制器。 RequestMappingHandlerAdapter支持使用@RequestMapping注释注释的方法。 我们将在此处关注@Controller注释，但是也可以使用一些有用的资源，并使用SimpleControllerHandlerAdapter的几个示例。 @RequestMapping注释设置与它相关联的WebApplicationContext中处理程序可用的特定端点。 我们来看一个公开和处理’/ user / example’端点的控制器的例子： 12345678910@Controller@RequestMapping(\"/user\")@ResponseBodypublic class UserController &#123; @GetMapping(\"/example\") public User fetchUserExample() &#123; // ... &#125;&#125; 由@RequestMapping注释指定的路径通过HandlerMapping接口在内部进行管理。 RL结构自然相对于DispatcherServlet本身，并由servlet映射确定。因此，如果DispatcherServlet映射到“/”，则所有映射将被该映射覆盖。 但是，如果servlet映射是’/ dispatcher’，那么任何@RequestMapping注释都将与该根URL相关。 记住’/‘与servlet映射的’/ *’不一样！ ‘/‘是默认映射，并将所有URL公开给调度员的责任区域。 ‘/ *’让许多较新的Spring开发者感到困惑。它没有指定具有相同URL上下文的所有路径都属于调度员的责任区域。相反，它会覆盖并忽略其他调度器映射。所以’/ example’将会成为404！ 因此，除非非常有限的情况（如配置过滤器），否则不应使用’/ *’。 3.2. HTTP Request HandlingDispatcherServlet的核心职责是将传入的HttpRequests发送到使用@Controller或@RestController注释指定的正确处理程序。 作为旁注，@Controller和@RestController的主要区别是如何生成响应 - @RestController默认定义了@ResponseBody。 在这里我们可以找到关于Spring控制器的更深入的写作。 3.3. The ViewResolver InterfaceViewResolver作为ApplicationContext对象上的配置设置附加到DispatcherServlet。 ViewResolver确定调度员提供什么样的视图以及从哪里提供的视图。 以下是我们将放入WebMvcConfigurerAdapter中以呈现JSP页面的示例配置： 123456789101112131415@Configuration@EnableWebMvc@ComponentScan(\"com.baeldung.springdispatcherservlet\")public class AppConfig extends WebMvcConfigurerAdapter &#123; @Bean public UrlBasedViewResolver viewResolver() &#123; UrlBasedViewResolver resolver = new UrlBasedViewResolver(); resolver.setPrefix(\"/WEB-INF/jsp/\"); resolver.setSuffix(\".jsp\"); resolver.setViewClass(JstlView.class); return resolver; &#125;&#125; 一个常见的问题是调度员的ViewResolver和整个项目目录结构的关联程度。我们来看看基础知识。 以下是使用Spring的XML配置的InternalViewResolver的示例路径配置： 1&lt;property name=\"prefix\" value=\"/jsp/\"/&gt; 为了我们的例子，我们假设我们的应用程序正在托管在： 1http://localhost:8080/ 这是本地托管的Apache Tomcat服务器的默认地址和端口。 假设我们的应用程序称为dispatcherexample-1.0.0，我们的JSP视图将可以从以下位置访问： http://localhost:8080/dispatcherexample-1.0.0/jsp/ 在Maven的普通Spring项目中，这些视图的路径是： 1234567src -| main -| java resources webapp -| jsp WEB-INF 视图的默认位置在WEB-INF中。在上面的代码段中为我们的InternalViewResolver指定的路径确定了您的视图可用的“src / main / webapp”的子目录。 3.6. The MultipartResolver InterfaceMultipartResolver实现检查多部分的请求，并将它们包装在MultipartHttpServletRequest中，以便在发现至少一个multipart的过程中进一步处理其他元素。添加到AppConfig： 12345678@Beanpublic CommonsMultipartResolver multipartResolver() throws IOException &#123; CommonsMultipartResolver resolver = new CommonsMultipartResolver(); resolver.setMaxUploadSize(10000000); return resolver;&#125; 现在我们已经配置了MultipartResolver bean，我们设置一个控制器来处理MultipartFile请求： 123456789101112131415161718192021222324252627@Controllerpublic class MultipartController &#123; @Autowired ServletContext context; @PostMapping(\"/upload\") public ModelAndView FileuploadController( @RequestParam(\"file\") MultipartFile file) throws IOException &#123; ModelAndView modelAndView = new ModelAndView(\"index\"); InputStream in = file.getInputStream(); String path = new File(\".\").getAbsolutePath(); FileOutputStream f = new FileOutputStream( path.substring(0, path.length()-1) + \"/uploads/\" + file.getOriginalFilename()); int ch; while ((ch = in.read()) != -1) &#123; f.write(ch); &#125; f.flush(); f.close(); modelAndView.getModel() .put(\"message\", \"File uploaded successfully!\"); return modelAndView; &#125;&#125; 3.7. The HandlerExceptionResolver InterfaceSpring的HandlerExceptionResolver为整个Web应用程序，单个控制器或一组控制器提供统一的错误处理。 要提供应用程序范围的自定义异常处理，请创建一个使用@ControllerAdvice注释的类： 123456789@ControllerAdvicepublic class ExampleGlobalExceptionHandler &#123; @ExceptionHandler @ResponseBody public String handleExampleException(Exception e) &#123; // ... &#125;&#125; 使用@ExceptionHandler注释的类中的任何方法将在调度员的责任区域内的每个控制器上都可用。 DispatcherServlet的ApplicationContext中的HandlerExceptionResolver接口的实现可用于在使用@ExceptionHandler作为注释时拦截该调度程序的责任区域下的特定控制器，并将正确的类作为参数传入： 123456789@Controllerpublic class FooController&#123; @ExceptionHandler(&#123; CustomException1.class, CustomException2.class &#125;) public void handleException() &#123; // ... &#125; // ...&#125; 如果发生异常CustomException1或CustomException2，handleException（）方法现在将作为上述示例中的FooController的异常处理程序。 这是一篇关于Spring Web应用程序中的异常处理的文章。","tags":[{"name":"spring,springmvc","slug":"spring-springmvc","permalink":"http://yoursite.com/tags/spring-springmvc/"}]},{"title":"How to Get All Spring-Managed Beans?","date":"2017-06-23T01:33:03.228Z","path":"2017/06/23/如何获取spring管理的所有的bean/","text":"1.概述在本文中，我们将探讨如何使用容器显示所有Spring管理的不同的bean。 2. The IoC Container一个bean是Spring管理的应用程序的基础;所有的bean都与IOC容器一起居住，IOC容器负责管理其生命周期。 我们可以通过两种方式获取此容器中所有bean的列表： 使用ListableBeanFactory接口 使用 Spring Boot Actuator 3. Using ListableBeanFactory InterfaceListableBeanFactory接口提供getBeanDefinitionNames（）方法，该方法返回此工厂中定义的所有bean的名称。该接口由预先加载其bean定义以枚举其所有bean实例的所有bean工厂实现。您可以在官方文档中找到所有已知子接口及其实现类的列表。对于这个例子，我们将使用一个Spring引导应用程序。首先，我们将创建一些Spring bean。我们来创建一个简单的Spring Controller FooController： 12345678910111213@Controllerpublic class FooController &#123; @Autowired private FooService fooService; @RequestMapping(value=\"/displayallbeans\") public String getHeaderAndBody(Map model)&#123; model.put(\"header\", fooService.getHeader()); model.put(\"message\", fooService.getBody()); return \"displayallbeans\"; &#125;&#125; 这个Controller依赖于另一个Spring bean FooService： 12345678910111213@Servicepublic class FooService &#123; public String getHeader() &#123; return \"Display All Beans\"; &#125; public String getBody() &#123; return \"This is a sample application that displays all beans \" + \"in Spring IoC container using ListableBeanFactory interface \" + \"and Spring Boot Actuators.\"; &#125;&#125; 请注意，我们在这里创建了两个不同的bean： fooController fooService 在执行此应用程序时，我们将使用applicationContext对象并调用其getBeanDefinitionNames（）方法，该方法将返回我们的applicationContext容器中的所有bean： 12345678910111213141516@SpringBootApplicationpublic class Application &#123; private static ApplicationContext applicationContext; public static void main(String[] args) &#123; applicationContext = SpringApplication.run(Application.class, args); displayAllBeans(); &#125; public static void displayAllBeans() &#123; String[] allBeanNames = applicationContext.getBeanDefinitionNames(); for(String beanName : allBeanNames) &#123; System.out.println(beanName); &#125; &#125;&#125; 这将打印来自applicationContext容器的所有bean： 123fooControllerfooService//other beans 请注意，随着我们定义的bean，它还将记录在此容器中的所有其他bean。为了清楚起见，我们在这里省略了，因为它们有很多。 4. Using Spring Boot ActuatorSpring Boot Actuator功能提供端点，用于监视我们应用程序的统计信息。 它包括许多内置的端点，包括/ beans。这将显示我们应用程序中所有Spring管理bean的完整列表。您可以在官方文档中找到现有端点的完整列表。现在我们将在我们的application.properties中配置我们的beans端点： 12endpoints.beans.id=springbeansendpoints.beans.sensitive=false 在这里，我们正在设置bean端点的id。这个springbeans id现在将映射到一个URL，该URL将用于通过HTTP访问它。我们将敏感属性设置为false，以便我们可以在不进行身份验证的情况下访问它。如果我们只想要验证的用户查看数据，我们可以将其保留为默认值true。 现在，我们只需点击URL http：// &lt;address&gt;：&lt;management-port&gt; / springbeans。如果没有指定任何单独的管理端口，我们可以使用我们的默认服务器端口。这将返回显示Spring IoC容器中所有Bean的JSON响应： 1234567891011121314151617181920212223242526272829[ &#123; \"context\": \"application:8080\", \"parent\": null, \"beans\": [ &#123; \"bean\": \"fooController\", \"aliases\": [], \"scope\": \"singleton\", \"type\": \"com.baeldung.displayallbeans.controller.FooController\", \"resource\": \"file [E:/Workspace/tutorials-master/spring-boot/target /classes/com/baeldung/displayallbeans/controller/FooController.class]\", \"dependencies\": [ \"fooService\" ] &#125;, &#123; \"bean\": \"fooService\", \"aliases\": [], \"scope\": \"singleton\", \"type\": \"com.baeldung.displayallbeans.service.FooService\", \"resource\": \"file [E:/Workspace/tutorials-master/spring-boot/target/ classes/com/baeldung/displayallbeans/service/FooService.class]\", \"dependencies\": [] &#125;, // ...other beans ] &#125;] 当然，这也包含许多其他豆类，它们位于同一个spring容器中，但是为了清楚起见，我们在这里省略了它们。 5. Conclusion在本文中，我们学习了如何使用ListableBeanFactory界面和Spring Boot Actuator在Spring IoC容器中显示所有bean。","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"Spring RequestMapping","date":"2017-06-23T01:32:07.306Z","path":"2017/06/23/Spring RequestMapping/","text":"1. Overview在本文中，我们将重点介绍Spring MVC - @RequestMapping中的一个主要注释。 简单地说，注释用于将Web请求映射到Spring Controller方法。 2. @RequestMapping Basics我们从一个简单的例子开始 - 将HTTP请求映射到使用一些基本条件的方法。 2.1. @RequestMapping – by Path12345@RequestMapping(value = \"/ex/foos\", method = RequestMethod.GET)@ResponseBodypublic String getFoosBySimplePath() &#123; return \"Get some Foos\";&#125; 要使用简单的curl命令测试此映射，请运行： curl -i http://localhost:8080/spring-rest/ex/foos 2.2. @RequestMapping – the HTTP MethodHTTP方法参数没有默认值 - 所以如果我们没有指定值，它将映射到任何HTTP请求。 这是一个简单的例子，类似于上一个例子 - 但这次映射到一个HTTP POST请求： 12345@RequestMapping(value = \"/ex/foos\", method = POST)@ResponseBodypublic String postFoos() &#123; return \"Post some Foos\";&#125; 通过curl命令测试POST： 1curl -i -X POST http://localhost:8080/spring-rest/ex/foos 3. RequestMapping and HTTP Headers3.1. @RequestMapping with the headers Attribute可以通过指定请求的标题来进一步缩小映射： 12345@RequestMapping(value = \"/ex/foos\", headers = \"key=val\", method = GET)@ResponseBodypublic String getFoosWithHeader() &#123; return \"Get some Foos with Header\";&#125; 甚至通过@RequestMapping的头属性的多个头文件： 1234567@RequestMapping( value = \"/ex/foos\", headers = &#123; \"key1=val1\", \"key2=val2\" &#125;, method = GET)@ResponseBodypublic String getFoosWithHeaders() &#123; return \"Get some Foos with Header\";&#125; 要测试操作，我们将使用curl header 支持： 1curl -i -H \"key:val\" http://localhost:8080/spring-rest/ex/foos 请注意，对于用于分离头文件和头值的语法是一个冒号，与HTTP规范相同，而在Spring中则使用等号。 3.2. @RequestMapping Consumes and Produces映射由控制器方法生成的媒体类型值得特别注意 - 我们可以通过上面介绍的@RequestMapping头部属性来映射基于其Accept头部的请求： 12345678@RequestMapping( value = \"/ex/foos\", method = GET, headers = \"Accept=application/json\")@ResponseBodypublic String getFoosAsJsonFromBrowser() &#123; return \"Get some Foos with Header Old\";&#125; 用于定义Accept标头的这种匹配是灵活的 - 它使用contains而不是equals，因此下面的请求仍然会正确映射： 12curl -H \"Accept:application/json,text/html\" http://localhost:8080/spring-rest/ex/foos 从Spring 3.1开始，@RequestMapping注释现在具有生产和消耗属性，特别是为此目的： 123456789@RequestMapping( value = \"/ex/foos\", method = RequestMethod.GET, produces = \"application/json\")@ResponseBodypublic String getFoosAsJsonFromREST() &#123; return \"Get some Foos with Header New\";&#125; 此外，具有headers属性的旧类型的映射将自动从Spring 3.1开始转换为新的生成机制，因此结果将相同。 相同的方式consumed ： 12curl -H \"Accept:application/json\" http://localhost:8080/spring-rest/ex/foos 此外，还生成支持多个值： 12345@RequestMapping( value = \"/ex/foos\", method = GET, produces = &#123; \"application/json\", \"application/xml\" &#125;) 请记住，这些 - 旧的方式和指定accept标头的新方法基本上是一样的映射，所以Spring不会允许它们在一起使用 - 将这两个方法都激活会导致： 123456789101112131415Caused by: java.lang.IllegalStateException: Ambiguous mapping found. Cannot map 'fooController' bean method java.lang.String org.baeldung.spring.web.controller .FooController.getFoosAsJsonFromREST()to &#123; [/ex/foos], methods=[GET],params=[],headers=[], consumes=[],produces=[application/json],custom=[]&#125;: There is already 'fooController' bean methodjava.lang.String org.baeldung.spring.web.controller .FooController.getFoosAsJsonFromBrowser() mapped. 关于新产品和消费机制的最后一个注释 - 这些行为与大多数其他注释的行为不同：当在类型级别指定时，方法级注释不补充，而是覆盖类型级别信息。 4. RequestMapping with Path Variables映射URI的一部分可以通过@PathVariable注释绑定到变量。 4.1. Single @PathVariable单个路径变量的简单示例： 123456@RequestMapping(value = \"/ex/foos/&#123;id&#125;\", method = GET)@ResponseBodypublic String getFoosBySimplePathWithPathVariable( @PathVariable(\"id\") long id) &#123; return \"Get a specific Foo with id=\" + id;&#125; 如果方法参数的名称与路径变量的名称完全匹配，则可以使用无值的@PathVariable来简化此操作： 123456@RequestMapping(value = \"/ex/foos/&#123;id&#125;\", method = GET)@ResponseBodypublic String getFoosBySimplePathWithPathVariable( @PathVariable String id) &#123; return \"Get a specific Foo with id=\" + id;&#125; 请注意，@PathVariable受益于自动类型转换，因此我们也可以将该ID声明为： 1@PathVariable long id 4.2. Multiple @PathVariable更复杂的URI可能需要将URI的多个部分映射到多个值： 1234567@RequestMapping(value = \"/ex/foos/&#123;fooid&#125;/bar/&#123;barid&#125;\", method = GET)@ResponseBodypublic String getFoosBySimplePathWithPathVariables (@PathVariable long fooid, @PathVariable long barid) &#123; return \"Get a specific Bar with id=\" + barid + \" from a Foo with id=\" + fooid;&#125; 4.3. @PathVariable with RegEx映射@PathVariable时也可以使用正则表达式;例如，我们将把映射限制为仅接受id的数值： 123456@RequestMapping(value = \"/ex/bars/&#123;numericId:[\\\\d]+&#125;\", method = GET)@ResponseBodypublic String getBarsBySimplePathWithPathVariable( @PathVariable long numericId) &#123; return \"Get a specific Bar with id=\" + numericId;&#125; 这将意味着以下URI将匹配： 1http://localhost:8080/spring-rest/ex/bars/1 但这不会匹配： 1http://localhost:8080/spring-rest/ex/bars/abc 5. RequestMapping with Request Parameters@RequestMapping允许使用@RequestParam注释轻松映射URL参数。 我们现在正在将请求映射到URI，如： 123456789http://localhost:8080/spring-rest/ex/bars?id=100@RequestMapping(value = \"/ex/bars\", method = GET)@ResponseBodypublic String getBarBySimplePathWithRequestParam( @RequestParam(\"id\") long id) &#123; return \"Get a specific Bar with id=\" + id;&#125; 然后我们使用控制器方法签名中的@RequestParam（“id”）注释来提取id参数的值 使用id参数发送请求，我们将在curl中使用参数支持： curl -i -d id=100 http://localhost:8080/spring-rest/ex/bars 在这个例子中，参数是直接绑定的，而不是先被声明。对于更高级的场景，@RequestMapping可以可选地定义参数，这也是缩小请求映射的另一种方法： 123456@RequestMapping(value = \"/ex/bars\", params = \"id\", method = GET)@ResponseBodypublic String getBarBySimplePathWithExplicitRequestParam( @RequestParam(\"id\") long id) &#123; return \"Get a specific Bar with id=\" + id;&#125; 允许更灵活的映射 - 可以设置多个参数值，并不需要全部使用它们： 123456789@RequestMapping( value = \"/ex/bars\", params = &#123; \"id\", \"second\" &#125;, method = GET)@ResponseBodypublic String getBarBySimplePathWithExplicitRequestParams( @RequestParam(\"id\") long id) &#123; return \"Narrow Get a specific Bar with id=\" + id;&#125; 我们可以这样请求URI： http://localhost:8080/spring-rest/ex/bars?id=100&amp;second=something 将始终映射到最佳匹配 - 这是较精细的匹配，它定义了id和second参数。 6. RequestMapping Corner Cases6.1. @RequestMapping – multiple paths mapped to the same controller method虽然单个控制器方法通常使用一个@RequestMapping路径值，但这只是一个很好的做法，而不是一个很难和快速的规则 - 有些情况可能需要将多个请求映射到同一个方法。对于这种情况，@RequestMapping的value属性确实接受多个映射，而不仅仅是一个映射： 1234567@RequestMapping( value = &#123; \"/ex/advanced/bars\", \"/ex/advanced/foos\" &#125;, method = GET)@ResponseBodypublic String getFoosOrBarsByPath() &#123; return \"Advanced - Get some Foos or Bars\";&#125; 现在，这两个curl命令都应该使用相同的方法： 12curl -i http://localhost:8080/spring-rest/ex/advanced/fooscurl -i http://localhost:8080/spring-rest/ex/advanced/bars 6.2. @RequestMapping – multiple HTTP request methods to the same controller method使用不同HTTP动词的多个请求可以映射到相同的控制器方法： 12345678@RequestMapping( value = \"/ex/foos/multiple\", method = &#123; RequestMethod.PUT, RequestMethod.POST &#125;)@ResponseBodypublic String putAndPostFoos() &#123; return \"Advanced - PUT and POST within single method\";&#125; 使用curl，这两个现在将访问同样的方法： 12curl -i -X POST http://localhost:8080/spring-rest/ex/foos/multiplecurl -i -X PUT http://localhost:8080/spring-rest/ex/foos/multiple 6.3. @RequestMapping – a fallback for all requests要使用特定的HTTP方法为所有请求实现一个简单的回调 - 例如，对于GET： 12345@RequestMapping(value = \"*\", method = RequestMethod.GET)@ResponseBodypublic String getFallback() &#123; return \"Fallback for GET Requests\";&#125; 甚至对于所有请求： 1234567@RequestMapping( value = \"*\", method = &#123; RequestMethod.GET, RequestMethod.POST ... &#125;)@ResponseBodypublic String allFallback() &#123; return \"Fallback for All Requests\";&#125; 7. New Request Mapping Shortcuts在Spring Framework 4.3中引入了基于HTTP方法的@RequestMapping注释： @GetMapping @PostMapping @PutMapping @DeleteMapping @PatchMapping 这些新的注释大大提高了可读性，并减少了代码的冗长度(verbosity )。我们通过创建一个支持CRUD操作的RESTful API来查看这些新的注释： 123456789101112131415161718192021@GetMapping(\"/&#123;id&#125;\")public ResponseEntity&lt;?&gt; getBazz(@PathVariable String id)&#123; return new ResponseEntity&lt;&gt;(new Bazz(id, \"Bazz\"+id), HttpStatus.OK);&#125; @PostMappingpublic ResponseEntity&lt;?&gt; newBazz(@RequestParam(\"name\") String name)&#123; return new ResponseEntity&lt;&gt;(new Bazz(\"5\", name), HttpStatus.OK);&#125; @PutMapping(\"/&#123;id&#125;\")public ResponseEntity&lt;?&gt; updateBazz( @PathVariable String id, @RequestParam(\"name\") String name) &#123; return new ResponseEntity&lt;&gt;(new Bazz(id, name), HttpStatus.OK);&#125; @DeleteMapping(\"/&#123;id&#125;\")public ResponseEntity&lt;?&gt; deleteBazz(@PathVariable String id)&#123; return new ResponseEntity&lt;&gt;(new Bazz(id), HttpStatus.OK);&#125; 8. Spring ConfigurationSpring MVC配置很简单 - 考虑到我们的FooController在以下包中定义： 1234package org.baeldung.spring.web.controller; @Controllerpublic class FooController &#123; ... &#125; 我们只需要一个@Configuration类来启用完整的MVC支持，并为控制器配置类路径扫描： 123456@Configuration@EnableWebMvc@ComponentScan(&#123; \"org.baeldung.spring.web.controller\" &#125;)public class MvcConfig &#123; //&#125; 9. Conclusion本文重点介绍Spring中的@RequestMapping注释 - 讨论一个简单的用例，HTTP头的映射，URI的部分绑定与@PathVariable绑定，并使用URI参数和@RequestParam注释。","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"Java Bean Validation Basics","date":"2017-06-23T01:31:54.901Z","path":"2017/06/23/Java Bean Validation Basics/","text":"1. Overview在这篇快速的文章中，我们将介绍使用标准框架（JSR 303和JSR 349）来验证Java bean的基础知识。 在大多数应用程序中验证用户输入当然是一个超常见的要求，Java Bean验证框架已成为处理这种逻辑的事实上的标准。 2. JSR 303 and JSR 349JSR 303是用于bean验证的Java API的一个规范，它是JavaEE和JavaSE的一部分，它确保bean的属性符合特定标准，使用诸如@NotNull，@Min和@Max之类的注释。 JSR 349扩展了JSR 303，具有诸如约束冲突消息中的动态表达式评估，消息插入等功能。 有关规范的完整信息，请阅读JSR 303或JSR 349 JSR。 3. Dependencies我们将在这里使用Maven示例来显示确切的所需依赖关系，但是当然这些jar可以通过多种方式添加到项目中。 3.1. Validation API根据规范JSR 303和349，验证api依赖项包含标准验证API： 12345&lt;dependency&gt; &lt;groupId&gt;javax.validation&lt;/groupId&gt; &lt;artifactId&gt;validation-api&lt;/artifactId&gt; &lt;version&gt;1.1.0.Final&lt;/version&gt;&lt;/dependency&gt; 3.2. Validation API Reference ImplementationHibernate Validator是验证API的参考实现。为了使用它，我们必须添加以下依赖关系。 12345678910&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.2.1.Final&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator-annotation-processor&lt;/artifactId&gt; &lt;version&gt;5.2.1.Final&lt;/version&gt;&lt;/dependency&gt; 这里的一个快速说明是，hibernate验证器与Hibernate的持久性方面完全分离，并将其作为依赖项添加，我们不将这些持久性方面添加到项目中。 3.3. Expression Language DependenciesJSR 349提供变量插值，允许表达式在违例消息中。为了解析这些表达式，我们必须在表达式语言API和该API的实现上添加依赖关系。 GlassFish提供了参考实现。 1234567891011&lt;dependency&gt; &lt;groupId&gt;javax.el&lt;/groupId&gt; &lt;artifactId&gt;javax.el-api&lt;/artifactId&gt; &lt;version&gt;2.2.4&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt; &lt;artifactId&gt;javax.el&lt;/artifactId&gt; &lt;version&gt;2.2.4&lt;/version&gt;&lt;/dependency&gt; 如果未添加这些JAR，则会在运行时收到错误消息，如下所示： 1HV000183: Unable to load ‘javax.el.ExpressionFactory’. Check that you have the EL dependencies on the classpath, or use ParameterMessageInterpolator instead 4. Using Validation Annotations我们将使用User bean作为这里的主要示例，并致力于为其添加一些简单的验证： 1234567891011121314151617181920212223import javax.validation.constraints.AssertTrue;import javax.validation.constraints.Max;import javax.validation.constraints.Min;import javax.validation.constraints.NotNull;import javax.validation.constraints.Size; public class User &#123; @NotNull(message = \"Name cannot be null\") private String name; @AssertTrue private boolean working; @Size(min = 10, max = 200, message = \"About Me must be between 10 and 200 characters\") private String aboutMe; @Min(value = 18, message = \"Age should not be less than 18\") @Max(value = 150, message = \"Age should not be greater than 150\") private int age; // standard setters and getters &#125; 示例中使用的所有注释都是标准JSR注释： @NotNull – Validates that the annotated property value is not null 验证注释的属性值不为null @AssertTrue – Validates that the annotated property value is true 验证注释属性值为true @Size – Validates that the annotated property value has a size between the attributes min and max; can be applied to String, Collection, Map, and array properties 验证注释属性值的大小在属性min和max之间;可以应用于String，Collection，Map和数组属性 @Min – Validates that the annotated property has a value no smaller than the value attribute 验证注释属性的值不小于value属性 @Max – Validates that the annotated property has a value no larger than the value attribute 验证注释属性的值不大于value属性 些注释接受附加属性，但是message属性对它们都是共同的。这是当相应属性的值验证失败时通常会显示的消息。 5. Programmatic Validation一些框架（如Spring）有简单的方法可以通过使用注释触发验证过程。这主要是因为我们不必与编程验证API进行交互。 我们现在去手动路线，实际上是以编程方式设置的： 12ValidatorFactory factory = Validation.buildDefaultValidatorFactory();Validator validator = factory.getValidator(); 为了验证一个bean，我们必须先使用一个ValidatorFactory来构造一个Validator对象。 5.1. Defining the Bean我们不会设置这个无效用户 - 使用空值名称： 1234User user = new User();user.setWorking(true);user.setAboutMe(\"Its all about me!\");user.setAge(50); 5.2. Validate the Bean现在我们有一个验证器，我们可以通过将它传递给validate方法来验证我们的bean。任何违反User对象中定义的约束的行为都将返回为Set。 Set","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"介绍Spring Remoting与HTTP Invokers","date":"2017-06-23T01:31:46.226Z","path":"2017/06/23/介绍Spring Remoting与HTTP Invokers/","text":"1. Overview在某些情况下，我们需要将系统分解成几个进程，每个进程都承担我们应用的不同方面的责任。在这些情况下，其中一个进程需要同步从另一个进程获取数据。 Spring Framework提供了一系列全面的称为Spring Remoting的工具，它允许我们调用远程服务，至少在某种程度上可以在本地使用。 在本文中，我们将基于Spring的HTTP调用器设置一个应用程序，该应用程序利用本机Java序列化和HTTP来在客户端和服务器应用程序之间提供远程方法调用。 2. Service Definition 服务定义假设我们要实施一个允许用户在驾驶室内预订乘坐系统。我们还假设我们选择构建两个不同(distinct)的应用程序来实现这一目标 一个预订引擎应用程序，以检查是否可以提供驾驶室请求，以及 一个前端Web应用程序，允许客户预订他们的乘车，确保驾驶室的可以有车被预定 2.1. Service Interface 服务界面当我们使用HTTP invokerr进行Spring Remoting时，我们必须通过一个接口定义我们的远程可访问服务，让Spring在客户端和服务器端创建代理，从而封装远程调用的技术。所以让我们开始一个服务的界面，让我们预订出租车： 123public interface CabBookingService &#123; Booking bookRide(String pickUpLocation) throws BookingException;&#125; 如果服务无法预订出租车，则会抛出一个BookingException异常。在这种情况下，不需要将类标记为Serializable，因为Exception已经实现了它： 12345public class BookingException extends Exception &#123; public BookingException(String message) &#123; super(message); &#125;&#125; 2.2. Packaging the Service 包装服务服务界面以及用作参数的所有自定义类，返回类型和异常必须在客户端和服务器的类路径中都可用。 执行此操作的最有效方法之一就是将它们全部包含在.jar文件中，该文件可以在服务器和客户端的pom.xml中作为依赖关系。 所以我们把所有的代码放在专门的Maven模块中，叫做“api”;我们将使用以下Maven坐标： 123&lt;groupId&gt;com.baeldung&lt;/groupId&gt;&lt;artifactId&gt;api&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; 3. Server Application 服务程序我们来构建预订引擎应用程序，以使用Spring Boot公开服务 3.1. Maven Dependencies首先，您需要确保您的项目正在使用Spring Boot： 12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.3.RELEASE&lt;/version&gt;&lt;/parent&gt; 你可以在这里找到最后一个Spring Boot版本。然后我们需要Web启动器模块： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 我们需要我们在上一步中组装的服务定义模块： 3.2. Service Implementation 服务实现我们首先定义一个实现服务接口的类： 1234567public class CabBookingServiceImpl implements CabBookingService &#123; @Override public Booking bookPickUp(String pickUpLocation) throws BookingException &#123; if (random() &lt; 0.3) throw new BookingException(\"Cab unavailable\"); return new Booking(randomUUID().toString()); &#125;&#125; 假设这是一个可能的实现。使用具有随机值的测试，我们将能够重现两个成功的场景 - 当找到可用的驾驶室并返回一个预留代码，并且发生故障时 - 抛出一个BookingException来表示没有任何可用的驾驶室。 3.3. Exposing the Service 公开服务然后，我们需要在上下文中定义一个类型为HttpInvokerServiceExporter的bean的应用程序。它将在Web应用程序中暴露一个HTTP入口点，这将由客户端稍后调用： 12345678910111213141516@Configuration@ComponentScan@EnableAutoConfigurationpublic class Server &#123; @Bean(name = \"/booking\") HttpInvokerServiceExporter accountService() &#123; HttpInvokerServiceExporter exporter = new HttpInvokerServiceExporter(); exporter.setService( new CabBookingServiceImpl() ); exporter.setServiceInterface( CabBookingService.class ); return exporter; &#125; public static void main(String[] args) &#123; SpringApplication.run(Server.class, args); &#125;&#125; 值得注意的是，Spring的HTTP调用者使用HttpInvokerServiceExporter bean的名称作为HTTP端点URL的相对路径 我们现在可以在设置客户端应用程序时启动服务器应用程序并保持运行。 4. Client Application现在我们来写客户端应用程序。 4.1. Maven Dependencies我们将使用相同的服务定义和我们在服务器端使用的相同的Spring引导版本。我们仍然需要Web起始依赖关系，但由于我们不需要自动启动嵌入式容器，因此我们可以从依赖关系中排除Tomcat启动器： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 4.2. Client Implementation让我们来是想客户端： 123456789101112131415161718@Configurationpublic class Client &#123; @Bean public HttpInvokerProxyFactoryBean invoker() &#123; HttpInvokerProxyFactoryBean invoker = new HttpInvokerProxyFactoryBean(); invoker.setServiceUrl(\"http://localhost:8080/booking\"); invoker.setServiceInterface(CabBookingService.class); return invoker; &#125; public static void main(String[] args) throws BookingException &#123; CabBookingService service = SpringApplication .run(Client.class, args) .getBean(CabBookingService.class); out.println(service.bookRide(\"13 Seagate Blvd, Key Largo, FL 33037\")); &#125;&#125; @Bean注释的invoker（）方法创建一个HttpInvokerProxyFactoryBean的实例。我们需要通过setServiceUrl（）方法提供远程服务器响应的URL。 与我们为服务器做的一样，我们还应该通过setServiceInterface（）方法提供我们想要远程调用的服务的接口。 HttpInvokerProxyFactoryBean实现了Spring的FactoryBean。一个FactoryBean被定义为一个bean，但是Spring IoC容器将注入它创建的对象，而不是工厂本身。您可以在我们的工厂bean文章中找到关于FactoryBean的更多详细信息。 main（）方法引导独立应用程序，并从上下文获取CabBookingService的实例。在引擎盖下，此对象只是由HttpInvokerProxyFactoryBean创建的代理，它负责执行远程调用所涉及的所有技术性。感谢它让我们可以轻松地使用代理，就像我们在本地可用的服务实现一样。 让我们多次运行应用程序来执行多个远程调用，以验证客户端在出租车是否可用时的运行方式。 5. Caveat Emptor 注意事项当我们使用允许远程调用的技术时，我们必须应该知道他的一些陷阱。 5.1谨防网络相关的异常当我们使用不可靠的资源作为网络时，我们应该总是期待意想不到的。 假设客户端正在调用服务器，而无法访问服务器 - 由于网络问题或服务器关闭 - 那么Spring Remoting会引发一个RuntimeException异常的RemoteAccessException。 编译器不会迫使我们将调用包含在try-catch块中，但是我们应该始终考虑这样做，以正确地管理网络问题。 5.2. Objects are Transferred by Value, not by ReferenceSpring Remoting HTTP传递方法参数并且返回值以便在网络上传输它们。这意味着服务器将作用于提供的参数的副本，并且客户端对由服务器创建的结果的副本执行操作。 所以我们不能指望，例如，在结果对象上调用一个方法会改变服务器端同一对象的状态，因为客户端和服务器之间没有任何共享对象。 5.3。注意细粒度接口通过网络边界调用方法比在同一进程中的对象上调用方法要慢得多。 因此，通过较粗糙的界面来定义应该远程调用服务的服务通常是一个很好的做法，即使以更麻烦的界面为代价，也能够完成需要较少交互的业务交易。 6. Conclusion有了这个例子，我们看到Spring Remoting如何方便地调用远程进程。 该解决方案比其他广泛的机制（如REST或Web服务）稍微开放，但是在所有组件都使用Spring开发的情况下，它可以代表可行且更快速的替代方案。","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"Introduction to RabbitMQ","date":"2017-06-23T01:31:38.721Z","path":"2017/06/23/Introduction to RabbitMQ/","text":"Introduction to RabbitMQ1. Overview软件组件的去耦是软件设计中最重要的部分之一。实现这一点的一种方法是使用消息系统，其提供组件（服务）之间的异步通信方式。在本文中，我们将介绍一个这样的系统：RabbitMQ RabbitMQ是实现高级消息队列协议（AMQP）的消息代理。它为主要的编程语言提供客户端库。 除了用于去耦软件组件之外，RabbitMQ可用于： 执行后台操作 执行异步操作 2. Messaging Model首先，让我们快速，高级地了解消息传递的工作原理。 简单地说，有两种应用程序与消息系统交互：生产者和消费者。生产者是向broker发送（发布）消息的消费者，以及从broker接收消息的消费者。通常，该程序（软件组件）在不同的机器上运行，RabbitMQ作为它们之间的通信中间件 在本文中，我们将讨论一个使用RabbitMQ进行通信的两个服务的简单示例。其中一个服务将向RabbitMQ发布消息，另一个将消耗。 3. Setup为了开始，我们在这里使用官方设置指南运行RabbitMQ。 我们自然会使用Java客户端与RabbitMQ服务器交互;该客户端的Maven依赖关系是： 12345&lt;dependency&gt; &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt; &lt;artifactId&gt;amqp-client&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt;&lt;/dependency&gt; 使用官方指南运行RabbitMQ代理后，我们需要使用java客户端连接到它： 1234ConnectionFactory factory = new ConnectionFactory();factory.setHost(\"localhost\");Connection connection = factory.newConnection();Channel channel = connection.createChannel(); 我们使用ConnectionFactory来设置与服务器的连接，它也负责协议（AMQP）和认证。这里我们连接到localhost上的服务器，我们可以使用setHost函数修改主机名。 如果RabbitMQ Server不使用默认端口，我们可以使用setPort设置端口; RabbitMQ的默认端口为15672： factory.setPort(15678); 我们可以设置用户名和密码： factory.setUsername(“user1”);factory.setPassword(“MyPassword”); 此外，我们将使用此连接来发布和使用消息。 4. Producer考虑一个简单的场景，Web应用程序允许用户向网站添加新产品。任何新增产品，我们都需要向客户发送电子邮件。 首先，我们定义一个队列： channel.queueDeclare(“products_queue”, false, false, false, null); 每当用户添加新产品时，我们都会将消息发布到队列中： String message = “product details”;channel.basicPublish(“”, “products_queue”, null, message.getBytes()); 最后，我们关闭渠道和连接： channel.close();connection.close(); 此消息将被另一个负责向客户发送电子邮件的服务使用。 5. Consumer看看我们能实现消费者的一面,我们要声明同一个队列： channel.queueDeclare(“products_queue”, false, false, false, null); 以下是我们如何定义将异步处理来自队列的消息的消费者： 12345678910111213Consumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery( String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String message = new String(body, \"UTF-8\"); // process the message &#125;&#125;;channel.basicConsume(\"products_queue\", true, consumer); 6. Conclusion这篇简单的文章介绍了RabbitMQ的基本概念，并讨论了一个使用它的简单示例。","tags":[{"name":"programming","slug":"programming","permalink":"http://yoursite.com/tags/programming/"}]},{"title":"Spring Remoting with AMQP","date":"2017-06-23T01:31:31.068Z","path":"2017/06/23/Spring Remoting with AMQP/","text":"Spring Remoting with AMQP1. Overview我们在本系列的前一期中看到了如何利用Spring Remoting和相关技术，在服务器和客户端之间的HTTP通道之上启用同步远程过程调用。 在本文中，我们将在AMQP之上探索Spring Remoting，这样可以在利用本质上是异步的介质的同时执行同步RPC。 2. Installing RabbitMQ有各种与AMQP兼容的消息系统，我们可以使用，我们选择RabbitMQ，因为它是一个成熟的平台，它在Spring中得到完全支持 - 两个产品都由同一家公司（Pivotal）进行管理。 如果您不熟悉AMQP或RabbitMQ，您可以阅读我们的快速介绍。 所以，第一步是安装和启动RabbitMQ。有多种方法来安装它 - 只需选择您喜欢的方法，按照官方指南中提到的步骤。 3. Maven Dependencies我们将设置服务器和客户端Spring Boot应用程序来显示AMQP Remoting的工作原理。通常情况下，Spring Boot，我们只需要选择和导入正确的启动器依赖关系，如下所述： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 我们明确地排除了spring-boot-starter-tomcat，因为我们不需要任何嵌入式HTTP服务器 - 如果我们允许Maven导入类路径中的所有传递依赖项，将自动启动。 4. Server Application4.1. Expose the Service正如我们在前面的文章中所示，我们将公开一个模拟可能的远程服务的CabBookingService。 我们首先声明一个实现我们想要远程调用的服务接口的bean。这是在服务器端实际执行服务调用的bean： 1234@BeanCabBookingService bookingService() &#123; return new CabBookingServiceImpl();&#125; 然后我们定义服务器将从中检索调用的队列。在这种情况下，为它指定一个名称就足够了，在构造函数中提供它： 1234@BeanQueue queue() &#123; return new Queue(\"remotingQueue\");&#125; 正如我们从前面的文章中已经知道的那样，Spring Remoting的主要概念之一就是服务导出器，这个组件实际上是从一些来源收集调用请求的 - 在这种情况下是一个RabbitMQ队列 - 并且在服务器上调用所需的方法实现。 在这种情况下，我们定义一个AmqpInvokerServiceExporter，可以看到─需要引用AmqpTemplate。 AmqpTemplate类由Spring Framework提供，简化了与AMQP兼容的消息传递系统的处理方式，与JdbcTemplate更易于处理数据库的方式相同。 我们不会明确定义这样的AmqpTemplate bean，因为它将由Spring Boot自动配置模块自动提供： 123456789@Bean AmqpInvokerServiceExporter exporter( CabBookingService implementation, AmqpTemplate template) &#123; AmqpInvokerServiceExporter exporter = new AmqpInvokerServiceExporter(); exporter.setServiceInterface(CabBookingService.class); exporter.setService(implementation); exporter.setAmqpTemplate(template); return exporter;&#125; 最后，我们需要定义一个容器，它有责任使用队列中的消息，并将它们转发到某些指定的监听器。 然后，我们将将此容器连接到我们在上一步中创建的服务导出器，以允许它接收排队的消息。这里ConnectionFactory由Spring Boot自动提供，与AmqpTemplate相同： 123456789101112@BeanSimpleMessageListenerContainer listener( ConnectionFactory facotry, AmqpInvokerServiceExporter exporter, Queue queue) &#123; SimpleMessageListenerContainer container = new SimpleMessageListenerContainer(facotry); container.setMessageListener(exporter); container.setQueueNames(queue.getName()); return container;&#125; 4.2. Configuration我们记得设置application.properties文件以允许Spring Boot配置基本对象。显然，参数的值也取决于RabbitMQ的安装方式。 例如，当RabbitMQ运行该示例运行的相同机器时，以下可能是一个合理的配置： 12345spring.rabbitmq.dynamic=truespring.rabbitmq.port=5672spring.rabbitmq.username=guestspring.rabbitmq.password=guestspring.rabbitmq.host=localhost 5. Client Application5.1. Invoke the Remote Service我们现在来处理客户。同样，我们需要定义调用消息将被写入的队列。我们需要仔细检查客户端和服务器是否使用相同的名称。 1234@BeanQueue queue() &#123; return new Queue(\"remotingQueue\");&#125; 在客户端，我们需要比服务器端稍微复杂的设置。实际上，我们需要定义一个具有相关绑定的Exchange： 123456789@BeanExchange directExchange(Queue someQueue) &#123; DirectExchange exchange = new DirectExchange(\"remoting.exchange\"); BindingBuilder .bind(someQueue) .to(exchange) .with(\"remoting.binding\"); return exchange;&#125; 关于RabbitMQ作为交换和绑定的主要概念的一个很好的介绍可以在这里。 由于Spring Boot不自动配置AmqpTemplate，因此我们必须自己设置一个，指定一个路由密钥。在这样做时，我们需要仔细检查路由密钥和交换机是否与上一步中用于定义Exchange的交换机匹配 123456@Bean RabbitTemplate amqpTemplate(ConnectionFactory factory) &#123; RabbitTemplate template = new RabbitTemplate(factory); template.setRoutingKey(\"remoting.binding\"); template.setExchange(\"remoting.exchange\"); return template;&#125; 然后，正如我们与其他Spring Remoting实现一样，我们定义了一个FactoryBean，它将生成远程暴露的服务的本地代理。没有什么太奇怪，我们只需要提供远程服务的接口： 123456@Bean AmqpProxyFactoryBean amqpFactoryBean(AmqpTemplate amqpTemplate) &#123; AmqpProxyFactoryBean factoryBean = new AmqpProxyFactoryBean(); factoryBean.setServiceInterface(CabBookingService.class); factoryBean.setAmqpTemplate(amqpTemplate); return factoryBean;&#125; 我们现在可以使用远程服务，就像它被声明为本地bean一样： 12CabBookingService service = context.getBean(CabBookingService.class);out.println(service.bookRide(\"13 Seagate Blvd, Key Largo, FL 33037\")); 5.2. Setup同样对于客户端应用程序，我们必须正确选择application.properties文件中的值。在一个常见的设置中，那些将与服务器端使用的设置完全匹配。 5.3. Run the Example这应该足以证明通过RabbitMQ的远程调用。然后我们启动RabbitMQ，服务器应用程序和调用远程服务的客户端应用程序。 幕后发生的是AmqpProxyFactoryBean将构建一个实现CabBookingService的代理。 当在该代理上调用一个方法时，它会对RabbitMQ上的消息进行排队，在其中指定调用的所有参数和用于发回结果的队列名称。 消息从调用实际实现的AmqpInvokerServiceExporter中消耗。然后，将结果收集到消息中，并将其放在队列中，该名称在传入消息中指定。 AmqpProxyFactoryBean接收到结果，最后返回最初在服务器端生成的值。 6. Conclusion在本文中，我们看到了如何使用Spring Remoting在消息传递系统之上提供RPC。 这可能不是我们可能喜欢利用RabbitMQ的异步性的主要场景的方式，但是在某些选定和有限的情况下，同步调用可以更容易理解，并且更快更简单地开发。","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"Spring YAML Configuration","date":"2017-06-22T13:16:37.844Z","path":"2017/06/22/Spring YAML Configuration/","text":"1. Overview配置Spring应用程序的一种方法是使用YAML配置文件。 在这篇快速的文章中，我们将使用YAML为简单的Spring引导应用程序配置不同的配置文件 2. Spring YAML FileSpring配置文件可帮助Spring应用程序为不同环境定义不同的属性。 以下是一个包含两个配置文件的简单YAML文件。 分隔两个配置文件的三个虚线表示新文档的开始，因此所有配置文件都可以在同一个YAML文件中进行描述。 application.yml文件的相对路径是/myApplication/src/main/resources/application.yml。 Spring应用程序将第一个配置文件作为默认配置文件，除非在Spring应用程序中另外声明。 12345678910111213141516spring: profiles: testname: test-YAMLenvironment: testservers: - www.abc.test.com - www.xyz.test.com ---spring: profiles: prodname: prod-YAMLenvironment: productionservers: - www.abc.com - www.xyz.com 3. Binding YAML to a Config Class要从属性文件加载一组相关属性，我们将创建一个bean类： 12345678910111213@Configuration@EnableConfigurationProperties@ConfigurationPropertiespublic class YAMLConfig &#123; private String name; private String environment; private List&lt;String&gt; servers = new ArrayList&lt;&gt;(); // standard getters and setters &#125;enter code here 这里使用的注释是： @Configuration将该类定义为bean定义的源 @ConfigurationProperties将外部配置绑定并验证配置类 @EnableConfigurationProperties此注释用于在Spring应用程序中启用@ConfigurationProperties注释的bean 4. Accessing the YAML Properties要访问YAML属性，我们创建一个YAMLConfig类的对象，并使用该对象访问属性。 在属性文件中，我们将spring.active.profiles环境变量设置为prod。如果我们没有定义spring.profiles.active，它将默认为YAML文件中定义的第一个配置文件属性。 属性文件的相对路径为/myApplication/src/main/resources/application.properties。 spring.profiles.active=prod 在这个例子中，我们使用CommandLineRunner显示属性。 1234567891011121314151617@SpringBootApplicationpublic class MyApplication implements CommandLineRunner &#123; @Autowired private YAMLConfig myConfig; public static void main(String[] args) &#123; SpringApplication app = new SpringApplication(MyApplication.class); app.run(); &#125; public void run(String... args) throws Exception &#123; System.out.println(\"using environment: \" + myConfig.getEnvironment()); System.out.println(\"name: \" + myConfig.getName()); System.out.println(\"servers: \" + myConfig.getServers()); &#125;&#125; 命令行上的输出： 123using environment: productionname: prod-YAMLservers: [www.abc.com, www.xyz.com] 5. YAML Property Overriding在Spring Boot中，YAML文件可以被其他YAML属性文件覆盖，具体取决于它们的位置。 YAML属性可以由以下位置的属性文件覆盖，首先以最高优先顺序排列： Profiles’ properties placed outside the packaged jar 配置文件的属性放在打包的jar的外面 Profiles’ properties packaged inside the packaged jar 配置文件的属性放在打包的jar的里面 Application properties placed outside the packaged jar 应用程序属性放置在打包的jar的外面 Application properties packaged inside the packaged jar 应用程序属性放置在打包的jar的里面 6. Conclusion在这篇快速的文章中，我们已经了解了如何使用YAML在Spring引导应用程序中配置属性。我们也看到了Spring Boot for YAML文件的属性覆盖规则。","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"使用Spring Boot创建自定义自动配置","date":"2017-06-22T13:16:31.940Z","path":"2017/06/22/使用Spring Boot创建自定义自动配置/","text":"1. Overview简单的来说，Spring Boot autoconfiguration是基于在类路径中存在的依赖关系来自动配置一个Spring应用程序的一种方式。 这可以通过消除定义自动配置类中包含的某些bean的需要，使开发更快更容易。 在下面的部分中，我们将介绍如何创建自定义的Spring Boot自动配置。 2. Maven Dependencies我们从我们需要的依赖开始： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;version&gt;1.5.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt;&lt;/dependency&gt; 3. Creating a Custom Auto-Configuration要创建自定义自动配置，我们需要创建一个注释为@Configuration并注册的类。. 我们为MySQL数据源创建一个自定义配置： 1234@Configurationpublic class MySQLAutoconfiguration &#123; //...&#125; 下一个强制性步骤是通过在标准文件资源/ META-INF / spring.factory中的org.springframework.boot.autoconfigure.EnableAutoConfiguration项下添加类的名称来将类注册为自动配置候选项： 12org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\com.baeldung.autoconfiguration.MySQLAutoconfiguration 如果我们希望我们的自动配置类优先于其他自动配置候选，我们可以添加@AutoConfigureOrder（Ordered.HIGHEST_PRECEDENCE）注释 请注意，只有在应用程序中未定义自动配置的bean时，自动配置才有效。如果你定义你的bean，那么默认的bean将被覆盖。 3.1. Class Conditions类条件允许我们指定如果存在指定的类，使用@ConditionalOnClass注释，或者如果一个类不存在的时候使用@ConditionalOnMissingClass注释。 我们指定我们的MySQLConfiguration只有在DataSource类存在时才会加载，在这种情况下，我们可以假定应用程序将使用数据库： 12345@Configuration@ConditionalOnClass(DataSource.class)public class MySQLAutoconfiguration &#123; //...&#125; 3.2. Bean Conditions如果我们仅在指定的bean存在的情况下才包含一个bean，那么我们可以使用@ConditionalOnBean和@ConditionalOnMissingBean注释。 为了说明这一点，我们将entityManagerFactory bean添加到我们的配置类中，并指定如果存在称为dataSource的bean并且一个名为entityManagerFactory的bean还没有被定义，则创建该bean： 1234567891011121314@Bean@ConditionalOnBean(name = \"dataSource\")@ConditionalOnMissingBeanpublic LocalContainerEntityManagerFactoryBean entityManagerFactory() &#123; LocalContainerEntityManagerFactoryBean em = new LocalContainerEntityManagerFactoryBean(); em.setDataSource(dataSource()); em.setPackagesToScan(\"com.baeldung.autoconfiguration.example\"); em.setJpaVendorAdapter(new HibernateJpaVendorAdapter()); if (additionalProperties() != null) &#123; em.setJpaProperties(additionalProperties()); &#125; return em;&#125; 我们还要配置一个仅在没有定义类型为JpaTransactionManager的bean的情况下加载的transactionManager bean： 1234567@Bean@ConditionalOnMissingBean(type = \"JpaTransactionManager\")JpaTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) &#123; JpaTransactionManager transactionManager = new JpaTransactionManager(); transactionManager.setEntityManagerFactory(entityManagerFactory); return transactionManager;&#125; 3.3. Property Conditions@ConditionalOnProperty注释用于指定是否将根据Spring Environment属性的存在和值来加载配置。 首先，我们为配置添加一个属性源文件，该文件将决定从哪里读取属性： 1234@PropertySource(\"classpath:mysql.properties\")public class MySQLAutoconfiguration &#123; //...&#125; 我们可以配置主DataSource bean，该bean将用于创建与数据库的连接，只有当存在名为usemysql的属性时才会加载它。 我们可以使用hasValue属性来指定必须匹配的usemysql属性的某些值。 如果将usemysql属性设置为local，则使用默认值定义dataSource bean，该值将连接到名为myDb的本地数据库 123456789101112131415@Bean@ConditionalOnProperty( name = \"usemysql\", havingValue = \"local\")@ConditionalOnMissingBeanpublic DataSource dataSource() &#123; DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(\"com.mysql.cj.jdbc.Driver\"); dataSource.setUrl(\"jdbc:mysql://localhost:3306/myDb?createDatabaseIfNotExist=true\"); dataSource.setUsername(\"mysqluser\"); dataSource.setPassword(\"mysqlpass\"); return dataSource;&#125; 如果将usemysql属性设置为自定义，则将使用dataSource bean的自定义属性值配置：数据库URL，用户和密码 1234567891011121314151617@Bean(name = \"dataSource\")@ConditionalOnProperty( name = \"usemysql\", havingValue = \"custom\")@ConditionalOnMissingBeanpublic DataSource dataSource2() &#123; DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(\"com.mysql.cj.jdbc.Driver\"); dataSource.setUrl(env.getProperty(\"mysql.url\")); dataSource.setUsername(env.getProperty(\"mysql.user\") != null ? env.getProperty(\"mysql.user\") : \"\"); dataSource.setPassword(env.getProperty(\"mysql.pass\") != null ? env.getProperty(\"mysql.pass\") : \"\"); return dataSource;&#125; mysql.properties文件将包含usemysql属性： usemysql=local 如果使用MySQLAutoconfiguration的应用程序希望覆盖默认属性，则需要做的就是为mysql.url，mysql.user和mysql.pass属性以及mysql.properties文件中的usemysql = custom 添加不同的值。 3.4. Resource Conditions添加@ConditionalOnResource注释意味着只有当指定的资源存在时才会加载配置。 让我们定义一个名为additionalProperties（）的方法，该方法将返回一个包含特定于Hibernate的属性的Properties对象，以供entityManagerFactory bean使用，只有当资源文件mysql.properties存在时： 123456789101112131415@ConditionalOnResource( resources = \"classpath:mysql.properties\")@Conditional(HibernateCondition.class)Properties additionalProperties() &#123; Properties hibernateProperties = new Properties(); hibernateProperties.setProperty(\"hibernate.hbm2ddl.auto\", env.getProperty(\"mysql-hibernate.hbm2ddl.auto\")); hibernateProperties.setProperty(\"hibernate.dialect\", env.getProperty(\"mysql-hibernate.dialect\")); hibernateProperties.setProperty(\"hibernate.show_sql\", env.getProperty(\"mysql-hibernate.show_sql\") != null ? env.getProperty(\"mysql-hibernate.show_sql\") : \"false\"); return hibernateProperties; &#125; 我们可以将Hibernate的特定属性添加到mysql.properties文件中： 123mysql-hibernate.dialect=org.hibernate.dialect.MySQLDialectmysql-hibernate.show_sql=truemysql-hibernate.hbm2ddl.auto=create-drop 3.5. Custom Conditions如果我们不想使用Spring Boot中可用的任何条件，我们还可以通过扩展Sp​​ringBootCondition类并覆盖getMatchOutcome（）metho来定义自定义条件 我们为我们的additionalProperties（）方法创建一个名为HibernateCondition的条件，该方法将验证类路径中是否存在HibernateEntityManager类： 1234567891011121314151617181920212223static class HibernateCondition extends SpringBootCondition &#123; private static String[] CLASS_NAMES = &#123; \"org.hibernate.ejb.HibernateEntityManager\", \"org.hibernate.jpa.HibernateEntityManager\" &#125;; @Override public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; ConditionMessage.Builder message = ConditionMessage.forCondition(\"Hibernate\"); return Arrays.stream(CLASS_NAMES) .filter(className -&gt; ClassUtils.isPresent(className, context.getClassLoader())) .map(className -&gt; ConditionOutcome .match(message.found(\"class\") .items(Style.NORMAL, className))) .findAny() .orElseGet(() -&gt; ConditionOutcome .noMatch(message.didNotFind(\"class\", \"classes\") .items(Style.NORMAL, Arrays.asList(CLASS_NAMES)))); &#125;&#125; 然后我们可以将这个条件添加到additionalProperties（）方法中： 1234@Conditional(HibernateCondition.class)Properties additionalProperties() &#123; //...&#125; 3.6. Application Conditions我们还可以通过添加@ConditionalOnWebApplication或@ConditionalOnNotWebApplication注释来指定配置只能在Web上下文中加载。 4. Testing the Auto-Configuration让我们创建一个非常简单的例子来测试我们的自动配置。我们将创建一个名为MyUser的实体类，使用Spring Data创建一个MyUserRepository接口： 1234567@Entitypublic class MyUser &#123; @Id private String email; // standard constructor, getters, setters&#125; 12public interface MyUserRepository extends JpaRepository&lt;MyUser, String&gt; &#123; &#125; 要启用自动配置，我们可以使用@SpringBootApplication或@EnableAutoConfiguration注释之一： 123456@SpringBootApplicationpublic class AutoconfigurationApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(AutoconfigurationApplication.class, args); &#125;&#125; 接下来，让我们写一个JUnit测试可以保存MYUSER实体： 12345678910111213141516@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest( classes = AutoconfigurationApplication.class)@EnableJpaRepositories( basePackages = &#123; \"com.baeldung.autoconfiguration.example\" &#125;)public class AutoconfigurationTest &#123; @Autowired private MyUserRepository userRepository; @Test public void whenSaveUser_thenOk() &#123; MyUser user = new MyUser(\"user@email.com\"); userRepository.save(user); &#125;&#125; 由于我们尚未定义DataSource配置，因此应用程序将使用我们创建的自动配置来连接到名为myDb的MySQL数据库。 连接字符串包含createDatabaseIfNotExist = true属性，因此数据库不需要存在。但是，用户mysqluser或通过mysql.user属性指定的用户，如果存在，则需要创建。 我们可以检查应用程序日志以查看正在使用的MySQL数据源： web - 2017-04-12 00:01:33,956 [main] INFO o.s.j.d.DriverManagerDataSource - Loaded JDBC driver: com.mysql.cj.jdbc.Driver 5. Disabling Auto-Configuration Classes如果我们想排除自动配置加载，我们可以将@EnableAutoConfiguration注释与exclude或excludeName属性添加到配置类中： 123456@Configuration@EnableAutoConfiguration( exclude=&#123;MySQLAutoconfiguration.class&#125;)public class AutoconfigurationApplication &#123; //...&#125; 禁用特定自动配置的另一个选项是设置spring.autoconfigure.exclude属性： spring.autoconfigure.exclude=com.baeldung.autoconfiguration.MySQLAutoconfiguration 6. Conclusions在本教程中，我们展示了如何创建自定义的Spring Boot自动配置。该示例的完整源代码可以在GitHub上找到。 可以使用自动配置配置文件运行JUnit测试：mvn clean install -Pautoconfiguration。","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"Implementing a Custom Spring AOP Annotation","date":"2017-06-18T14:55:13.900Z","path":"2017/06/18/Implementing a Custom Spring AOP Annotation/","text":"1. Introduction在本文中，我们将使用Spring中的AOP支持来实现自定义AOP注释。 首先，我们将对AOP进行高级概述，说明它是什么以及它的优点。接下来，我们将逐步实施注释，逐步建立对AOP概念的更深入的了解。 结果将是对AOP的更好理解和将来创建我们的定制Spring注释的能力。 2. What is an AOP Annotation?要快速总结，AOP代表面向方面的编程。基本上，它是一种在不修改该代码的情况下向现有代码添加行为的方式。 有关AOP的详细介绍，有关于AOP切入点和建议的文章。本文假设我们已经有了基础知识 我们将在本文中实现的AOP的类型是注释驱动的。如果我们使用了Spring @Transactional注释，我们可能已经熟悉了这一点： 1234@Transactionalpublic void orderGoods(Order order) &#123; // A series of database calls to be performed in a transaction&#125; 这里的关键是非侵略性。通过使用注解元数据，我们的核心业务逻辑不会被我们的交易代码污染。这使得更容易理解，重构和隔离测试。 有时，开发Spring应用程序的人可以将其看作是“弹性魔法”，而不必考虑如何运作。在现实中，发生的事情并不是特别复杂。但是，一旦我们完成了本文中的步骤，我们将能够创建自己的自定义注释，以了解和利用AOP。 3. Maven Dependency首先，我们添加我们的Maven依赖关系。 对于这个例子，我们将使用Spring Boot，因为它的配置方法的惯例让我们尽可能快地起床和运行： 123456789101112&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.2.RELEASE&lt;/version&gt;&lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 请注意，我们已经包括了AOP启动器，它引入了我们开始实现方面所需的库。 4. Creating our Custom Annotation我们要创建的注释是用于记录执行方法所需的时间量的注释。我们创建我们的注释： 12345@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface LogExecutionTime &#123; &#125; 虽然相对简单的实现，值得注意的是使用两个元注释。 @Target注释告诉我们我们的注释将适用于何处。在这里我们使用ElementType.Method，这意味着它只适用于方法。如果我们试图在其他地方使用注释，那么我们的代码将无法编译。这种行为是有道理的，因为我们的注释将用于记录方法执行时间。 而@Retention只是说明注释是否在运行时可用于JVM。默认情况下不是这样，所以Spring AOP将无法看到注释。这就是为什么它被重新配置。 5. Creating our Aspect现在我们有了我们的注释，我们来创建我们的方面。这只是封装我们交叉关切的模块，我们的方法是执行时间记录。它是一个类，用@Aspect注释： 12345@Aspect@Componentpublic class ExampleAspect &#123; &#125; 6. Creating our Pointcut and Advice现在，我们来创建我们的切入点和建议。这将是一个注释的方法，它存在于我们的方面： 1234@Around(\"@annotation(LogExecutionTime)\")public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable &#123; return joinPoint.proceed();&#125; 从技术上讲，这并没有改变任何事情的行为，但仍然有很多需求分析。 首先，我们用@Around注释了我们的方法。这是我们的建议，围绕建议意味着我们在方法执行之前和之后添加额外的代码。还有其他类型的建议，例如前后，但这些建议将被排除在本文的范围之外。 接下来，我们的@Around注释有一个切点参数。我们的切入点只是说，’应用这个建议任何方法用@LogExecutionTime注释’。还有很多其他类型的切入点，但是如果范围，它们将再次被忽略。 方法logExecutionTime（）本身就是我们的建议。有一个参数，即ProceedingJoinPoint。在我们的例子中，这将是一个已经用@LogExecutionTime注释的执行方法。 最后，当我们的注释方法最终被调用时，会发生什么，我们的建议将被首先调用。那么由我们的建议决定下一步做什么。在我们的例子中，我们的建议是除了调用proceed（）之外什么也没做，只是调用原来的注释方法。 7. Logging our Execution Time现在我们有了我们的骨架，我们需要做的就是为我们的建议添加一些额外的逻辑。除了调用原始方法之外，这将记录执行时间。让我们再补充一点： 1234567891011@Around(\"@annotation(LogExecutionTime)\")public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable &#123; long start = System.currentTimeMillis(); Object proceed = joinPoint.proceed(); long executionTime = System.currentTimeMillis() - start; System.out.println(joinPoint.getSignature() + \" executed in \" + executionTime + \"ms\"); return proceed;&#125; 再次，我们没有做任何在这里特别复杂的事情。我们刚刚记录了当前的时间，执行了该方法，然后打印出控制台所需的时间。我们还记录了使用连接点实例提供的方法签名。如果我们想要，我们也可以访问其他信息位，例如方法参数。 现在，让我们尝试用@LogExecutionTime注释一个方法，然后执行它来看看会发生什么。请注意，这必须是一个Spring Bean才能正常工作： 1234@LogExecutionTimepublic void serve() throws InterruptedException &#123; Thread.sleep(2000);&#125; 执行后，我们应该看到以下记录到控制台： void org.baeldung.Service.serve() executed in 2030ms 8. Conclusion在本文中，我们利用Spring Boot AOP创建自定义注释，我们可以将其应用于Spring bean，以便在运行时向其注入额外的行为。","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"Intro to AspectJ","date":"2017-06-18T14:49:42.156Z","path":"2017/06/18/Intro to AspectJ/","text":"1. Introduction本文是对AspectJ的一个快速实用的介绍。 首先，我们将展示如何启用面向方面的编程，然后我们将重点介绍编译时，后期编译和加载时织入之间的区别。 我们首先简要介绍面向方面的编程（AOP）和AspectJ的基础知识。 2. OverviewAOP是一种编程范式，旨在通过允许分离交叉关切来增加模块化。它通过在现有代码中添加附加行为，而不会修改代码本身。相反，我们单独声明要修改哪个代码。 AspectJ使用Java编程语言的扩展来实现关注和织入横切问题。 3. Maven DependenciesAspectJ根据其使用情况提供不同的库。我们可以在Maven Central存储库中的org.aspectj组下找到Maven依赖项。 在本文中，我们关注使用编译时，后期编译和织入加载时间创建方面所需的依赖关系。 3.1. AspectJ Runtime运行AspectJ程序时，类路径应包含与AspectJ运行时库aspectjrt.jar一起的类和方面： 12345&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.8.9&lt;/version&gt;&lt;/dependency&gt; 3.2. AspectJWeaver除了AspectJ运行时依赖之外，我们还需要包含aspectjweaver.jar来在加载时向Java类介绍建议： 12345&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.9&lt;/version&gt;&lt;/dependency&gt; 4. Aspect CreationAspectJ提供了AOP的实现，并有三个核心概念： Join Point Pointcut Advice 我们将通过创建一个简单的程序来验证用户帐户余额来演示这些概念。 首先，我们创建一个具有给定余额的帐户类和一种撤销方法： 1234567891011public class Account &#123; int balance = 20; public boolean withdraw(int amount) &#123; if (balance &lt; amount) &#123; return false; &#125; balance = balance - amount; return true; &#125;&#125; 我们将创建一个AccountAspect.aj文件来记录帐户信息并验证帐户余额（请注意，AspectJ文件以“.aj”文件扩展名结尾）：","tags":[{"name":"spring,aop","slug":"spring-aop","permalink":"http://yoursite.com/tags/spring-aop/"}]},{"title":"Spring BeanCreationException","date":"2017-06-13T06:35:17.661Z","path":"2017/06/13/Spring BeanCreationException/","text":"Spring BeanCreationException1.概述在这片文章中，我们会讨论关于Spring的异常： Spring org.springframework.beans.factory.BeanCreationException 当BeanFactory创建定义的bean的时候，本文中将会讨论这种常见的异常，以及它们解决方案。 2.Cause: org.springframework.beans.factory.NoSuchBeanDefinitionExceptionBeanCreationException最常见的原因是Spring试图注入上下文中不存在的bean。 例如，BeanA尝试注入BeanB： 1234567@Componentpublic class BeanA &#123; @Autowired private BeanB dependency; ...&#125; 如果在上下文中找不到BeanB，则会抛出以下异常（创建Bean时出错）： 1234567Error creating bean with name 'beanA': Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: private org.baeldung.web.BeanB org.baeldung.web.BeanA.dependency; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [org.baeldung.web.BeanB] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: &#123;@org.springframework.beans.factory.annotation.Autowired(required=true)&#125; 要诊断这种类型的问题 - 首先，确保bean被声明： 在使用&lt;bean /&gt;元素的XML配置文件中 或通过@Bean注解在Java @Configuration类中 或者注解为：@Component，@Repository，@Service，@Controller和类路径扫描对于该包是active的 还要检查配置文件或类真正正确的由Spring获取到并加载到主上下文中。 3.Cause:org.springframework.beans.factory.NoUniqueBeanDefinitionExceptionbean创建异常的另一个类似原因是Spring试图通过类型（即其接口）注入一个bean，并在上下文中找到两个或更多个bean来实现该接口。 例如，BeanB1和BeanB2都实现了相同的接口： 123456789101112@Componentpublic class BeanB1 implements IBeanB &#123; ... &#125;@Componentpublic class BeanB2 implements IBeanB &#123; ... &#125; @Componentpublic class BeanA &#123; @Autowired private IBeanB dependency; ...&#125; 这将导致Spring bean工厂抛出以下异常： 123456Error creating bean with name 'beanA': Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: private org.baeldung.web.IBeanB org.baeldung.web.BeanA.b; nested exception is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type [org.baeldung.web.IBeanB] is defined: expected single matching bean but found 2: beanB1,beanB2 4. Cause: org.springframework.beans.BeanInstantiationException4.1 自定义异常123456789@Componentpublic class BeanA &#123; public BeanA() &#123; super(); throw new NullPointerException(); &#125; ...&#125; 如预期的那样，这将导致Spring很快的失败，并且抛出异常： 12345Error creating bean with name 'beanA' defined in file [...BeanA.class]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Could not instantiate bean class [org.baeldung.web.BeanA]: Constructor threw exception; nested exception is java.lang.NullPointerException 4.2 java.lang.InstantiationExceptionBeanInstantiationException的另一个可能的发生是将抽象类定义为XML中的bean;这必须在XML中，因为在Java @Configuration文件中没有办法这样做，而类路径扫描将忽略抽象类： 12@Componentpublic abstract class BeanA implements IBeanA &#123; ... &#125; bean的XML定义： 1&lt;bean id=\"beanA\" class=\"org.baeldung.web.BeanA\" /&gt; 此设置将导致类似异常： 1234567org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'beanA' defined in class path resource [beansInXml.xml]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Could not instantiate bean class [org.baeldung.web.BeanA]: Is it an abstract class?; nested exception is java.lang.InstantiationException 4.3. java.lang.NoSuchMethodException如果一个bean没有默认构造函数，并且Spring尝试通过查找该构造函数实例化它，这将导致运行时异常;例如： 12345678@Componentpublic class BeanA implements IBeanA &#123; public BeanA(final String name) &#123; super(); System.out.println(name); &#125;&#125; 当这个bean被类路径扫描机制获取时，将会导致： 12345Error creating bean with name 'beanA' defined in file [...BeanA.class]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Could not instantiate bean class [org.baeldung.web.BeanA]: No default constructor found; nested exception is java.lang.NoSuchMethodException: org.baeldung.web.BeanA.&lt;init&gt;() 当类中的Spring依赖关系不具有相同的版本时，可能会出现类似异常但是更难诊断的异常是由于API更改，此类版本不兼容可能会导致NoSuchMethodException异常。解决这个问题的方法是确保所有的Spring库在项目中都有完全相同的版本。 6.org.springframework.beans.NotWritablePropertyException另一个可能性是定义一个bean - BeanA - 引用另一个Bean - BeanB–在BeanA中没有相应的setter方法： 1234567@Componentpublic class BeanA &#123; private IBeanB dependency; ...&#125;@Componentpublic class BeanB implements IBeanB &#123; ... &#125; Spring XML配置： 123&lt;bean id=\"beanA\" class=\"org.baeldung.web.BeanA\"&gt; &lt;property name=\"beanB\" ref=\"beanB\" /&gt;&lt;/bean&gt; 再次，这只能发生在XML配置中，因为在使用Java @Configuration时，编译器会使此问题无法再现。 当然，为了解决这个问题，需要为IBeanB添加setter： 12345678@Componentpublic class BeanA &#123; private IBeanB dependency; public void setDependency(final IBeanB dependency) &#123; this.dependency = dependency; &#125;&#125; 6.org.springframework.beans.CannotLoadBeanClassException当Spring无法加载定义的bean的类时，抛出此异常 - 如果Spring XML配置包含一个根本没有相应类的bean，则可能会发生此异常。例如，如果类BeanZ不存在，以下定义将导致异常： 1&lt;bean id=\"beanZ\" class=\"org.baeldung.web.BeanZ\" /&gt; 根本原因是ClassNotFoundException这种异常： 123456nested exception is org.springframework.beans.factory.BeanCreationException: ...nested exception is org.springframework.beans.factory.CannotLoadBeanClassException: Cannot find class [org.baeldung.web.BeanZ] for bean with name 'beanZ'defined in class path resource [beansInXml.xml]; nested exception is java.lang.ClassNotFoundException: org.baeldung.web.BeanZ 7.org.springframework.beans.Children of BeanCreationException7.1. The org.springframework.beans.factory.BeanCurrentlyInCreationExceptionBeanCreationException的子类之一是BeanCurrentlyInCreationException;这通常在使用构造函数注入时出现 - 例如，在循环依赖性的情况下： 1234567891011121314151617181920@Componentpublic class BeanA implements IBeanA &#123; private IBeanB beanB; @Autowired public BeanA(final IBeanB beanB) &#123; super(); this.beanB = beanB; &#125;&#125;@Componentpublic class BeanB implements IBeanB &#123; final IBeanA beanA; @Autowired public BeanB(final IBeanA beanA) &#123; super(); this.beanA = beanA; &#125;&#125; Spring将无法解决这种情况，最终的结果将是： 123org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'beanA': Requested bean is currently in creation: Is there an unresolvable circular reference? 完整的异常是非常冗长的： 1234567891011121314151617181920212223org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'beanA' defined in file [...BeanA.class]: Unsatisfied dependency expressed through constructor argument with index 0 of type [org.baeldung.web.IBeanB]: : Error creating bean with name 'beanB' defined in file [...BeanB.class]: Unsatisfied dependency expressed through constructor argument with index 0 of type [org.baeldung.web.IBeanA]: : Error creating bean with name 'beanA': Requested bean is currently in creation: Is there an unresolvable circular reference?; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'beanA': Requested bean is currently in creation: Is there an unresolvable circular reference?; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'beanB' defined in file [...BeanB.class]: Unsatisfied dependency expressed through constructor argument with index 0 of type [org.baeldung.web.IBeanA]: : Error creating bean with name 'beanA': Requested bean is currently in creation: Is there an unresolvable circular reference?; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'beanA': Requested bean is currently in creation: Is there an unresolvable circular reference? 7.2. The org.springframework.beans.factory.BeanIsAbstractException当Bean Factory尝试检索和实例化被声明为抽象的bean时，可能会发生此实例化异常。例如： 123public abstract class BeanA implements IBeanA &#123; ...&#125; 在XML配置中声明为： 1&lt;bean id=\"beanA\" abstract=\"true\" class=\"org.baeldung.web.BeanA\" /&gt; 现在，如果我们尝试通过名称从Spring上下文中检索BeanA，例如实例化另一个bean： 1234567891011@Configurationpublic class Config &#123; @Autowired BeanFactory beanFactory; @Bean public BeanB beanB() &#123; beanFactory.getBean(\"beanA\"); return new BeanB(); &#125;&#125; 这将导致以下异常： 12345678org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'beanB' defined in class path resource [org/baeldung/spring/config/WebConfig.class]: Instantiation of bean failed; nested exception is org.springframework.beans.factory.BeanDefinitionStoreException: Factory method [public org.baeldung.web.BeanB org.baeldung.spring.config.WebConfig.beanB()] threw exception; nested exception is org.springframework.beans.factory.BeanIsAbstractException: Error creating bean with name 'beanA': Bean definition is abstract 8.总结 …在本文末尾，我们应该有一个清晰的地图来浏览可能导致Spring中的BeanCreationException异常的原因和问题，以及如何解决所有这些问题。 在Github项目中可以找到一些这些例外示例的实现这是一个基于Eclipse的项目，所以应该很容易导入和运行。","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"初探RxJS","date":"2017-05-26T08:31:47.113Z","path":"2017/05/26/初探RxJS/","text":"什么是RxJsRxJS是一个JavaScript库，将“反应式编程”的概念带入网络。 反应式编程只是构建软件应用程序的另一种方法。本质上，您的软件是为了对发生的变化进行“反应”（例如点击事件，获取的数据等），而不是典型的编写我们明确编写代码（也称为“命令式”编程）的软件来处理这些更改。对于熟悉的人，您可以将RxJS视为异步数据操作的lodash。 如果你仍然感到困惑，别担心，这通常没有什么意义。让我们用类比来更好地解释一下： 1RxJS is to Javascript as Henry Ford's assembly line was to cars. RxJS是为了像亨利·福特的装配线一样用于汽车。 我知道这听起来很棒，但是听到我的声音。 早在二十世纪初，产品完全由手工制造。所以任何产生的产品 - 让我们以座椅为例 - 是由一个人建造的。要做椅子，这个人会把木头切成适当的尺寸。然后，他们将这些块拼合在一起，将粗糙的边缘砂磨。然后他们会画它，完成它，最后卖掉它。然后他们将重复从步骤1的过程。 这可能听起来不是那么糟糕，但是考虑一下：定制颜色的椅子会花多少钱？你会认为这不会太多，对吧？实际上是相反的 - 不仅你会为自己的颜色付钱，而且你必须付钱给那个人整天坐下来，为你创造一个全新的椅子。所以你在宜家买的20美元的椅子可能会花费200美元以上。 为什么？因为这是不被分解成模块化和异步进程的系统的成本。 当亨利·福特（Henry Ford）批量生产第一辆燃烧车的时候，他有一个辉煌的想法：如果你将装配过程分解成由单人负责的模块化件？这样，大会的每一部分都是可以互换的，也消除了一个人负责创造整个汽车的巨大的低效率。事实上，一个人在一个12小时内搭建了一辆满车，他的装配线减少了两个半小时。 这也打开了通常成本高昂的定制和配置级别。例如，如果客户想要汽车的不同颜色的内部，那么他们可以简单地将完成的灯箱重定向到不同的工作人员。 装配线提供了两个主要优点：工人能够异步工作（导致完成所需的总工作时间大大减少），现在重新配置/定制最终产品将是非常便宜的。 1In this sense, RxJS (and reactive programming in general) can be thought of as writing assembly lines in your software applications. It allows you to write software that is reusable, configurable, and asynchronous. 在这个意义上，RxJS（一般说响应式编程）可以被认为是在您的软件应用程序中编写装配线。它允许您编写可重复使用，可配置和异步的软件。 我认为这里的关键词是异步的。大多数库/框架已经允许您编写可重用且可配置的代码，但可以从异步操作中轻松调用？例如，如果我们正在等待聊天消息从网络套接字回来，新聊天消息如何更新正在运行的应用程序的状态？如果你已经建立了一个有意义的大型实时应用程序，那么你知道写这种逻辑可能是多么痛苦。 虽然websockets和其他实时事件是RxJS真正闪耀的地方，但RxJS还提供了更强大的功能来执行甚至标准的AJAX请求。与promises（解决AJAX请求的正常方法）不同，RxJS的Observable序列是可以取消的。它们也可以轻松链接，操纵和配置。 1The possibilities are endless. You can create assembly lines (i.e. RxJS Observables) that can be chained together, split apart, configured slightly different, or just used without any modification at all. It's really up to you. 可能性是无止境的。您可以创建可以链接在一起，拆分，配置稍微不同或刚刚使用而不进行任何修改的装配线（即RxJS Observables）。这真的取决于你 就这样说，现在我们来探讨一些真正的RxJS和Observables的例子！ 重要的是覆盖RxJS包含的基本术语及其相应的功能，然后再继续实例。在上面的视频中，我们介绍了marble diagrams的可观察序列的总体思路，以及以下主题与之相互作用。 Observer 您通常不会直接与Observer对象进行交互，因为您可能会与主题进行交互（我们将在下面介绍），但重要的是要知道它的作用。 观察者允许您将新数据“推”到可观察的序列中。您可以将其视为修改可观察序列的“只写”方式（要回到我们类似的装配线，观察者只能将新车添加到装配线上）。 Observable 一个可观察的是我们可以用来听，又名订阅，也就是发现一个观察者发出的新的变化。将其视为“只读”装配线（只能观察新车从装配线中脱落）。 Subject 主题只是一个观察者和可观察者。您可以推新值并订阅。将其视为“读写”装配线（您可以将车辆添加到装配线上，观察从装配线下车的车辆）。 Operators RxJS中的运算符的目的与其他编程语言/库中的大多数运算符相同：它们允许您对代码执行操作。 在RxJS中，您可以将运算符视为在发送到Observable之前操纵来自主题（或观察者）的数据的一种方法。这相当于指示装配线以某种方式修改汽车（即涂漆黑色，闪耀等），然后将其返回到下一个装配线。 在RxJS中有一些不同类型的主题，但是在构建真实世界应用程序时弹出的最常见的主题是BehaviorSubject。 假设我们想要存储用户的名字，但是我们也希望他们能够更改它。我们想要存储一个初始名称，有能力更新它，并且还可以在任何给定的时间访问当前的名称设置。 这正是BehaviorSubject允许你做的事情。让我们看看这个例子的用例实际上是如何工作的： 使用初始值实例化一个新的BehaviorSubject 在这个例子中，初始值将是一个字符串（Eric） 1let currentNameSubject = new BehaviorSubject('Eric'); 要获取当前值，请调用getValue方法： 12currentNameSubject.getValue();// =&gt; 'Eric' 要更改现有BehaviorSubject的值，请使用新值调用下一个方法： 1currentNameSubject.next('Obama'); 如果我们再次调用getValue： 12currentNameSubject.getValue();// =&gt; 'Obama' 订阅值的变动使用RxJS的全部要点是跨应用程序异步更新和共享数据。这是通过订阅Observable而不是同步调用getValue完成的： 123456789101112let currentNameSubject = new BehaviorSubject('Eric');currentNameSubject.subscribe((val) =&gt; &#123; console.log(val);&#125;)// =&gt; 'Eric'currentNameSubject.next('Obama');// =&gt; 'Obama'currentNameSubject.next('Jacob');// =&gt; 'Jacob' 在RxJS世界中，被认为是最佳实践，仅将Subjects暴露给您的应用程序的部分，将新数据添加到Observable序列中。这只是允许对您的应用程序，私人和公共类成员等的某些部分进行写入访问的相同想法。 要从主题创建一个Observable，您可以在任何主题上简单地调用asObservable： 12let currentUserSubject = new BehaviorSubject&lt;string&gt;('Eric');let currentUser = currentUserSubject.asObservable(); 我们现在有一个名为currentUser的新变量，它是currentUserSubject的可观察序列的可观察值。要看看它是如何工作的，可以订阅currentUser observable，然后将一些数据添加到currentUserSubject： 12345678910let currentUserSubject = new BehaviorSubject&lt;string&gt;('Eric');let currentUser = currentUserSubject.asObservable();currentUserSubject.subscribe((val) =&gt; &#123; console.log(val)&#125;)// =&gt; 'Eric'currentUserSubject.next('hello');// =&gt; 'hello' 请注意，如果您尝试调用currentUser.next（），它将抛出一个错误，因为Observables只能观察序列 - 从而为您提供只读访问currentUserSubject Making our first HTTP request向API发出请求，使用observable来映射和返回数据 就像Angular 1.x一样，建议Http调用包含在服务中，而不是直接在组件中使用。这可以为您的应用程序结构提供更大的灵活性，因为您可以在整个应用程序中重用您的呼叫，以及实现更高级功能（如缓存）的能力。 要使用Http服务，我们需要（你猜到它）import＆并注入它： 12345678910111213141516import &#123; Injectable &#125; from '@angular/core';import &#123; Http, Response &#125; from '@angular/http';import 'rxjs/add/operator/map';@Injectable()export class UserService &#123; constructor ( private http: Http ) &#123;&#125; getUser() &#123; return this.http.get(`https://conduit.productionready.io/api/profiles/eric`) .map((res:Response) =&gt; res.json()); &#125;&#125; 我们需要从rxjs导入map才能使用地图运算符。 $ http从Angular 1.x和Http在Angular 2之间有一些区别。Http返回一个Observable与Response对象，而$ http返回Promises。 Promises和Observables之间的主要区别在于Observables可能会多次发布数据，这就是为什么它们可以被订阅和取消订阅。 $ http和Http之间的另一个主要区别是Http实际上没有向服务器发出请求，直到有一个订阅observable。 虽然可观察是在angular2处理数据的推荐方法，您可以通过导入rxjs / add / operator / toPromise然后调用您的observable的Promise（）将它们转换为promises。起初我发现自己想要使用像Angular 1的好日子这样的承诺，但是我最终发现Observables实际上是相当不错的，与你写承诺代码的方式没有太大的不同。 getUser方法从服务器上关闭对我的配置文件信息的GET请求。当数据回来时，我们使用map操作符来获取响应数据，将其转换为JSON，然后将其重新输入到等待数据解析的任何订阅者。 在home组件中，允许订阅该Observable并将返回给组件中的profile变量的数据分配： 123456789101112131415161718192021import &#123; Component &#125; from '@angular/core';import &#123; UserService &#125; from './shared/index';@Component(&#123; selector: 'home-page', template: ` &lt;div&gt; &lt;button (click)=\"loadUser()\"&gt;Load profile&lt;/button&gt; &#123;&#123; profile | json &#125;&#125; &lt;/div&gt; `&#125;)export class HomeComponent &#123; constructor(private userService: UserService) &#123;&#125; profile = &#123;&#125;; loadUser() &#123; this.userService.getUser().subscribe(data =&gt; this.profile = data); &#125;&#125;","tags":[{"name":"Rxjs","slug":"Rxjs","permalink":"http://yoursite.com/tags/Rxjs/"}]},{"title":"陌生单词笔记本","date":"2017-05-23T03:09:38.984Z","path":"2017/05/23/陌生单词笔记本/","text":"Robust 强大的 definitive 确定的 security landscape（风景，风景，山水） 安全形势 two-factor authentication 双因素认证 solid 坚实 alternative 可以供选择的 debate 争论 intelligently 智能的 properly 正确的 tactics 策略、 fluent 连贯 endpoint 端点 enforce 实施 强制 执行 encapsulate 封装 interchangeable 可交换的 Strategy 策略 vary 变化 DelegatingFilterProxy 委托过滤代理 hierarchies 阶层; 层次; 层次结构 outlines 概述 application 应用程式 应用、应用程序application framework 应用程式框架、应用框架 应用程序框架architecture 架构、系统架构 体系结构argument 参数（传给函式的值）。array 阵列 数组arrow operator arrow（箭头）运算子 箭头操作符assembly 装配件assembly language 组合语言 汇编语言assert(ion) 断言assign 指派、指定、设值、赋值 赋值assignment 指派、指定 赋值、分配assignment operator 指派（赋值）运算子 = 赋值操作符associated 相应的、相关的 相关的、关联、相应的associative container 关联式容器（对应 sequential container）关联式容器atomic 不可分割的 原子的attribute 属性 属性、特性audio 音讯 音频A.I. 人工智慧 人工智能 background 背景 背景（用於图形着色）後台（用於行程）backward compatible 回溯相容 向下兼容bandwidth 频宽 带宽base class 基础类别 基类base type 基础型别 (等同於base class) batch 批次（意思是整批作业） 批处理benefit 利益 收益best viable function 最佳可行函式 最佳可行函式binary search 二分搜寻法 二分查找binary tree 二元树 二叉树binary function 二元函式 双叁函数binary operator 二元运算子 二元操作符binding 系结 绑定bit 位元 位bit field 位元栏 位域bitmap 位元图 位图bitwise 以 bit 为单元逐一bitwise copy 以 bit 为单元进行复制；位元逐一复制 位拷贝block 区块,区段 块、区块、语句块boolean 布林值（真假值，true 或 false）布尔值border 边框、框线 边框brace(curly brace) 大括弧、大括号 花括弧、花括号bracket(square brakcet) 中括弧、中括号 方括弧、方括号breakpoint 中断点 断点build 建造、构筑、建置（MS 用语）build－in 内建 内置bus 汇流排 总线business 商务,业务 业务buttons 按钮 按钮byte 位元组（由 8 bits 组成） 字节 cache 快取 高速缓存call 呼叫、叫用 调用callback 回呼 回调call operator call（函式呼叫）运算子调用操作符candidate function 候选函式 候选函数chain 串链（例 chain of function calls） 链character 字元 字符check box 核取方块 (i.e. check button) 复选框checked exception 可控式异常check button 方钮 (i.e. check box) 复选按钮child class 子类别（或称为derived class, subtype） 子类class 类别 类class body 类别本体 类体class declaration 类别宣告、类别宣告式 类声明class definition 类别定义、类别定义式 类定义class derivation list 类别衍化列 类继承列表class head 类别表头 类头class hierarchy 类别继承体系, 类别阶层 类层次体系class library 类别程式库、类别库 类库class template 类别模板、类别范本 类模板class template partial specializations 类别模板偏特化 类模板部分特化class template specializations 类别模板特化 类模板特化cleanup 清理、善後 清理、清除client 客端、客户端、客户 客户client－server 主从架构 客户/服务器clipboard 剪贴簿 剪贴板clone 复制 克隆collection 群集 集合combo box 复合方块、复合框 组合框command line 命令列 命令行(系统文字模式下的整行执行命令)communication 通讯 通讯compatible 相容 兼容compile time 编译期 编译期、编译时compiler 编译器 编译器component 组件 组件composition 复合、合成、组合 组合computer 电脑、计算机 计算机、电脑concept 概念 概念concrete 具象的 实在的concurrent 并行 并发configuration 组态 配置connection 连接，连线（网络,资料库） 连接constraint 约束（条件）construct 构件 构件container 容器 容器(存放资料的某种结构如 list, vector…）containment 内含 包容context 背景关系、周遭环境、上下脉络 环境、上下文control 控制元件、控件 控件console 主控台 控制台const常数（constant 的缩写，C++ 关键字）constant 常数（相对於 variable） 常量constructor（ctor） 建构式 构造函数（与class 同名的一种 member functions）copy (v) 复制、拷贝 拷贝copy (n) 复件, 副本cover 涵盖 覆盖create 创建、建立、产生、生成 创建creation 产生、生成 创建cursor 游标 光标custom 订制、自定 定制 data 资料 数据database 资料库 数据库database schema 数据库结构纲目data member 资料成员、成员变数 数据成员、成员变量data structure 资料结构 数据结构datagram 资料元 数据报文dead lock 死结 死锁debug 除错 调试debugger 除错器 调试器declaration 宣告、宣告式 声明deduction 推导（例：template argument deduction） 推导、推断default 预设 缺省、默认defer 延缓 推迟define 定义 预定义definition 定义、定义区、定义式 定义delegate 委派、委托、代理delegation （同上）demarshal 反编列 散集dereference 提领（取出指标所指物体的内容） 解叁考dereference operator dereference（提领）运算子 * 解叁考操作符derived class 衍生类别 派生类design by contract 契约式设计design pattern 设计范式、设计样式 设计模式destroy 摧毁、销毁destructor 解构式 析构函数device 装置、设备 设备dialog 对话窗、对话盒 对话框directive 指令（例：using directive） (编译)指示符directory 目录 目录disk 碟 盘dispatch 分派 分派distributed computing 分布式计算 (分布式电算) 分布式计算 分散式计算 (分散式电算)document 文件 文档dot operator dot（句点）运算子 . (圆)点操作符driver 驱动程式 驱动（程序）dynamic binding 动态系结 动态绑定 efficiency 效率 效率efficient 高效 高效end user 终端用户entity 物体 实体、物体encapsulation 封装 封装enclosing class外围类别（与巢状类别 nested class 有关）外围类enum (enumeration) 列举（一种 C++ 资料型别） 枚举enumerators 列举元（enum 型别中的成员） 枚举成员、枚举器equal 相等 相等equality 相等性 相等性equality operator equality（等号）运算子 == 等号操作符equivalence 等价性、等同性、对等性 等价性equivalent 等价、等同、对等 等价escape code 转义码 转义码evaluate 评估、求值、核定 评估event 事件 事件event driven 事件驱动的 事件驱动的exception 异常情况 异常exception declaration 异常宣告（ref. C++ Primer 3/e, 11.3）异常声明exception handling 异常处理、异常处理机制 异常处理、异常处理机制exception specification 异常规格（ref. C++ Primer 3/e, 11.4）异常规范exit 退离（指离开函式时的那一个执行点） 退出explicit 明白的、明显的、显式 显式export 汇出 引出、导出 facility 设施、设备 设施、设备feature 特性field 栏位,资料栏（Java） 字段, 值域（Java）file 档案 文件firmware 韧体 固件flag 旗标 标记flash memory 快闪记忆体 闪存flexibility 弹性 灵活性flush 清理、扫清 刷新font 字型 字体form 表单（programming 用语） 窗体formal parameter形式叁数 形式叁数forward declaration 前置宣告 前置声明forwarding 转呼叫,转发 转发forwarding function 转呼叫函式,转发函式 转发函数fractal 碎形 分形framework 框架 框架full specialization 全特化（ref. partial specialization）function 函式、函数 函数function call operator 同call operator function object 函式物件（ref. C++ Primer 3/e, 12.3） 函数对象function overloaded resolution 函式多载决议程序 函数重载解决（方案）functionality 功能、机能 功能function template 函式模板、函式范本 函数模板functor 仿函式 仿函式、函子 game 游戏 游戏generate 生成generic 泛型、一般化的 一般化的、通用的、泛化generic algorithm 泛型演算法 通用算法getter (相对於 setter) 取值函式global 全域的（对应於 local） 全局的global object 全域物件 全局对象global scope resolution operator 全域生存空间（范围决议）运算子 :: 全局范围解析操作符group 群组group box 群组方块 分组框guard clause 卫述句 (Refactoring, p250) 卫语句GUI 图形介面 图形界面 hand shaking 握手协商handle 识别码、识别号、号码牌、权柄 句柄handler 处理常式 处理函数hard－coded 编死的 硬编码的hard－copy 硬拷图 屏幕截图hard disk硬碟 硬盘hardware 硬体 硬件hash table 杂凑表 哈希表、散列表header file 表头档、标头档 头文件heap 堆积 堆hierarchy 阶层体系 层次结构（体系）hook 挂钩 钩子hyperlink 超链结 超链接 icon 图示、图标 图标IDE 整合开发环境 集成开发环境identifier 识别字、识别符号 标识符if and only if 若且唯若 当且仅当Illinois 伊利诺 伊利诺斯image 影像 图象immediate base 直接的（紧临的）上层 base class。 直接上层基类immediate derived 直接的（紧临的）下层 derived class。 直接下层派生类immutability 不变性immutable 不可变（的）implement 实作、实现 实现implementation 实作品、实作体、实作码、实件 实现implicit 隐喻的、暗自的、隐式 隐式import 汇入 导入increment operator 累加运算子 ++ 增加操作符infinite loop 无穷回圈 无限循环infinite recursive 无穷递回 无限递归information 资讯 信息infrastructure 公共基础建设inheritance 继承、继承机制 继承、继承机制inline 行内 内联inline expansion 行内展开 内联展开initialization 初始化（动作） 初始化initialization list 初值列 初始值列表initialize 初始化 初始化inner class 内隐类别 内嵌类instance 实体 实例（根据某种表述而实际产生的「东西」）instantiated 具现化、实体化（常应用於 template） 实例化instantiation 具现体、具现化实体（常应用於 template） 实例integer (integral) 整数（的） 整型（的）integrate 整合 集成interacts 交谈、互动 交互interface 介面 接口interpreter 直译器 解释器invariants 恒常性,约束条件 约束条件invoke 唤起 调用iterate迭代（回圈一个轮回一个轮回地进行） 迭代iterative 反覆的，迭代的iterator 迭代器（一种泛型指标） 迭代器iteration 迭代（回圈每次轮回称为一个 iteration） 迭代item 项目、条款 项、条款、项目laser 雷射 激光level 阶 层 (级) 例 high level 高阶 高层library 程式库、函式库 库、函数库lifetime 生命期、寿命 生命期、寿命link 联结、连结 连接,链接linker 联结器、连结器 连接器literal constant 字面常数（例 3.14 或 “hi” 这等常数值） 字面常数list 串列（linked－list） 列表、表、链表list box 列表方块、列表框 列表框 load 载入 装载loader 载入器 装载器、载入器local 区域的（对应於 global） 局部的local object 区域物件 局部对象lock 机锁loop 回圈 循环lvalue 左值 左值 macro 巨集 宏magic number 魔术数字 魔法数maintain 维护 维护manipulator 操纵器（iostream 预先定义的一种东西） 操纵器marshal 编列 列集叁考demarshal mechanism 机制 机制member 成员 成员member access operator 成员取用运算子（有 dot 和 arrow 两种） 成员存取操作符member function 成员函式 成员函数member initialization list 成员初值列 成员初始值列表memberwise 以 member 为单元┅、members 逐一┅ 以成员为单位memberwise copy 以 members 为单元逐一复制memory 记忆体 内存menu 表单、选单 菜单message 讯息 消息message based 以讯息为基础的 基於消息的message loop 讯息回圈 消息环method 方法、行为、函式 方法meta－ 超－ 元－meta－programming 超编程 元编程micro 微 微middleware 中介层 中间件modeling 模塑modeling language 塑模语言，建模语言modem 数据机 调制解调器module 模组 模块modifier 饰词 修饰符most derived class 最末层衍生类别 最底层的派生类mouse 滑鼠 鼠标mutable可变的 可变的multi－tasking 多工 多任务 namespace 命名空间 名字空间、命名空间native 原生的 本地的、固有的nested class 巢状类别 嵌套类network 网路 网络network card 网路卡 网卡 object 物件 对象object based 以物件为基础的 基於对象的object file 目的档 目标文件object model 物件模型 对象模型object oriented 物件导向的 面向对象的online 线上 在线opaque 不透明的operand 运算元 操作数operating system (OS) 作业系统 操作系统operation 操作、操作行为 操作operator 运算子 操作符、运算符option 选项，可选方案 选项ordinary 常规的 常规的overflow 上限溢位（相对於 underflow） 溢出（underflow:下溢）overhead 额外负担、额外开销 额外开销overload 多载化、多载化、重载 重载overloaded function 多载化函式 重载的函数overloaded operator 多载化运算子 被重载的操作符overloaded set 多载集合 重载集合override 改写、覆写 重载、改写、重新定义（在 derived class 中重新定义虚拟函式) package 套件 包pair 对组palette 调色盘、组件盘、工具箱pane 窗格 窗格parallel 平行 并行parameter 叁数（函式叁数列上的变数） 叁数、形式叁数、形叁parameter list 叁数列 叁数列表parent class 父类别（或称 base class） 父类parentheses 小括弧、小括号 圆括弧、圆括号parse 解析 解析part 零件 部件partial specialization 偏特化（ref. C++ Primer 3/e, 16.10）局部特化pass by address 传址（函式引数的传递方式）（非正式用语）传地址pass by reference 传址（函式引数的一种传递方式） 传地址, 按引用传递pass by value 传值（函式引数的一种传递方式） 按值传递pattern 范式、样式 模式performance 效率、性能兼而有之 性能persistence 永续性 持久性pixel 图素、像素 像素platform 平台 平台pointer 指标 指针址位器（和址叁器 reference 形成对映，满好）poll 轮询 轮询polymorphism 多型 多态pop up 冒起式、弹出式 弹出式port 埠 端口postfix 後置式、後序式 後置式precedence 优先序（通常用於运算子的优先执行次序）prefix 前置式、前序式 前置式preprocessor 前处理器 预处理器prime 质数 素数primitive type 基本型别 (不同於 base class,基础类别)print 列印 打印printer 印表机 打印机priority 优先权 (通常用於执行绪获得 CPU 时间的优先次序）procedure 程序 过程procedural 程序性的、程序式的 过程式的、过程化的process 行程 进程profile 评测 评测profiler 效能（效率）评测器 效能（性能）评测器programmer 程式员 程序员programming 编程、程式设计、程式化 编程progress bar 进度指示器 进度指示器project 专案 项目、工程property 属性protocol 协定 协议pseudo code 假码、虚拟码、伪码 伪码 qualified 经过资格修饰（例如加上 scope 运算子） 限定qualifier 资格修饰词、饰词 限定修饰词quality 品质 质量queue 伫列 队列 radian 径度 弧度radio button 圆钮 单选按钮raise 引发（常用来表示发出一个 exception） 引起、引发random number 随机数、乱数 随机数range 范围、区间（用於 STL 时） 范围、区间rank 等级、分等（ref. C++Primer 3/e 9,15章） 等级raw 生鲜的、未经处理的 未经处理的record 记录 记录recordset 记录集 记录集recursive 递回 递归re－direction 重导向 重定向refactoring 重构、重整 重构refer 取用 叁考refer to 指向、指涉、指代reference 引用、叁考 址叁器,see pointer register 暂存器 寄存器reflection 反射 反射、映像relational database 关联式资料库 关系数据库represent 表述，表现 表述，表现resolve 决议（为算式中的符号名称寻找 解析对应之宣告式的过程）resolution 决议程序、决议过程 解析过程resolution 解析度 分辨率restriction 局限return 传回、回返 返回return type 回返型别 返回类型return value 回返值 返回值robust 强固、稳健 健壮robustness 强固性、稳健性 健壮性routine 常式 例程runtime 执行期 运行期、运行时common language runtime (CLR) 译为「通用语言执行层」rvalue 右值 右值 save 保存savepoint 保存点SAX (Simple API for XML)scalable 可伸缩的、可扩展的schedule 调度scheduler 调度程序schema 模式、纲目结构scroll bar 滚动条scope 作用域、生存空间scope operator 生存空间操作符scope resolution operator 生存空间解析操作符screen 屏幕SDK (Software Development Kit) 软件开发包sealed class 密封类search 查找semantics 语义semaphore 信号量sequential container序列式容器server 服务器、服务端serial 串行serialization/serialize 序列化server cursor 服务端游标、服务器游标session 会话setter 设值函数shared lock 共享锁sibling 同级side effect 副作用signature 签名single-threaded 单线程slider 滑块slot 槽smart pointer 智能指针SMTP (Simple Mail Transfer Protocol) 简单邮件传输协议snapshot 截屏图snapshot 快照specialization 特化specification 规范、规格splitter 切分窗口SOAP (simple object access protocol) 简单对象访问协议software 软件source code 源码、源代码SQL (Structured Query Language) 结构化查询语言stack 栈、堆栈stack unwinding 叠辗转开解(此词用于exception主题)standard library 标准库standard template library 标准模板库stateless 无状态的statement 语句、声明static cursor 静态游标static SQL statements 静态SQL语句stored procedure 存储过程status bar 状态条stream 流string 字符串stub 存根subobject 子对象subquery 子查询subroutine 子例程subscript operator 下标操作符subset 子集subtype 子类型support 支持suspend 挂起symbol 记号syntax 语法system databases 系统数据库system tables 系统表 tag标签 标记 索引标签,页签target 标的（例 target pointer：标的指标） 目标task switch 工作切换 任务切换template 模板、范本 模板template argument deduction 模板引数推导 模板叁数推导template explicit specialization 模板显式特化（版本） 模板显式特化template parameter 模板叁数 模板叁数temporary object 暂时物件 临时对象text文字 文本text file 程式本文档（放置程式原始码的档案） 文本文件thread 执行绪 线程thread safe 多绪安全 多线程安全throw 丢掷（常指发出一个 exception） 丢掷、引发token 语汇单元 符号、标记transaction 交易 事务transaction log 事务日志transaction rollback 事务回滚transactional replication 事务复制translation unit 翻译单元transparent(ly) 透通的(地)traverse 巡访（来回走动） 遍历trigger 触发 触发type 型别 类型table 表table lock 表锁table-level constraint 表级约束tape backup 磁带备份task switch 工作切换TCP (Transport Control Protocol) 传输控制协议temporary table 临时表thin client 瘦客户端third-party 第三方trace 跟踪traverse 遍历two-phase commit 两阶段提交tupletwo-phase lookup 两阶段查找 UML unified modeling language 统一建模语言unary function 一元函式 单叁函数unary operator 一元运算子 一元操作符underflow 下限溢位（相对於 overflow） 下溢unchecked exception 不可控异常unqualified 未经资格修饰（而直接取用）user 使用者、用户 用户user interface 使用者界面、用户界面、人机界面UDDI(Universary Description, Discovery and Integration)统一描述、查询与集成unboxing 拆箱、拆箱转换Union query 联合查询UNIQUE constraints UNIQUE约束unique index 唯一索引unmanaged code 非受控代码、非托管代码unmarshal 散集unqualified 未经限定的、未经修饰的URI (Uniform Resource identifier) 统一资源标识符URL (Uniform Resource Locator) 统一资源定位器 variable 变数（相对於常数 const） 变量vector 向量（一种容器，有点类似 array） 向量、矢量viable 可实行的、可行的 可行的viable function 可行函式 可行函数video 视讯 视频view (1) 视图(document/view) 文档/视图virtual function 虚拟函式 虚函数virtual machine 虚拟机器 虚拟机virtual memory虚拟记忆体 虚内存, 虚存volatile 易挥发的、易变的vowel 母音 元音字母 window 视窗 窗口window function 视窗函式 窗口函数window procedure 视窗函式 窗口过程word 字 单词word processor 文书处理器 字处理器wrapper 外覆、外包 包装Web Services web 服务WHERE clause WHERE子句wildcard characters 通配符字符wildcard search 通配符搜索Windows authentication Windows 身份验证wizard 向导write enable 写启用write-ahead log 预写日志write-only 只写WSDL (Web Service Description Language)Web Service 描述语言 XML (eXtensible Markup Language) 可扩展标记语言XSD (XML Schema Definition) XML 模式定义语言XSL (eXtensible Stylesheet Language) 可扩展样式表语言XSLT (eXtensible Stylesheet Language Transformation)可扩展样式表语言转换xxx based 基于xxx的xxx oriented 面向xxxXML (eXtensible Markup Language) 可扩展标记语言","tags":[{"name":"english learn","slug":"english-learn","permalink":"http://yoursite.com/tags/english-learn/"}]},{"title":"设计模式","date":"2017-05-20T03:42:48.025Z","path":"2017/05/20/设计模式/","text":"设计模式总结什么是设计模式设计模式是从许多优秀的软件系统中总觉出成功的可复用的设计方案。 每一个设计模式描述一个在我们周围不断重复发生的问题，以及该为题的解决方案的核心，这样，你就可以一次一次的使用该方案而不必做重复的劳动。 by – Alexander 建筑大师 尽管Alwxander 所指的是城市和建筑的设计模式，但他的思想也同样适用于面向对象设计模式，只是在面向对象的解决方案里，我们用对象和接口代替了墙壁和门窗。 记录一个设计模式需有四个基本的要素： 名称 问题 方案 效果 例如: 中介者模式： 名称 中介者 问题 用一个中介者来封装一系列的对象交互，中介者使各种对象不需要显示的相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互。 方案 中介者（Mediator） 接口，具体中介者（Concerte Mediator），同事（Colleague），具体同事（Concrete Colleagure） 效果 减少了子类的生成，将各个同事解耦，简化了对象的协议，控制集中化。 软件领域的设计模式起源于建筑学，一个好的设计系统往往是易维护，易扩展，易复用的。 什么是框架 框架不是模式，框架是针对某个领域，提供用于开发应用系统的类的集合，程序设计者可以使用框架提供的类设计一个应用程序，而且在设计应用程序时可以针对特定的问题使用某个模式。 面向对象的几个基本的原则 抽象类和接口 面向抽象所谓面向抽象编程，是指当设计一个类时，不让该类面向具体的类，而是面向抽象类或者接口，即所设计类中的重要数据是抽象类或接口声明的变量，而不是具体类声明的变量。3.开闭原则让设计对扩展开放，对修改关闭。4.多用组合少用继承原则5.高内聚-低耦合原则 在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。这个术语是由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学的。 设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案。 面向对象设计模式通常以类或对象来描述其中的关系和相互作用，但不涉及用来完成应用程序的特定类或对象。设计模式能使不稳定依赖于相对稳定、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力。 并非所有的软件模式都是设计模式，设计模式特指软件“设计”层次上的问题。还有其它非设计模式的模式，如架构模式。同时，算法不能算是一种设计模式，因为算法主要是用来解决计算上的问题，而非设计上的问题。 肯特·贝克和沃德·坎宁安在1987年，利用克里斯托佛·亚历山大在建筑设计领域里的思想开发了设计模式并把此思想应用在Smalltalk中的图形用户接口（GUI）的生成中。一年后埃里希·伽玛在他的苏黎世大学博士毕业论文中开始尝试把这种思想改写为适用于软件开发。与此同时James Coplien 在1989年至1991年也在利用相同的思想致力于C++的开发，而后于1991年发表了他的著作Advanced C++ Programming Styles and Idioms。同年Erich Gamma 得到了博士学位，然后去了美国，在那与Richard Helm, Ralph Johnson ,John Vlissides 合作出版了《设计模式：可复用面向对象软件的基础》（Design Patterns - Elements of Reusable Object-Oriented Software） 一书，在此书中共收录了23个设计模式。 这四位作者在软件开发领域里以“四人帮”（英语，Gang of Four，简称GoF）而闻名，并且他们在此书中的协作导致了软件设计模式的突破。有时，GoF也会用于代指《设计模式》这本书。 《设计模式》一书原先把设计模式分为创建型模式、结构型模式、行为型模式，把它们通过授权、聚合、诊断的概念来描述。若想更进一步了解关于面向对象设计的背景，参考接口模式、内聚。若想更进一步了解关于面向对象编程的背景，参考继承，接口，多态。 简单工厂模式活字印刷 面向对象话说三国时期，曹操带领百万大军攻打东吴，大军在长江赤壁驻扎，军船连成一片，眼看就要灭掉东吴，统一天下，曹操大悦，于是大宴众文武，在酒席间，曹操诗兴大发，不觉吟道：喝酒唱歌，人生真爽。众文武齐呼：“丞相好诗！于是一臣子速命印刷工匠刻板印刷，以便流传天下。” 样张出来给曹操一看，曹操感觉不妥，说到：“喝与唱，此话过俗，应该为‘对酒当歌’较好！”，于是此臣就命工匠重新来过。工匠眼看连夜刻板之工，彻底白费，心中叫苦不迭。只得照办。” 样张再次出来请曹操过目，曹操细细一品，感觉还是不好，说：“人生真爽太过直接，应改问语才够意境，因此应改为‘对酒当歌，人生几何？’当臣子转告工匠之时，工匠晕倒！” 为何三国时期的工匠有如此的问题？ 当时活字印刷还未发明，所以要改字的时候必须要整个刻板重刻。如果有活字印刷，则只需更改四个字就可，其余工作都未白做，岂不妙哉。 要改，只需要更改之字，此为可维护。 这写字并非用完这次就无用，完全可以在后来的印刷中重复使用，此乃可复用。 此诗若要加字，只需另刻字加入即可，这是可扩展。 字的排列其实可能是竖排也可能是横排，此时只需要将活字移动就可以做到满足排列需求，此是灵活性好 面对对象的分析设计编程思想，通过封装，继承多态把程序的耦合度降低，传统印刷术的问题就在于所有的字都刻在同一版面上造成耦合度太高所致，开始用设计模式使得程序更加灵活，易于修改，易于复用。 简单工厂模式例：计算器，到底要实例化谁，将来会不会增加实例化的对象，把很容易变化的地方用一个单独的类来做这个创造实例的过程，这个就是工厂。简单的运算工厂类 public class OperationFactory { public static operation createOperate(string operate) { Operation oper = null; switch (operate) { case &quot;+&quot;: oper = new OperationAdd(); break; case &quot;-&quot;: oper = new OperationSub(); break; case &quot;*&quot;: oper = new OperationMul(); break; case &quot;/&quot;: oper = new OperationDiv(); break; } return oper; } } 客户端代码 Operation oper; oper = OperationFactory.createOperate(&quot;+&quot;); oper.NumberA = 1; oper.NumberB = 2; double result = oper.GetResult(); 这样，以后需要增加各种复杂运算，比如平方根，立方根，自然对数等等，只要增加相对应的运算子类就可以了。 策略模式应用场景一个商场收银软件，营业员根据客户所购买的商品的单价和数量，向客户收费用两个文本框来输入单价和数量，一个确定按钮来算出每种商品的费用，用个列表框来记录商品的清单，一个标签来记录总计，一个重置按钮来重新开始。 double total = 0.0d; private void btn0k_Click(object sender, EventArgs e) { double totalPrices = Convert.ToDouble(txtPrice.Text) * Convert.ToDouble(txtNum.Text); total = total + totalPrices; IbxList.Items.Add(&quot;单价：&quot; +txtPrice.Text + &quot;数量：&quot; ＋ txtNum.Text + &quot;合计：&quot;+ totalPrices.ToString()); IblResult.Text = total.ToString(); } 比如遇到节假日 增加打折double total = 0.0d; private void Form_Load(object sender, EventArgs e) { cbxType.Items.AddRange(new object[] {&quot;正常收费&quot;,&quot;打八折&quot;,&quot;打五折&quot;}); cbxType.SlectedIndex = 0; } private void btn0k_Click(object sender, EventArgs e) { double totalPrices = 0.0d; switch(cbxType.Selectedindex) { case 0: totalPrices = Convert.ToDouble(txtPrice.Text) * Convert.ToDouble(txtNum.Text); case 1: totalPrices = Convert.ToDouble(txtPrice.Text) * Convert.ToDouble(txtNum.Text)*0.8; case 2: totalPrices = Convert.ToDouble(txtPrice.Text) * Convert.ToDouble(txtNum.Text)*0.5; } total = total + totalPrices; IbxList.Items.Add(&quot;单价：&quot; +txtPrice.Text + &quot;数量：&quot; ＋ txtNum.Text + &quot;合计：&quot;+ totalPrices.ToString()); IblResult.Text = total.ToString(); } 简单工厂实现面对对象的编程，并不是类越多越好，类的划分是为了封装，但是分装的基础是抽象，具有相同属性和功能的对象的抽象集合才是类。打一折和打九折只是形式的不同，抽象分析出来，所有的打折算法都是一样的，所以打折算法应该是一个类。 //现金收费抽象类 abstract class CashSuper { public abstract double acceptCash(double money); } //正常收费子类 class CashNormal: CashSuper { public override double acceptCash(double money) { return money; } } //打折收费子类 class CashRebate: CashSuper { private double moneyRebate = 1d; public Cash Rebebate(string moneyRebate) { this.moneyRebate = double.Parse(moneyRebate); } publci override double acceptCash(double money) { return money * moneyRebate; } } //返利收费子类 class cashReturn: CashSuper { private double moneyCondition = 0.0d; private double moneyreturn = 0.0d; public CashReturn(string moneyCondition, string moneyReturn) { this.moneyCondition = double.Parse(moneyCondtion); this.moneyReturn = double.Parse(moneyReturn); } public override double acceptCash(double money) { double result = money; if(money &gt;= moneyCondition) { result = money - Math.Floor(money / moneyCondition) * moneyReturn; } return result; } } //现金收费工厂类 class CashFactory { public static CashSuper createCashAccept(string type) { CashSuper cs = null; switch (type) { case:&quot;正常收费&quot;: cs = new CashNormal(); break; case:&quot;满300返100&quot;: CashReturn cr1 = new CashReturn(&quot;300&quot;,&quot;100&quot;); cs = cr1; break; case:&quot;打8折&quot;: CashRebate cr2 = new CashRebate(&quot;0,8&quot;); cs = cr2; break; } return cs; } } //客户端程序主要部分 double total = 0.0d; private void btn0k_clik(object sneder, EventArgs e) { cashSuper csuper = CashFactory.createCashAccept(cbxType.SelectedItem.ToString()); double totalPrices = 0d; totalPrices = csuper.acceptCash(Convert.ToDouble(txtPrice.txt)*Convert.ToDouble(txtNum.Text)); total = total + totalPrices; IbxList.Items.Add(&quot;单价：&quot; +txtPrice.Text + &quot;数量：&quot; ＋ txtNum.Text + &quot;合计：&quot;+ totalPrices.ToString()); IblResult.Text = total.ToString(); } 简单工厂模式虽然能解决这个问题，但是这个模式知识解决对象的创建问题，而且由于工厂本身包括了所有的收费方式，商场是可能经常性地更改打折额度和返利额度，每次维护或扩展收费方式都要改动这个工厂，以致代码需重新编译部署，这真的是很糟糕的处理方式，所以用它不是做好的办法，。面对算法的时常变动应该有更好的办法。 策略模式策略模式定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。 //CashContext类 class CashContext { private CashSuper cs; public CashContext(CashSuper csuper) { this.cs = csuper; } public double GetResult(double money) { return cs.accptCash(money); } } //客户端主要代码 double total = 0.0d; private void btn0k_Click(object sender, EventArgs e) { CashContext cc = null; switch (cbxType.selectedItem.ToString()) { case: &quot;正常收费&quot;: cc = new CashContext(new CashNormal()); break; case: &quot;满300返100&quot;: cc = new CashContext(new CashReturn (&quot;300&quot;,&quot;100&quot;)); break; case: &quot;打8折&quot;: cc = new CashContext(new CashRebate(&quot;0.8&quot;)); break; } double totalPrices = 0d; totalPrices = cc.GetResult(convert.ToDouble(txtPrice.Text)*convert.ToDouble(txtNum.Text)); total = total + totalPrices; IbxList.Items.Add(&quot;单价：&quot; +txtPrice.Text + &quot;数量：&quot; ＋ txtNum.Text + &quot;合计：&quot;+ totalPrices.ToString()); IblResult.Text = total.ToString(); } 虽然策略模式写出来了，但是不应该让客户端去判断用哪一个算法。 策略与简单工厂结合class CashContext { CashSuper cs = null; public CashContext(String type) { switch(type) { case &quot;正常收费&quot;: CashNormal cs0 = new CashNormal(); cs = cs0; break; case &quot;满300返100&quot;: CashReturn cr1 = new CashReturn(&quot;300&quot;,&quot;100&quot;); cs = cr1; break; case &quot;打8折&quot;： CashReturn cr2 = new CashRebate(&quot;0.8&quot;); cs = cr2; break; } public double GetResult(double money) { return cs.acceptCash(money); } } } //客户端代码 double total = 0.0d; private void btn0k_Click(object sender, EvnetArgs e) { CashContext csuper = new CashContext(cbxType.slectedItem.ToString()); double totalPrices = 0d; totalPrices = csuper.GetResult(Convert.ToDouble(txtPrice.Text)*Convert.ToDouble(txtNum.Text)); total = total + totalPrices; IbxList.Items.Add(&quot;单价：&quot; +txtPrice.Text + &quot;数量：&quot; ＋ txtNum.Text + &quot;合计：&quot;+ totalPrices.ToString()); IblResult.Text = total.ToString(); } //简单工厂模式的用法 CashSuper csuper = CashFactory.CreateCashAccept(cbxType.SelectedItem.ToString()); =csuper.GetResult; //策略模式与简单工厂结合的用法 CashContext csuper = new (CashContext(cbxType.SelectedItem.ToString())); =csuper.GetResult; 简单工厂模式让客户端认识两个类， CashSuper和CashFactory,而策略模式与简单工厂结合的用法，客户端只需要认识一个类CashContext就可以了。耦合更加降低。 策略模式解析策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相通的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少各种算法类和使用算法类之间的耦合。策略模式就是用来封装算法的，但是实践中，我们发现可以用它来分装几乎任何类型的规则，只要在分析过程中听到需要在不同的时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性。 面向对象六大原则概述在工作初期，我们可能会经常会有这样的感觉，自己的代码接口设计混乱、代码耦合较为严重、一个类的代码过多等等，自己回头看的时候都觉得汗颜。再看那些知名的开源库，它们大多有着整洁的代码、清晰简单的接口、职责单一的类，这个时候我们通常会捶胸顿足而感叹：什么时候老夫才能写出这样的代码！ 相关资料iOSAFNetworking2.0源码解析 AFNetworking源码 单一原则(Single Responsibility Principle)简述SRP:就一个类而言，应该仅有一个引起它变化的原因。单一职责的划分界限并不是如马路上的行车道那么清晰，很多时候都是需要靠个人经验来界定。当然最大的问题就是对职责的定义，什么是类的职责，以及怎么划分类的职责。如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。 当然，软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离，就是抽象的能力。其实要去判断是否应该分离出类来，也不难，那就是如果你能想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。 示例/** * An HTTP stack abstraction. */ public interface HttpStack { /** * 执行Http请求,并且返回一个HttpResponse */ public HttpResponse performRequest(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders) throws IOException, AuthFailureError; } HttpStack中这个函数的职责就是执行网络请求并且返回一个Response。它的职责很单一，这样在需要修改执行网络请求的相关代码时我们只需要修改实现HttpStack接口的类，而不会影响其它的类的代码。如果某个类的职责包含有执行网络请求、解析网络请求、进行gzip压缩、封装请求参数等等，那么在你修改某处代码时你就必须谨慎，以免修改的代码影响了其它的功能。但是当职责单一的时候，你修改的代码能够基本上不影响其它的功能。这就在一定程度上保证了代码的可维护性。注意，单一职责原则并不是说一个类只有一个函数，而是说这个类中的函数所做的工作必须要是高度相关的，也就是高内聚。 里氏替换原则(Liskov Substitution Principle)简述肯定有不少人跟我刚看到这项原则的时候一样，对这个原则的名字充满疑惑。其实原因就是这项原则最早是在1988年，由麻省理工学院的一位姓里的女士（Barbara Liskov）提出来的。 定义1：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。 定义2：所有引用基类的地方必须能透明地使用其子类的对象。 问题由来：有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。 解决方案：当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。 继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。 继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。 里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义： 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 子类中可以增加自己特有的方法。 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。 示例还是以HttpStack为例，Volley定义了HttpStack来表示执行网络请求这个抽象概念。在执行网络请求时，我们只需要定义一个HttpStack对象，然后调用performRequest即可。至于HttpStack的具体实现由更高层的调用者给出。示例如下 :123456789101112131415161718192021 public static RequestQueue newRequestQueue(Context context, HttpStack stack) &#123; File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR); String userAgent = &quot;volley/0&quot;; // 代码省略// 1、构造HttpStack对象 if (stack == null) &#123; if (Build.VERSION.SDK_INT &gt;= 9) &#123; stack = new HurlStack(); &#125; else &#123; // Prior to Gingerbread, HttpUrlConnection was unreliable. // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent)); &#125; &#125;// 2、将HttpStack对象传递给Network对象 Network network = new BasicNetwork(stack);// 3、将network对象传递给网络请求队列 RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network); queue.start(); return queue; &#125; BasicNetwork的代码如下: 1234567891011121314151617/** * A network performing Volley requests over an &#123;@link HttpStack&#125;. */public class BasicNetwork implements Network &#123; // HttpStack抽象对象 protected final HttpStack mHttpStack; protected final ByteArrayPool mPool; public BasicNetwork(HttpStack httpStack) &#123; this(httpStack, new ByteArrayPool(DEFAULT_POOL_SIZE)); &#125; public BasicNetwork(HttpStack httpStack, ByteArrayPool pool) &#123; mHttpStack = httpStack; mPool = pool; &#125;&#125; 上述代码中，BasicNetwork构造函数依赖的是HttpStack抽象接口，任何实现了HttpStack接口的类型都可以作为参数传递给BasicNetwork用以执行网络请求。这就是所谓的里氏替换原则，任何父类出现的地方子类都可以出现，这不就保证了可扩展性吗？ 减少LSP妨碍契约（Contracts）处理 LSP 过分妨碍的一个策略是使用契约，契约清单有 2 种形式：执行说明书（executable specifications）和错误处理，在执行说明书里，一个详细类库的契约也包括一组自动化测试，而错误处理是在代码里直接处理的，例如在前置条件，后置条件，常量检查等，可以从 Bertrand Miller 的大作《契约设计》中查看这个技术。虽然自动化测试和契约设计不在本篇文字的范围内，但当我们用的时候我还是推荐如下内容： 检查使用测试驱动开发（Test-Driven Development）来指导你代码的设计设计可重用类库的时候可随意使用契约设计技术对于你自己要维护和实现的代码，使用契约设计趋向于添加很多不必要的代码，如果你要控制输入，添加测试是非常有必要的，如果你是类库作者，使用契约设计，你要注意不正确的使用方法以及让你的用户使之作为一个测试工具。契约（Contracts） 处理 LSP 过分妨碍的一个策略是使用契约，契约清单有 2 种形式：执行说明书（executable specifications）和错误处理，在执行说明书里，一个详细类库的契约也包括一组自动化测试，而错误处理是在代码里直接处理的，例如在前置条件，后置条件，常量检查等，可以从 Bertrand Miller 的大作《契约设计》中查看这个技术。虽然自动化测试和契约设计不在本篇文字的范围内，但当我们用的时候我还是推荐如下内容： 检查使用测试驱动开发（Test-Driven Development）来指导你代码的设计设计可重用类库的时候可随意使用契约设计技术对于你自己要维护和实现的代码，使用契约设计趋向于添加很多不必要的代码，如果你要控制输入，添加测试是非常有必要的，如果你是类库作者，使用契约设计，你要注意不正确的使用方法以及让你的用户使之作为一个测试工具。 避免继承避免 LSP 妨碍的另外一个测试是：如果可能的话，尽量不用继承，在Gamma的大作《Design Patterns – Elements of Reusable Object-Orineted Software》中，我们可以看到如下建议： Favor object composition over class inheritance 尽量使用对象组合而不是类继承有些书里讨论了组合比继承好的唯一作用是静态类型，基于类的语言（例如，在运行时可以改变行为），与 JavaScript 相关的一个问题是耦合，当使用继承的时候，继承子类型和他们的基类型耦合在一起了，就是说基类型的改变会影响到继承子类型。组合倾向于对象更小化，更容易向静态和动态语言语言维护。 与行为有关，而不是继承到现在，我们讨论了和继承上下文在内的里氏替换原则，指示出 JavaScript 的面向对象实。不过，里氏替换原则（LSP）的本质不是真的和继承有关，而是行为兼容性。JavaScript 是一个动态语言，一个对象的契约行为不是对象的类型决定的，而是对象期望的功能决定的。里氏替换原则的初始构想是作为继承的一个原则指南，等价于对象设计中的隐式接口。 依赖倒置原则(Dependence Inversion Principle)应用场景电脑在以前维修的话是根本不可能的事，可是现在却特别容易，比如说内存坏了，买个内存条，硬盘坏了，买个硬盘换上。为啥这么方便？从修电脑里面就有面相对象的几大设计原则，比如单一职责原则，内存坏了，不应该成为更换CPU的理由，它们各自的职责是明确的。再比如开放－封闭原则，内存不够只要插槽足够就可以添加。还有依赖倒转原则，原话解释是抽象不应该依赖细节，细节应该依赖于抽象，说白了，就是要针对接口编程，不要对实现编程，无论主板，CPU，内存，硬盘都是针对接口设计的，如果是针对实现来设计，内存就要对应的某个品牌的主板，那就会出现换内存需要把主板也换了的尴尬。 为什么叫反转呢？ 面对过程开发时，为了使得常用代码可以复用，一般都会把这些常用代码写成许许多多函数的程序库，这样我们做新项目时，去调用这些底层的函数就可以了。比如我们做的项目大多要访问数据库，所以我们就把访问数据库的代码写成了函数，每次做新项目时就去调用，这就叫做高层模块依赖底层模块。 但是要做新项目是 业务逻辑的高层模块都是一样的，客户却希望使用不同的数据库或存储信息方式，这时出现麻烦了。我们希望能再次利用这些高层模块，但高层模块都是与底层的访问数据库绑定在一起的，没办法复用这些高层模块，这就非常糟糕了。就像刚才说的，PC里如果CPU，内存，硬盘都是需要依赖具体的主板，主板一坏，所有的部件都没法用了，显然不合理，而如果不管高层模块还是底层模块，它们都依赖于抽象，具体一点就是接口或者抽象类，只要接口是稳定的，那么任何一个的更改都不用担心其它受影响，这就使得无论高层模块还是底层模块都可以很容易被复用，这才是最好的办法。 实例依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。 依赖倒置原则的核心思想是面向接口编程，我们依旧用一个例子来说明面向接口编程比相对于面向实现编程好在什么地方。场景是这样的，母亲给孩子讲故事，只要给她一本书，她就可以照着书给孩子讲故事了。代码如下： 1234567891011121314151617181920class Book&#123; public String getContent()&#123; return &quot;很久很久以前有一个阿拉伯的故事……&quot;; &#125; &#125; class Mother&#123; public void narrate(Book book)&#123; System.out.println(&quot;妈妈开始讲故事&quot;); System.out.println(book.getContent()); &#125; &#125; public class Client&#123; public static void main(String[] args)&#123; Mother mother = new Mother(); mother.narrate(new Book()); &#125; &#125; 运行良好，假如有一天，需求变成这样：不是给书而是给一份报纸，让这位母亲讲一下报纸上的故事，报纸的代码如下： 12345class Newspaper&#123; public String getContent()&#123; return &quot;林书豪38+7领导尼克斯击败湖人……&quot;; &#125; &#125; 这位母亲却办不到，因为她居然不会读报纸上的故事，这太荒唐了，只是将书换成报纸，居然必须要修改Mother才能读。假如以后需求换成杂志呢？换成网页呢？还要不断地修改Mother，这显然不是好的设计。原因就是Mother与Book之间的耦合性太高了，必须降低他们之间的耦合度才行。我们引入一个抽象的接口IReader。读物，只要是带字的都属于读物： 1234567interface IReader&#123; public String getContent(); &#125; ``` Mother类与接口IReader发生依赖关系，而Book和Newspaper都属于读物的范畴，他们各自都去实现IReader接口，这样就符合依赖倒置原则了，代码修改为： class Newspaper implements IReader { public String getContent(){ return “林书豪17+9助尼克斯击败老鹰……”; }}class Book implements IReader{ public String getContent(){ return “很久很久以前有一个阿拉伯的故事……”; }} class Mother{ public void narrate(IReader reader){ System.out.println(“妈妈开始讲故事”); System.out.println(reader.getContent()); }} public class Client{ public static void main(String[] args){ Mother mother = new Mother(); mother.narrate(new Book()); mother.narrate(new Newspaper()); }}1234567891011121314151617181920212223242526272829这样修改后，无论以后怎样扩展Client类，都不需要再修改Mother类了。这只是一个简单的例子，实际情况中，代表高层模块的Mother类将负责完成主要的业务逻辑，一旦需要对它进行修改，引入错误的风险极大。所以遵循依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。 采用依赖倒置原则给多人并行开发带来了极大的便利，比如上例中，原本Mother类与Book类直接耦合时，Mother类必须等Book类编码完成后才可以进行编码，因为Mother类依赖于Book类。修改后的程序则可以同时开工，互不影响，因为Mother与Book类一点关系也没有。参与协作开发的人越多、项目越庞大，采用依赖导致原则的意义就越重大。现在很流行的TDD开发模式就是依赖倒置原则最成功的应用。传递依赖关系有三种方式，以上的例子中使用的方法是接口传递，另外还有两种传递方式：构造方法传递和setter方法传递，相信用过Spring框架的，对依赖的传递方式一定不会陌生。在实际编程中，我们一般需要做到如下3点：* 低层模块尽量都要有抽象类或接口，或者两者都有。* 变量的声明类型尽量是抽象类或接口。* 使用继承时遵循里氏替换原则。依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。# 接口隔离原则(Interface Segregation Principle)## 简介接口隔离原则（英语：interface-segregation principles， 缩写：ISP）指明没有客户(client)应该被迫依赖于它不使用方法。接口隔离原则(ISP)拆分非常庞大臃肿的接口成为更小的和更具体的接口，这样客户将会只需要知道他们感兴趣的方法。这种缩小的接口也被称为角色接口（role interfaces）。接口隔离原则(ISP)的目的是系统解开耦合，从而容易重构，更改和重新部署。接口隔离原则是在SOLID (面向对象设计)中五个面向对象设计(OOD)的原则之一，类似于在GRASP (面向对象设计)中的高内聚性。## 实例定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。解决方案：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。举例来说明接口隔离原则：![enter description here][1]这个图的意思是：类A依赖接口I中的方法1、方法2、方法3，类B是对类A依赖的实现。类C依赖接口I中的方法1、方法4、方法5，类D是对类C依赖的实现。对于类B和类D来说，虽然他们都存在着用不到的方法（也就是图中红色字体标记的方法），但由于实现了接口I，所以也必须要实现这些用不到的方法。对类图不熟悉的可以参照程序代码来理解，代码如下： interface I { public void method1(); public void method2(); public void method3(); public void method4(); public void method5();} class A{ public void depend1(I i){ i.method1(); } public void depend2(I i){ i.method2(); } public void depend3(I i){ i.method3(); }} class B implements I{ public void method1() { System.out.println(“类B实现接口I的方法1”); } public void method2() { System.out.println(“类B实现接口I的方法2”); } public void method3() { System.out.println(“类B实现接口I的方法3”); } //对于类B来说，method4和method5不是必需的，但是由于接口A中有这两个方法， //所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。 public void method4() {} public void method5() {}} class C{ public void depend1(I i){ i.method1(); } public void depend2(I i){ i.method4(); } public void depend3(I i){ i.method5(); }} class D implements I{ public void method1() { System.out.println(“类D实现接口I的方法1”); } //对于类D来说，method2和method3不是必需的，但是由于接口A中有这两个方法， //所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。 public void method2() {} public void method3() {} public void method4() { System.out.println(&quot;类D实现接口I的方法4&quot;); } public void method5() { System.out.println(&quot;类D实现接口I的方法5&quot;); } } public class Client{ public static void main(String[] args){ A a = new A(); a.depend1(new B()); a.depend2(new B()); a.depend3(new B()); C c = new C(); c.depend1(new D()); c.depend2(new D()); c.depend3(new D()); } } 1234可以看到，如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。如果将这个设计修改为符合接口隔离原则，就必须对接口I进行拆分。在这里我们将原有的接口I拆分为三个接口，拆分后的设计如图2所示：![][2] interface I1 { public void method1();} interface I2 { public void method2(); public void method3();} interface I3 { public void method4(); public void method5();} class A{ public void depend1(I1 i){ i.method1(); } public void depend2(I2 i){ i.method2(); } public void depend3(I2 i){ i.method3(); }} class B implements I1, I2{ public void method1() { System.out.println(“类B实现接口I1的方法1”); } public void method2() { System.out.println(“类B实现接口I2的方法2”); } public void method3() { System.out.println(“类B实现接口I2的方法3”); }} class C{ public void depend1(I1 i){ i.method1(); } public void depend2(I3 i){ i.method4(); } public void depend3(I3 i){ i.method5(); }} class D implements I1, I3{ public void method1() { System.out.println(“类D实现接口I1的方法1”); } public void method4() { System.out.println(“类D实现接口I3的方法4”); } public void method5() { System.out.println(“类D实现接口I3的方法5”); }}1234567891011121314151617181920212223242526272829303132333435 接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。本文例子中，将一个庞大的接口变更为3个专用的接口所采用的就是接口隔离原则。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。 说到这里，很多人会觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构。 采用接口隔离原则对接口进行约束时，要注意以下几点： * 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。* 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。* 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。 # 迪米特原则( Law of Demeter)## 简介得墨忒耳定律（Law of Demeter，缩写LoD）亦稱為“最少知识原则（Principle of Least Knowledge）”，是一种软件开发的设计指導原則，特别是面向对象的程序设计。得墨忒耳定律是松耦合的一种具體案例。該原則是美國東北大學在1987年末在發明的，可以簡單地以下面任一種方式總結:每个单元对于其他的单元只能拥有有限的知识：只是与当前单元紧密联系的单元；每个单元只能和它的朋友交谈：不能和陌生单元交谈；只和自己直接的朋友交谈。这个原理的名称来源于希腊神话中的农业女神，孤独的得墨忒耳。很多面向对象程序设计语言用&quot;.&quot;表示对象的域的解析算符，因此得墨忒耳定律可以简单地陈述为“只使用一个.算符”。因此，a.b.Method()违反了此定律，而a.Method()不违反此定律。一个简单例子是，人可以命令一条狗行走（walk），但是不应该直接指挥狗的腿行走，应该由狗去指挥控制它的腿如何行走。## 实例**定义**：一个对象应该对其他对象保持最少的了解。问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。**解决方案**：尽量降低类与类之间的耦合。自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。迪米特法则又叫最少知道原则，最早是在1987年由美国Northeastern University的Ian Holland提出。通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。迪米特法则还有一个更简单的定义：只与直接的朋友通信。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。举一个例子：有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工ID。先来看一下违反迪米特法则的设计。 //总公司员工class Employee{ private String id; public void setId(String id){ this.id = id; } public String getId(){ return id; }} //分公司员工class SubEmployee{ private String id; public void setId(String id){ this.id = id; } public String getId(){ return id; }} class SubCompanyManager{ public List getAllEmployee(){ List list = new ArrayList(); for(int i=0; i&lt;100; i++){ SubEmployee emp = new SubEmployee(); //为分公司人员按顺序分配一个ID emp.setId(“分公司”+i); list.add(emp); } return list; }} class CompanyManager{ public List&lt;Employee&gt; getAllEmployee(){ List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;(); for(int i=0; i&lt;30; i++){ Employee emp = new Employee(); //为总公司人员按顺序分配一个ID emp.setId(&quot;总公司&quot;+i); list.add(emp); } return list; } public void printAllEmployee(SubCompanyManager sub){ List&lt;SubEmployee&gt; list1 = sub.getAllEmployee(); for(SubEmployee e:list1){ System.out.println(e.getId()); } List&lt;Employee&gt; list2 = this.getAllEmployee(); for(Employee e:list2){ System.out.println(e.getId()); } } } public class Client{ public static void main(String[] args){ CompanyManager e = new CompanyManager(); e.printAllEmployee(new SubCompanyManager()); }}12现在这个设计的主要问题出在CompanyManager中，根据迪米特法则，只与直接的朋友发生通信，而SubEmployee类并不是CompanyManager类的直接朋友（以局部变量出现的耦合不属于直接朋友），从逻辑上讲总公司只与他的分公司耦合就行了，与分公司的员工并没有任何联系，这样设计显然是增加了不必要的耦合。按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合。修改后的代码如下: class SubCompanyManager{ public List getAllEmployee(){ List list = new ArrayList(); for(int i=0; i","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"面向对象设计原则","date":"2017-05-03T00:35:32.794Z","path":"2017/05/03/面向对象设计原则/","text":"面向对象的三个基本特征：封装，继承，多态面向对象设计原则 迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用 又叫最少知道原则。是强调了类之间的松耦合，类之间的耦合越弱,越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成影响，也就是说，信息的隐藏促进了软件的复用。 里氏代换原则：所有引用基类对象的地方能够透明地使用其子类的对象 定义1: 如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。 定义2：子类型必须能够替换掉它们的父类型 开闭原则: 软件实体应对扩展开放，而对修改关闭 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 单一职责原则:一个类只负责一个功能领域中的相应职责 不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责，应该仅有一个引起它变化的原因。 遵循单一职责原的优点有： 可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多； 提高类的可读性，提高系统的可维护性； 变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。 依赖倒转原则：抽象不应该依赖于细节，细节应该依赖于抽象 高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。即针对接口编程，不要针对实现编程。 在实际编程中，我们一般需要做到如下3点： 低层模块尽量都要有抽象类或接口，或者两者都有。 变量的声明类型尽量是抽象类或接口。 使用继承时遵循里氏替换原则。 接口隔离原则：使用多个专门的接口，而不使用单一的总接口 使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。 合成复用原则：尽量使用对象组合，而不是继承来达到复用的目的 要尽量的使用合成和聚合，而不是继承关系达到复用的目的. 该原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分： 新的对象通过向这些对象的委派达到复用已有功能的目的。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"理解ThreadLocal","date":"2017-05-02T14:28:08.066Z","path":"2017/05/02/理解ThreadLocal/","text":"理解ThreadLocaljava中可以使用public static设置一个全局变量，所有线程都共享这个变量。但是有时，我们需要每一个线程都有一个自己的共享变量，ThreadLocal就是一个不错的解决方案。 java8中对ThreadLocal的解释12345This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method)has its own, independently initialized copy of the variable. ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID). 对其理解： 每个线程单独保存这个变量，对其他线程不可见。 ThreadLocal可以给一个初始值，而每个线程都会获得这个初始化值的一个副本，也可以new的方式为线程创建一个变量。 ThreadLocal 不是用于解决共享变量的问题的，不是为了协调线程同步而存在，而是为了方便每个线程处理自己的状态而引入的一个机制。 ThreadLocal的使用 ThreadLocal几个主要操作方法 1234public T get() &#123;...&#125;//获取线程变量对象public void remove() &#123;...&#125;//移除线程变量对象，将对线程变量对象的引用设置为nullpublic void set(T value) &#123;...&#125;//添加线程变量对象protected T initialValue() &#123;...&#125;//设置初始化数据，覆盖该方法可以设置初始默认值 使用的小demo 123456789101112131415161718192021public class ThreadLocalDemo &#123; private static ThreadLocal&lt;Integer&gt; local=() -&gt; 0;//覆盖initialValue方法设置初始值。 public static void main(String[] args) &#123; Thread[] threads=new Thread[3]; for(int i=0;i&lt;3;i++)&#123; threads[i]=() -&gt; &#123; int mun=local.get(); for(int j=0;j&lt;10;j++)&#123; mun=mun+1; &#125; local.set(mun); System.out.println(Thread.currentThread().getName()+\"===\"+local.get()); &#125;; &#125; for(Thread t:threads)&#123; t.start(); &#125; &#125;&#125; 运行结果123Thread-3===10Thread-2===10Thread-1===10 可以看出线程之间互不影响。 实现原理 ThreadLocal中的静态内部类ThreadLocalMap可以看到Entry 类继承了 WeakReference","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"synchronized","date":"2017-05-02T14:13:12.023Z","path":"2017/05/02/synchronized/","text":"synchronized同步方法 方法的变量不存在非线程安全问题，永远都是线程安全的。 实例变量为非线程安全。 多个对象则有多个锁。非静态同步方法的锁为对象锁，当存在多个对象的时候，JVM就会创建多个锁。 锁对象。 所有的非静态同步方法用的都是同一把锁——实例对象本身 也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。 所有的静态同步方法用的也是同一把锁——类对象本身 静态同步方法与非静态同步方法之间是不会有竞态条件的。但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！ 只有共享资源的读写访问需要同步化，如果非共享资源，则根本没有同步化的必要。 A线程先持有对象的Lock锁，B线程可以异步的方式调用该对象的非synchronized方法；A线程先持有对象的Lock锁，B线程此时调用该对象的synchronized方法，则需要等待，也就是同步。 同步不可以继承。要想子类的方法同步，也需要加上synchronized关键字。 出现异常，自动释放锁。当一个线程执行的代码出现异常时，其所持有的锁会自动释放。 锁重入。在一个synchronized方法/块内部调用本类的其他的synchronized方法/块时，是永远可以得到锁的；当存在父子类继承关系时，子类完全可以通过”可重入锁”调用父类的同步方法的。 脏读。生脏读的情况是在读取实例变量时，此值已经被其他线程更改过了，脏读一定发生在操作实例变量的情况下，这就是不同线程“争抢”实例变量的结果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 //测试synchronized类public class PublicVar &#123; public String username=\"A\"; public String password=\"AA\"; synchronized public void setValue(String username,String password)&#123; try &#123; this.username=username; Thread.sleep(1000); this.password=password; System.out.println(\"thread:\"+Thread.currentThread().getName()+ \" username\"+this.username+\" password\"+this.password); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public void getValue()&#123; System.out.println(\"thread:\"+Thread.currentThread().getName()+ \" username\"+this.username+\" password\"+this.password); &#125;&#125;//测试线程public class ThreadA extends Thread &#123; private PublicVar publicVar; public ThreadA(PublicVar publicVar) &#123; super(); this.publicVar = publicVar; &#125; @Override public void run() &#123; super.run(); publicVar.setValue(\"B\",\"BB\"); &#125;&#125;//测试入口public class DrMain &#123; public static void main(String args[])&#123; try &#123; PublicVar publicVar=new PublicVar(); ThreadA threadA=new ThreadA(publicVar); threadA.start(); threadA.sleep(200); publicVar.getValue(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 123结果：thread:main usernameB passwordAA //发生了脏读thread:Thread-0 usernameB passwordBB synchronized同步代码块 synchronized方法是对当前对象加锁，而synchronized同步代码块是对某一个对象进行加锁。 在synchronized同步代码块中的就是同步执行，不在就是异步执行。 静态同步synchronized方法和synchronized(class)代码块的锁都是*.java文件对应的Class类进行持锁。 同步synchronized代码块不使用String作为锁对象，因为String的常量池的影响，而改用其他，比如new Object()实例化对象 参考: JAVA多线程编程核心技术 JAVA编程思想","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"clean-code-js","date":"2017-04-30T03:18:30.969Z","path":"2017/04/30/clean-code-js/","text":"Original Repository: ryanmcdermott/clean-code-javascript JavaScript 风格指南目录 介绍 变量 函数 对象和数据结构 类 测试 并发 错误处理 格式化 注释 介绍作者根据 Robert C. Martin 《代码整洁之道》总结了适用于 JavaScript 的软件工程原则《Clean Code JavaScript》。 本文是对其的翻译。 不必严格遵守本文的所有原则，有时少遵守一些效果可能会更好，具体应根据实际情况决定。这是根据《代码整洁之道》作者多年经验整理的代码优化建议，但也仅仅只是一份建议。 软件工程已经发展了 50 多年，至今仍在不断前进。现在，把这些原则当作试金石，尝试将他们作为团队代码质量考核的标准之一吧。 最后你需要知道的是，这些东西不会让你立刻变成一个优秀的工程师，长期奉行他们也并不意味着你能够高枕无忧不再犯错。千里之行，始于足下。我们需要时常和同行们进行代码评审，不断优化自己的代码。不要惧怕改善代码质量所需付出的努力，加油。 变量使用有意义，可读性好的变量名反例:1var yyyymmdstr = moment().format('YYYY/MM/DD'); 正例:1var yearMonthDay = moment().format('YYYY/MM/DD'); 回到目录 使用 ES6 的 const 定义常量反例中使用”var”定义的”常量”是可变的。 在声明一个常量时，该常量在整个程序中都应该是不可变的。 反例:1var FIRST_US_PRESIDENT = \"George Washington\"; 正例:1const FIRST_US_PRESIDENT = \"George Washington\"; 回到目录 对功能类似的变量名采用统一的命名风格反例:123getUserInfo();getClientData();getCustomerRecord(); 正例:1getUser(); 回到目录 使用易于检索名称我们需要阅读的代码远比自己写的要多，使代码拥有良好的可读性且易于检索非常重要。阅读变量名晦涩难懂的代码对读者来说是一种相当糟糕的体验。让你的变量名易于检索。 反例:1234// 525600 是什么?for (var i = 0; i &lt; 525600; i++) &#123; runCronJob();&#125; 正例:12345// Declare them as capitalized `var` globals.var MINUTES_IN_A_YEAR = 525600;for (var i = 0; i &lt; MINUTES_IN_A_YEAR; i++) &#123; runCronJob();&#125; 回到目录 使用说明变量(即有意义的变量名)反例:12const cityStateRegex = /^(.+)[,\\\\s]+(.+?)\\s*(\\d&#123;5&#125;)?$/;saveCityState(cityStateRegex.match(cityStateRegex)[1], cityStateRegex.match(cityStateRegex)[2]); 正例:12345const cityStateRegex = /^(.+)[,\\\\s]+(.+?)\\s*(\\d&#123;5&#125;)?$/;const match = cityStateRegex.match(cityStateRegex)const city = match[1];const state = match[2];saveCityState(city, state); 回到目录 不要绕太多的弯子显式优于隐式。 反例:12345678910var locations = ['Austin', 'New York', 'San Francisco'];locations.forEach((l) =&gt; &#123; doStuff(); doSomeOtherStuff(); ... ... ... // l是什么？ dispatch(l);&#125;); 正例:123456789var locations = ['Austin', 'New York', 'San Francisco'];locations.forEach((location) =&gt; &#123; doStuff(); doSomeOtherStuff(); ... ... ... dispatch(location);&#125;); 回到目录 避免重复的描述当类/对象名已经有意义时，对其变量进行命名不需要再次重复。 反例:123456789var Car = &#123; carMake: 'Honda', carModel: 'Accord', carColor: 'Blue'&#125;;function paintCar(car) &#123; car.carColor = 'Red';&#125; 正例:123456789var Car = &#123; make: 'Honda', model: 'Accord', color: 'Blue'&#125;;function paintCar(car) &#123; car.color = 'Red';&#125; 回到目录 避免无意义的条件判断反例:12345678function createMicrobrewery(name) &#123; var breweryName; if (name) &#123; breweryName = name; &#125; else &#123; breweryName = 'Hipster Brew Co.'; &#125;&#125; 正例:123function createMicrobrewery(name) &#123; var breweryName = name || 'Hipster Brew Co.'&#125; 回到目录 函数函数参数 (理想情况下应不超过 2 个)限制函数参数数量很有必要，这么做使得在测试函数时更加轻松。过多的参数将导致难以采用有效的测试用例对函数的各个参数进行测试。 应避免三个以上参数的函数。通常情况下，参数超过两个意味着函数功能过于复杂，这时需要重新优化你的函数。当确实需要多个参数时，大多情况下可以考虑这些参数封装成一个对象。 JS 定义对象非常方便，当需要多个参数时，可以使用一个对象进行替代。 反例:123function createMenu(title, body, buttonText, cancellable) &#123; ...&#125; 正例:12345678910var menuConfig = &#123; title: 'Foo', body: 'Bar', buttonText: 'Baz', cancellable: true&#125;function createMenu(menuConfig) &#123; ...&#125; 回到目录 函数功能的单一性这是软件功能中最重要的原则之一。 功能不单一的函数将导致难以重构、测试和理解。功能单一的函数易于重构，并使代码更加干净。 反例:12345678function emailClients(clients) &#123; clients.forEach(client =&gt; &#123; let clientRecord = database.lookup(client); if (clientRecord.isActive()) &#123; email(client); &#125; &#125;);&#125; 正例:12345678910111213141516function emailClients(clients) &#123; clients.forEach(client =&gt; &#123; emailClientIfNeeded(client); &#125;);&#125;function emailClientIfNeeded(client) &#123; if (isClientActive(client)) &#123; email(client); &#125;&#125;function isClientActive(client) &#123; let clientRecord = database.lookup(client); return clientRecord.isActive();&#125; 回到目录 函数名应明确表明其功能反例:1234567function dateAdd(date, month) &#123; // ...&#125;let date = new Date();// 很难理解dateAdd(date, 1)是什么意思 正例:123456function dateAddMonth(date, month) &#123; // ...&#125;let date = new Date();dateAddMonth(date, 1); 回到目录 函数应该只做一层抽象当函数的需要的抽象多于一层时通常意味着函数功能过于复杂，需将其进行分解以提高其可重用性和可测试性。 反例:12345678910111213141516171819202122function parseBetterJSAlternative(code) &#123; let REGEXES = [ // ... ]; let statements = code.split(' '); let tokens; REGEXES.forEach((REGEX) =&gt; &#123; statements.forEach((statement) =&gt; &#123; // ... &#125;) &#125;); let ast; tokens.forEach((token) =&gt; &#123; // lex... &#125;); ast.forEach((node) =&gt; &#123; // parse... &#125;)&#125; 正例:1234567891011121314151617181920212223242526272829303132function tokenize(code) &#123; let REGEXES = [ // ... ]; let statements = code.split(' '); let tokens; REGEXES.forEach((REGEX) =&gt; &#123; statements.forEach((statement) =&gt; &#123; // ... &#125;) &#125;); return tokens;&#125;function lexer(tokens) &#123; let ast; tokens.forEach((token) =&gt; &#123; // lex... &#125;); return ast;&#125;function parseBetterJSAlternative(code) &#123; let tokens = tokenize(code); let ast = lexer(tokens); ast.forEach((node) =&gt; &#123; // parse... &#125;)&#125; 回到目录 移除重复的代码永远、永远、永远不要在任何循环下有重复的代码。 这种做法毫无意义且潜在危险极大。重复的代码意味着逻辑变化时需要对不止一处进行修改。JS 弱类型的特点使得函数拥有更强的普适性。好好利用这一优点吧。 反例:1234567891011121314151617181920212223242526272829function showDeveloperList(developers) &#123; developers.forEach(developer =&gt; &#123; var expectedSalary = developer.calculateExpectedSalary(); var experience = developer.getExperience(); var githubLink = developer.getGithubLink(); var data = &#123; expectedSalary: expectedSalary, experience: experience, githubLink: githubLink &#125;; render(data); &#125;);&#125;function showManagerList(managers) &#123; managers.forEach(manager =&gt; &#123; var expectedSalary = manager.calculateExpectedSalary(); var experience = manager.getExperience(); var portfolio = manager.getMBAProjects(); var data = &#123; expectedSalary: expectedSalary, experience: experience, portfolio: portfolio &#125;; render(data); &#125;);&#125; 正例:123456789101112131415161718192021function showList(employees) &#123; employees.forEach(employee =&gt; &#123; var expectedSalary = employee.calculateExpectedSalary(); var experience = employee.getExperience(); var portfolio; if (employee.type === 'manager') &#123; portfolio = employee.getMBAProjects(); &#125; else &#123; portfolio = employee.getGithubLink(); &#125; var data = &#123; expectedSalary: expectedSalary, experience: experience, portfolio: portfolio &#125;; render(data); &#125;);&#125; 回到目录 采用默认参数精简代码反例:1234function writeForumComment(subject, body) &#123; subject = subject || 'No Subject'; body = body || 'No text';&#125; 正例:123function writeForumComment(subject = 'No subject', body = 'No text') &#123; ...&#125; 回到目录 使用 Object.assign 设置默认对象反例:12345678910111213141516var menuConfig = &#123; title: null, body: 'Bar', buttonText: null, cancellable: true&#125;function createMenu(config) &#123; config.title = config.title || 'Foo' config.body = config.body || 'Bar' config.buttonText = config.buttonText || 'Baz' config.cancellable = config.cancellable === undefined ? config.cancellable : true;&#125;createMenu(menuConfig); 正例:1234567891011121314151617181920var menuConfig = &#123; title: 'Order', // User did not include 'body' key buttonText: 'Send', cancellable: true&#125;function createMenu(config) &#123; config = Object.assign(&#123; title: 'Foo', body: 'Bar', buttonText: 'Baz', cancellable: true &#125;, config); // config now equals: &#123;title: \"Order\", body: \"Bar\", buttonText: \"Send\", cancellable: true&#125; // ...&#125;createMenu(menuConfig); 回到目录 不要使用标记(Flag)作为函数参数这通常意味着函数的功能的单一性已经被破坏。此时应考虑对函数进行再次划分。 反例:1234567function createFile(name, temp) &#123; if (temp) &#123; fs.create('./temp/' + name); &#125; else &#123; fs.create(name); &#125;&#125; 正例:12345678910function createTempFile(name) &#123; fs.create('./temp/' + name);&#125;----------function createFile(name) &#123; fs.create(name);&#125; 回到目录 避免副作用当函数产生了除了“接受一个值并返回一个结果”之外的行为时，称该函数产生了副作用。比如写文件、修改全局变量或将你的钱全转给了一个陌生人等。 程序在某些情况下确实需要副作用这一行为，如先前例子中的写文件。这时应该将这些功能集中在一起，不要用多个函数/类修改某个文件。用且只用一个 service 完成这一需求。 反例:1234567891011// Global variable referenced by following function.// If we had another function that used this name, now it'd be an array and it could break it.var name = 'Ryan McDermott';function splitIntoFirstAndLastName() &#123; name = name.split(' ');&#125;splitIntoFirstAndLastName();console.log(name); // ['Ryan', 'McDermott']; 正例:123456789function splitIntoFirstAndLastName(name) &#123; return name.split(' ');&#125;var name = 'Ryan McDermott'var newName = splitIntoFirstAndLastName(name);console.log(name); // 'Ryan McDermott';console.log(newName); // ['Ryan', 'McDermott']; 回到目录 不要写全局函数在 JS 中污染全局是一个非常不好的实践，这么做可能和其他库起冲突，且调用你的 API 的用户在实际环境中得到一个 exception 前对这一情况是一无所知的。 想象以下例子：如果你想扩展 JS 中的 Array，为其添加一个 diff 函数显示两个数组间的差异，此时应如何去做？你可以将 diff 写入 Array.prototype，但这么做会和其他有类似需求的库造成冲突。如果另一个库对 diff 的需求为比较一个数组中首尾元素间的差异呢？ 使用 ES6 中的 class 对全局的 Array 做简单的扩展显然是一个更棒的选择。 反例:12345678910111213141516Array.prototype.diff = function(comparisonArray) &#123; var values = []; var hash = &#123;&#125;; for (var i of comparisonArray) &#123; hash[i] = true; &#125; for (var i of this) &#123; if (!hash[i]) &#123; values.push(i); &#125; &#125; return values;&#125; 正例:12345678910111213141516171819202122class SuperArray extends Array &#123; constructor(...args) &#123; super(...args); &#125; diff(comparisonArray) &#123; var values = []; var hash = &#123;&#125;; for (var i of comparisonArray) &#123; hash[i] = true; &#125; for (var i of this) &#123; if (!hash[i]) &#123; values.push(i); &#125; &#125; return values; &#125;&#125; 回到目录 采用函数式编程函数式的编程具有更干净且便于测试的特点。尽可能的使用这种风格吧。 反例:123456789101112131415161718192021const programmerOutput = [ &#123; name: 'Uncle Bobby', linesOfCode: 500 &#125;, &#123; name: 'Suzie Q', linesOfCode: 1500 &#125;, &#123; name: 'Jimmy Gosling', linesOfCode: 150 &#125;, &#123; name: 'Gracie Hopper', linesOfCode: 1000 &#125;];var totalOutput = 0;for (var i = 0; i &lt; programmerOutput.length; i++) &#123; totalOutput += programmerOutput[i].linesOfCode;&#125; 正例:12345678910111213141516171819const programmerOutput = [ &#123; name: 'Uncle Bobby', linesOfCode: 500 &#125;, &#123; name: 'Suzie Q', linesOfCode: 1500 &#125;, &#123; name: 'Jimmy Gosling', linesOfCode: 150 &#125;, &#123; name: 'Gracie Hopper', linesOfCode: 1000 &#125;];var totalOutput = programmerOutput .map((programmer) =&gt; programmer.linesOfCode) .reduce((acc, linesOfCode) =&gt; acc + linesOfCode, 0); 回到目录 封装判断条件反例:123if (fsm.state === 'fetching' &amp;&amp; isEmpty(listNode)) &#123; /// ...&#125; 正例:1234567function shouldShowSpinner(fsm, listNode) &#123; return fsm.state === 'fetching' &amp;&amp; isEmpty(listNode);&#125;if (shouldShowSpinner(fsmInstance, listNodeInstance)) &#123; // ...&#125; 回到目录 避免“否定情况”的判断反例:1234567function isDOMNodeNotPresent(node) &#123; // ...&#125;if (!isDOMNodeNotPresent(node)) &#123; // ...&#125; 正例:1234567function isDOMNodePresent(node) &#123; // ...&#125;if (isDOMNodePresent(node)) &#123; // ...&#125; 回到目录 避免条件判断这看起来似乎不太可能。 大多人听到这的第一反应是：“怎么可能不用 if 完成其他功能呢？”许多情况下通过使用多态(polymorphism)可以达到同样的目的。 第二个问题在于采用这种方式的原因是什么。答案是我们之前提到过的：保持函数功能的单一性。 反例:12345678910111213class Airplane &#123; //... getCruisingAltitude() &#123; switch (this.type) &#123; case '777': return getMaxAltitude() - getPassengerCount(); case 'Air Force One': return getMaxAltitude(); case 'Cessna': return getMaxAltitude() - getFuelExpenditure(); &#125; &#125;&#125; 正例:123456789101112131415161718192021222324class Airplane &#123; //...&#125;class Boeing777 extends Airplane &#123; //... getCruisingAltitude() &#123; return getMaxAltitude() - getPassengerCount(); &#125;&#125;class AirForceOne extends Airplane &#123; //... getCruisingAltitude() &#123; return getMaxAltitude(); &#125;&#125;class Cessna extends Airplane &#123; //... getCruisingAltitude() &#123; return getMaxAltitude() - getFuelExpenditure(); &#125;&#125; 回到目录 避免类型判断(part 1)JS 是弱类型语言，这意味着函数可接受任意类型的参数。 有时这会对你带来麻烦，你会对参数做一些类型判断。有许多方法可以避免这些情况。 反例:1234567function travelToTexas(vehicle) &#123; if (vehicle instanceof Bicycle) &#123; vehicle.peddle(this.currentLocation, new Location('texas')); &#125; else if (vehicle instanceof Car) &#123; vehicle.drive(this.currentLocation, new Location('texas')); &#125;&#125; 正例:123function travelToTexas(vehicle) &#123; vehicle.move(this.currentLocation, new Location('texas'));&#125; 回到目录 避免类型判断(part 2)如果需处理的数据为字符串，整型，数组等类型，无法使用多态并仍有必要对其进行类型检测时，可以考虑使用 TypeScript。 反例:12345678function combine(val1, val2) &#123; if (typeof val1 == \"number\" &amp;&amp; typeof val2 == \"number\" || typeof val1 == \"string\" &amp;&amp; typeof val2 == \"string\") &#123; return val1 + val2; &#125; else &#123; throw new Error('Must be of type String or Number'); &#125;&#125; 正例:123function combine(val1, val2) &#123; return val1 + val2;&#125; 回到目录 避免过度优化现代的浏览器在运行时会对代码自动进行优化。有时人为对代码进行优化可能是在浪费时间。 这里可以找到许多真正需要优化的地方 反例:1234567// 这里使用变量len是因为在老式浏览器中，// 直接使用正例中的方式会导致每次循环均重复计算list.length的值，// 而在现代浏览器中会自动完成优化，这一行为是没有必要的for (var i = 0, len = list.length; i &lt; len; i++) &#123; // ...&#125; 正例:123for (var i = 0; i &lt; list.length; i++) &#123; // ...&#125; 回到目录 删除无效的代码不再被调用的代码应及时删除。 反例:12345678910function oldRequestModule(url) &#123; // ...&#125;function newRequestModule(url) &#123; // ...&#125;var req = newRequestModule;inventoryTracker('apples', req, 'www.inventory-awesome.io'); 正例:123456function newRequestModule(url) &#123; // ...&#125;var req = newRequestModule;inventoryTracker('apples', req, 'www.inventory-awesome.io'); 回到目录 对象和数据结构使用 getters 和 settersJS 没有接口或类型，因此实现这一模式是很困难的，因为我们并没有类似 public 和 private 的关键词。 然而，使用 getters 和 setters 获取对象的数据远比直接使用点操作符具有优势。为什么呢？ 当需要对获取的对象属性执行额外操作时。 执行 set 时可以增加规则对要变量的合法性进行判断。 封装了内部逻辑。 在存取时可以方便的增加日志和错误处理。 继承该类时可以重载默认行为。 从服务器获取数据时可以进行懒加载。 反例:12345678910class BankAccount &#123; constructor() &#123; this.balance = 1000; &#125;&#125;let bankAccount = new BankAccount();// Buy shoes...bankAccount.balance = bankAccount.balance - 100; 正例:1234567891011121314151617class BankAccount &#123; constructor() &#123; this.balance = 1000; &#125; // It doesn't have to be prefixed with `get` or `set` to be a getter/setter withdraw(amount) &#123; if (verifyAmountCanBeDeducted(amount)) &#123; this.balance -= amount; &#125; &#125;&#125;let bankAccount = new BankAccount();// Buy shoes...bankAccount.withdraw(100); 回到目录 让对象拥有私有成员可以通过闭包完成 反例:12345678910111213var Employee = function(name) &#123; this.name = name;&#125;Employee.prototype.getName = function() &#123; return this.name;&#125;var employee = new Employee('John Doe');console.log('Employee name: ' + employee.getName()); // Employee name: John Doedelete employee.name;console.log('Employee name: ' + employee.getName()); // Employee name: undefined 正例:1234567891011121314var Employee = (function() &#123; function Employee(name) &#123; this.getName = function() &#123; return name; &#125;; &#125; return Employee;&#125;());var employee = new Employee('John Doe');console.log('Employee name: ' + employee.getName()); // Employee name: John Doedelete employee.name;console.log('Employee name: ' + employee.getName()); // Employee name: John Doe 回到目录 类单一职责原则 (SRP)如《代码整洁之道》一书中所述，“修改一个类的理由不应该超过一个”。 将多个功能塞进一个类的想法很诱人，但这将导致你的类无法达到概念上的内聚，并经常不得不进行修改。 最小化对一个类需要修改的次数是非常有必要的。如果一个类具有太多太杂的功能，当你对其中一小部分进行修改时，将很难想象到这一修够对代码库中依赖该类的其他模块会带来什么样的影响。 反例:123456789101112131415class UserSettings &#123; constructor(user) &#123; this.user = user; &#125; changeSettings(settings) &#123; if (this.verifyCredentials(user)) &#123; // ... &#125; &#125; verifyCredentials(user) &#123; // ... &#125;&#125; 正例:1234567891011121314151617181920212223class UserAuth &#123; constructor(user) &#123; this.user = user; &#125; verifyCredentials() &#123; // ... &#125;&#125;class UserSettings &#123; constructor(user) &#123; this.user = user; this.auth = new UserAuth(user) &#125; changeSettings(settings) &#123; if (this.auth.verifyCredentials()) &#123; // ... &#125; &#125;&#125; 回到目录 开/闭原则 (OCP)“代码实体(类，模块，函数等)应该易于扩展，难于修改。” 这一原则指的是我们应允许用户方便的扩展我们代码模块的功能，而不需要打开 js 文件源码手动对其进行修改。 反例:123456789101112class AjaxRequester &#123; constructor() &#123; // What if we wanted another HTTP Method, like DELETE? We would have to // open this file up and modify this and put it in manually. this.HTTP_METHODS = ['POST', 'PUT', 'GET']; &#125; get(url) &#123; // ... &#125;&#125; 正例:12345678910111213class AjaxRequester &#123; constructor() &#123; this.HTTP_METHODS = ['POST', 'PUT', 'GET']; &#125; get(url) &#123; // ... &#125; addHTTPMethod(method) &#123; this.HTTP_METHODS.push(method); &#125;&#125; 回到目录 利斯科夫替代原则 (LSP)“子类对象应该能够替换其超类对象被使用”。 也就是说，如果有一个父类和一个子类，当采用子类替换父类时不应该产生错误的结果。 反例:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Rectangle &#123; constructor() &#123; this.width = 0; this.height = 0; &#125; setColor(color) &#123; // ... &#125; render(area) &#123; // ... &#125; setWidth(width) &#123; this.width = width; &#125; setHeight(height) &#123; this.height = height; &#125; getArea() &#123; return this.width * this.height; &#125;&#125;class Square extends Rectangle &#123; constructor() &#123; super(); &#125; setWidth(width) &#123; this.width = width; this.height = width; &#125; setHeight(height) &#123; this.width = height; this.height = height; &#125;&#125;function renderLargeRectangles(rectangles) &#123; rectangles.forEach((rectangle) =&gt; &#123; rectangle.setWidth(4); rectangle.setHeight(5); let area = rectangle.getArea(); // BAD: Will return 25 for Square. Should be 20. rectangle.render(area); &#125;)&#125;let rectangles = [new Rectangle(), new Rectangle(), new Square()];renderLargeRectangles(rectangles); 正例:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Shape &#123; constructor() &#123;&#125; setColor(color) &#123; // ... &#125; render(area) &#123; // ... &#125;&#125;class Rectangle extends Shape &#123; constructor() &#123; super(); this.width = 0; this.height = 0; &#125; setWidth(width) &#123; this.width = width; &#125; setHeight(height) &#123; this.height = height; &#125; getArea() &#123; return this.width * this.height; &#125;&#125;class Square extends Shape &#123; constructor() &#123; super(); this.length = 0; &#125; setLength(length) &#123; this.length = length; &#125; getArea() &#123; return this.length * this.length; &#125;&#125;function renderLargeShapes(shapes) &#123; shapes.forEach((shape) =&gt; &#123; switch (shape.constructor.name) &#123; case 'Square': shape.setLength(5); case 'Rectangle': shape.setWidth(4); shape.setHeight(5); &#125; let area = shape.getArea(); shape.render(area); &#125;)&#125;let shapes = [new Rectangle(), new Rectangle(), new Square()];renderLargeShapes(shapes); 回到目录 接口隔离原则 (ISP)“客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。” 在 JS 中，当一个类需要许多参数设置才能生成一个对象时，或许大多时候不需要设置这么多的参数。此时减少对配置参数数量的需求是有益的。 反例:123456789101112131415161718192021class DOMTraverser &#123; constructor(settings) &#123; this.settings = settings; this.setup(); &#125; setup() &#123; this.rootNode = this.settings.rootNode; this.animationModule.setup(); &#125; traverse() &#123; // ... &#125;&#125;let $ = new DOMTraverser(&#123; rootNode: document.getElementsByTagName('body'), animationModule: function() &#123;&#125; // Most of the time, we won't need to animate when traversing. // ...&#125;); 正例:1234567891011121314151617181920212223242526272829class DOMTraverser &#123; constructor(settings) &#123; this.settings = settings; this.options = settings.options; this.setup(); &#125; setup() &#123; this.rootNode = this.settings.rootNode; this.setupOptions(); &#125; setupOptions() &#123; if (this.options.animationModule) &#123; // ... &#125; &#125; traverse() &#123; // ... &#125;&#125;let $ = new DOMTraverser(&#123; rootNode: document.getElementsByTagName('body'), options: &#123; animationModule: function() &#123;&#125; &#125;&#125;); 回到目录 依赖反转原则 (DIP)该原则有两个核心点： 高层模块不应该依赖于低层模块。他们都应该依赖于抽象接口。 抽象接口应该脱离具体实现，具体实现应该依赖于抽象接口。 反例:12345678910111213141516171819202122232425262728class InventoryTracker &#123; constructor(items) &#123; this.items = items; // BAD: We have created a dependency on a specific request implementation. // We should just have requestItems depend on a request method: `request` this.requester = new InventoryRequester(); &#125; requestItems() &#123; this.items.forEach((item) =&gt; &#123; this.requester.requestItem(item); &#125;); &#125;&#125;class InventoryRequester &#123; constructor() &#123; this.REQ_METHODS = ['HTTP']; &#125; requestItem(item) &#123; // ... &#125;&#125;let inventoryTracker = new InventoryTracker(['apples', 'bananas']);inventoryTracker.requestItems(); 正例:12345678910111213141516171819202122232425262728293031323334353637class InventoryTracker &#123; constructor(items, requester) &#123; this.items = items; this.requester = requester; &#125; requestItems() &#123; this.items.forEach((item) =&gt; &#123; this.requester.requestItem(item); &#125;); &#125;&#125;class InventoryRequesterV1 &#123; constructor() &#123; this.REQ_METHODS = ['HTTP']; &#125; requestItem(item) &#123; // ... &#125;&#125;class InventoryRequesterV2 &#123; constructor() &#123; this.REQ_METHODS = ['WS']; &#125; requestItem(item) &#123; // ... &#125;&#125;// By constructing our dependencies externally and injecting them, we can easily// substitute our request module for a fancy new one that uses WebSockets.let inventoryTracker = new InventoryTracker(['apples', 'bananas'], new InventoryRequesterV2());inventoryTracker.requestItems(); 回到目录 使用 ES6 的 classes 而不是 ES5 的 Function典型的 ES5 的类(function)在继承、构造和方法定义方面可读性较差。 当需要继承时，优先选用 classes。 但是，当在需要更大更复杂的对象时，最好优先选择更小的 function 而非 classes。 反例:1234567891011121314151617181920212223242526272829303132333435var Animal = function(age) &#123; if (!(this instanceof Animal)) &#123; throw new Error(\"Instantiate Animal with `new`\"); &#125; this.age = age;&#125;;Animal.prototype.move = function() &#123;&#125;;var Mammal = function(age, furColor) &#123; if (!(this instanceof Mammal)) &#123; throw new Error(\"Instantiate Mammal with `new`\"); &#125; Animal.call(this, age); this.furColor = furColor;&#125;;Mammal.prototype = Object.create(Animal.prototype);Mammal.prototype.constructor = Mammal;Mammal.prototype.liveBirth = function() &#123;&#125;;var Human = function(age, furColor, languageSpoken) &#123; if (!(this instanceof Human)) &#123; throw new Error(\"Instantiate Human with `new`\"); &#125; Mammal.call(this, age, furColor); this.languageSpoken = languageSpoken;&#125;;Human.prototype = Object.create(Mammal.prototype);Human.prototype.constructor = Human;Human.prototype.speak = function() &#123;&#125;; 正例:12345678910111213141516171819202122232425class Animal &#123; constructor(age) &#123; this.age = age; &#125; move() &#123;&#125;&#125;class Mammal extends Animal &#123; constructor(age, furColor) &#123; super(age); this.furColor = furColor; &#125; liveBirth() &#123;&#125;&#125;class Human extends Mammal &#123; constructor(age, furColor, languageSpoken) &#123; super(age, furColor); this.languageSpoken = languageSpoken; &#125; speak() &#123;&#125;&#125; 回到目录 使用方法链这里我们的理解与《代码整洁之道》的建议有些不同。 有争论说方法链不够干净且违反了德米特法则，也许这是对的，但这种方法在 JS 及许多库(如 JQuery)中显得非常实用。 因此，我认为在 JS 中使用方法链是非常合适的。在 class 的函数中返回 this，能够方便的将类需要执行的多个方法链接起来。 反例:1234567891011121314151617181920212223242526272829class Car &#123; constructor() &#123; this.make = 'Honda'; this.model = 'Accord'; this.color = 'white'; &#125; setMake(make) &#123; this.name = name; &#125; setModel(model) &#123; this.model = model; &#125; setColor(color) &#123; this.color = color; &#125; save() &#123; console.log(this.make, this.model, this.color); &#125;&#125;let car = new Car();car.setColor('pink');car.setMake('Ford');car.setModel('F-150')car.save(); 正例:1234567891011121314151617181920212223242526272829303132333435class Car &#123; constructor() &#123; this.make = 'Honda'; this.model = 'Accord'; this.color = 'white'; &#125; setMake(make) &#123; this.name = name; // NOTE: Returning this for chaining return this; &#125; setModel(model) &#123; this.model = model; // NOTE: Returning this for chaining return this; &#125; setColor(color) &#123; this.color = color; // NOTE: Returning this for chaining return this; &#125; save() &#123; console.log(this.make, this.model, this.color); &#125;&#125;let car = new Car() .setColor('pink') .setMake('Ford') .setModel('F-150') .save(); 回到目录 优先使用组合模式而非继承在著名的设计模式一书中提到，应多使用组合模式而非继承。 这么做有许多优点，在想要使用继承前，多想想能否通过组合模式满足需求吧。 那么，在什么时候继承具有更大的优势呢？这取决于你的具体需求，但大多情况下，可以遵守以下三点： 继承关系表现为”是一个”而非”有一个”(如动物-&gt;人 和 用户-&gt;用户细节) 可以复用基类的代码(“Human”可以看成是”All animal”的一种) 希望当基类改变时所有派生类都受到影响(如修改”all animals”移动时的卡路里消耗量) 反例:12345678910111213141516171819class Employee &#123; constructor(name, email) &#123; this.name = name; this.email = email; &#125; // ...&#125;// Bad because Employees \"have\" tax data. EmployeeTaxData is not a type of Employeeclass EmployeeTaxData extends Employee &#123; constructor(ssn, salary) &#123; super(); this.ssn = ssn; this.salary = salary; &#125; // ...&#125; 正例:123456789101112131415161718192021class Employee &#123; constructor(name, email) &#123; this.name = name; this.email = email; &#125; setTaxData(ssn, salary) &#123; this.taxData = new EmployeeTaxData(ssn, salary); &#125; // ...&#125;class EmployeeTaxData &#123; constructor(ssn, salary) &#123; this.ssn = ssn; this.salary = salary; &#125; // ...&#125; 回到目录 测试一些好的覆盖工具。 一些好的 JS 测试框架。 单一的测试每个概念反例:12345678910111213141516171819const assert = require('assert');describe('MakeMomentJSGreatAgain', function() &#123; it('handles date boundaries', function() &#123; let date; date = new MakeMomentJSGreatAgain('1/1/2015'); date.addDays(30); date.shouldEqual('1/31/2015'); date = new MakeMomentJSGreatAgain('2/1/2016'); date.addDays(28); assert.equal('02/29/2016', date); date = new MakeMomentJSGreatAgain('2/1/2015'); date.addDays(28); assert.equal('03/01/2015', date); &#125;);&#125;); 正例:123456789101112131415161718192021const assert = require('assert');describe('MakeMomentJSGreatAgain', function() &#123; it('handles 30-day months', function() &#123; let date = new MakeMomentJSGreatAgain('1/1/2015'); date.addDays(30); date.shouldEqual('1/31/2015'); &#125;); it('handles leap year', function() &#123; let date = new MakeMomentJSGreatAgain('2/1/2016'); date.addDays(28); assert.equal('02/29/2016', date); &#125;); it('handles non-leap year', function() &#123; let date = new MakeMomentJSGreatAgain('2/1/2015'); date.addDays(28); assert.equal('03/01/2015', date); &#125;);&#125;); 回到目录 并发用 Promises 替代回调回调不够整洁并会造成大量的嵌套。ES6 内嵌了 Promises，使用它吧。 反例:1234567891011121314require('request').get('https://en.wikipedia.org/wiki/Robert_Cecil_Martin', function(err, response) &#123; if (err) &#123; console.error(err); &#125; else &#123; require('fs').writeFile('article.html', response.body, function(err) &#123; if (err) &#123; console.error(err); &#125; else &#123; console.log('File written'); &#125; &#125;) &#125;&#125;) 正例:12345678910require('request-promise').get('https://en.wikipedia.org/wiki/Robert_Cecil_Martin') .then(function(response) &#123; return require('fs-promise').writeFile('article.html', response); &#125;) .then(function() &#123; console.log('File written'); &#125;) .catch(function(err) &#123; console.error(err); &#125;) 回到目录 Async/Await 是较 Promises 更好的选择Promises 是较回调而言更好的一种选择，但 ES7 中的 async 和 await 更胜过 Promises。 在能使用 ES7 特性的情况下可以尽量使用他们替代 Promises。 反例:12345678910require('request-promise').get('https://en.wikipedia.org/wiki/Robert_Cecil_Martin') .then(function(response) &#123; return require('fs-promise').writeFile('article.html', response); &#125;) .then(function() &#123; console.log('File written'); &#125;) .catch(function(err) &#123; console.error(err); &#125;) 正例:123456789101112async function getCleanCodeArticle() &#123; try &#123; var request = await require('request-promise') var response = await request.get('https://en.wikipedia.org/wiki/Robert_Cecil_Martin'); var fileHandle = await require('fs-promise'); await fileHandle.writeFile('article.html', response); console.log('File written'); &#125; catch(err) &#123; console.log(err); &#125;&#125; 回到目录 错误处理错误抛出是个好东西！这使得你能够成功定位运行状态中的程序产生错误的位置。 别忘了捕获错误对捕获的错误不做任何处理是没有意义的。 代码中 try/catch 的意味着你认为这里可能出现一些错误，你应该对这些可能的错误存在相应的处理方案。 反例:12345try &#123; functionThatMightThrow();&#125; catch (error) &#123; console.log(error);&#125; 正例:1234567891011try &#123; functionThatMightThrow();&#125; catch (error) &#123; // One option (more noisy than console.log): console.error(error); // Another option: notifyUserOfError(error); // Another option: reportErrorToService(error); // OR do all three!&#125; 不要忽略被拒绝的 promises理由同 try/catch。 反例:1234567getdata().then(data =&gt; &#123; functionThatMightThrow(data);&#125;).catch(error =&gt; &#123; console.log(error);&#125;); 正例:12345678910111213getdata().then(data =&gt; &#123; functionThatMightThrow(data);&#125;).catch(error =&gt; &#123; // One option (more noisy than console.log): console.error(error); // Another option: notifyUserOfError(error); // Another option: reportErrorToService(error); // OR do all three!&#125;); 回到目录 格式化格式化是一件主观的事。如同这里的许多规则一样，这里并没有一定/立刻需要遵守的规则。可以在这里完成格式的自动化。 大小写一致JS 是弱类型语言，合理的采用大小写可以告诉你关于变量/函数等的许多消息。 这些规则是主观定义的，团队可以根据喜欢进行选择。重点在于无论选择何种风格，都需要注意保持一致性。 反例:1234567891011var DAYS_IN_WEEK = 7;var daysInMonth = 30;var songs = ['Back In Black', 'Stairway to Heaven', 'Hey Jude'];var Artists = ['ACDC', 'Led Zeppelin', 'The Beatles'];function eraseDatabase() &#123;&#125;function restore_database() &#123;&#125;class animal &#123;&#125;class Alpaca &#123;&#125; 正例:1234567891011var DAYS_IN_WEEK = 7;var DAYS_IN_MONTH = 30;var songs = ['Back In Black', 'Stairway to Heaven', 'Hey Jude'];var artists = ['ACDC', 'Led Zeppelin', 'The Beatles'];function eraseDatabase() &#123;&#125;function restoreDatabase() &#123;&#125;class Animal &#123;&#125;class Alpaca &#123;&#125; 回到目录 调用函数的函数和被调函数应放在较近的位置当函数间存在相互调用的情况时，应将两者置于较近的位置。 理想情况下，应将调用其他函数的函数写在被调用函数的上方。 反例:1234567891011121314151617181920212223242526272829303132333435class PerformanceReview &#123; constructor(employee) &#123; this.employee = employee; &#125; lookupPeers() &#123; return db.lookup(this.employee, 'peers'); &#125; lookupMananger() &#123; return db.lookup(this.employee, 'manager'); &#125; getPeerReviews() &#123; let peers = this.lookupPeers(); // ... &#125; perfReview() &#123; getPeerReviews(); getManagerReview(); getSelfReview(); &#125; getManagerReview() &#123; let manager = this.lookupManager(); &#125; getSelfReview() &#123; // ... &#125;&#125;let review = new PerformanceReview(user);review.perfReview(); 正例:1234567891011121314151617181920212223242526272829303132333435class PerformanceReview &#123; constructor(employee) &#123; this.employee = employee; &#125; perfReview() &#123; getPeerReviews(); getManagerReview(); getSelfReview(); &#125; getPeerReviews() &#123; let peers = this.lookupPeers(); // ... &#125; lookupPeers() &#123; return db.lookup(this.employee, 'peers'); &#125; getManagerReview() &#123; let manager = this.lookupManager(); &#125; lookupMananger() &#123; return db.lookup(this.employee, 'manager'); &#125; getSelfReview() &#123; // ... &#125;&#125;let review = new PerformanceReview(employee);review.perfReview(); 回到目录 注释只对存在一定业务逻辑复杂性的代码进行注释注释并不是必须的，好的代码是能够让人一目了然，不用过多无谓的注释。 反例:1234567891011121314151617function hashIt(data) &#123; // The hash var hash = 0; // Length of string var length = data.length; // Loop through every character in data for (var i = 0; i &lt; length; i++) &#123; // Get character code. var char = data.charCodeAt(i); // Make the hash hash = ((hash &lt;&lt; 5) - hash) + char; // Convert to 32-bit integer hash = hash &amp; hash; &#125;&#125; 正例:12345678910111213function hashIt(data) &#123; var hash = 0; var length = data.length; for (var i = 0; i &lt; length; i++) &#123; var char = data.charCodeAt(i); hash = ((hash &lt;&lt; 5) - hash) + char; // Convert to 32-bit integer hash = hash &amp; hash; &#125;&#125; 回到目录 不要在代码库中遗留被注释掉的代码版本控制的存在是有原因的。让旧代码存在于你的 history 里吧。 反例:1234doStuff();// doOtherStuff();// doSomeMoreStuff();// doSoMuchStuff(); 正例:1doStuff(); 回到目录 不需要版本更新类型注释记住，我们可以使用版本控制。废代码、被注释的代码及用注释记录代码中的版本更新说明都是没有必要的。 需要时可以使用 git log 获取历史版本。 反例:123456789/** * 2016-12-20: Removed monads, didn't understand them (RM) * 2016-10-01: Improved using special monads (JP) * 2016-02-03: Removed type-checking (LI) * 2015-03-14: Added combine with type-checking (JR) */function combine(a, b) &#123; return a + b;&#125; 正例:123function combine(a, b) &#123; return a + b;&#125; 回到目录 避免位置标记这些东西通常只能代码麻烦，采用适当的缩进就可以了。 反例:1234567891011121314////////////////////////////////////////////////////////////////////////////////// Scope Model Instantiation////////////////////////////////////////////////////////////////////////////////let $scope.model = &#123; menu: 'foo', nav: 'bar'&#125;;////////////////////////////////////////////////////////////////////////////////// Action setup////////////////////////////////////////////////////////////////////////////////let actions = function() &#123; // ...&#125; 正例:12345678let $scope.model = &#123; menu: 'foo', nav: 'bar'&#125;;let actions = function() &#123; // ...&#125; 回到目录 避免在源文件中写入法律评论将你的 LICENSE 文件置于源码目录树的根目录。 反例:123456789101112131415161718192021222324252627/*The MIT License (MIT)Copyright (c) 2016 Ryan McDermottPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the \"Software\"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in allcopies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THESOFTWARE*/function calculateBill() &#123; // ...&#125; 正例:123function calculateBill() &#123; // ...&#125; 回到目录","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"HTTP状态码","date":"2017-04-09T12:36:27.352Z","path":"2017/04/09/HTTP状态码/","text":"HTTP状态码 100 请求者应继续进行请求。服务器返回此代码以表示，服务器已收到某项请求的第一部分，正等待接收剩余部分。 101 请求者已要求服务器切换协议，服务器已确认并准备切换。 200 服务器已成功处理相应请求。通常，这表示服务器提供了请求的网页。如果您的 robots.txt 文件显示为此状态，则表示 Googlebot 已成功检索到该文件。 201 请求成功且服务器创建了新的资源。 202 服务器已接受相应请求，但尚未对其进行处理。 203 服务器已成功处理相应请求，但返回了可能来自另一来源的信息。 204 服务器已成功处理相应请求，但未返回任何内容。 205 服务器已成功处理相应请求，但未返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如清除表单内容以输入新内容） 206 服务器成功处理了部分 GET 请求。 300 服务器可以根据请求来执行多项操作，例如：按照请求者（用户代理）的要求来选择某项操作或者展示列表以便请求者选择其中某项操作。 301 请求的网页已被永久迁移至新位置。服务器返回此响应（作为对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码通知 Googlebot 某个网页或网站已被永久迁移至新位置。 302 服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置。但由于 Googlebot 会继续抓取原有位置并将其编入索引，因此您不应使用此代码来通知 Googlebot 某个页面或网站已被迁移。 303 当请求者应对不同的位置进行单独的 GET 请求以检索响应时，服务器会返回此代码。对于除 HEAD 请求之外的所有请求，服务器会自动转到其他位置。 304 请求的网页自上次请求后再也没有修改过。当服务器返回此响应时，不会返回相关网页的内容。如果网页自请求者上次请求后再也没有更改过，您应当将服务器配置为返回此响应（称为 If Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。 305 请求者只能使用代理访问请求的网页。如果服务器返回此响应，那么服务器还会指明请求者应当使用的代理。 307 服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置。但由于 Googlebot 会继续抓取原有位置并将其编入索引，因此您不应使用此代码来通知 Googlebot 某个页面或网站已被迁移。 400 服务器不理解请求的语法。 401 请求要求进行身份验证。登录后，服务器可能会返回对页面的此响应。 403 服务器正在拒绝相应请求。如果 Googlebot 在尝试抓取网站的有效网页时收到此状态代码（您可在 Google Search Console 中运行状况下的抓取错误页上进行查看），则可能是因为您的服务器或主机正在阻止 Googlebot 进行访问。 404 服务器找不到请求的网页。例如，如果相应请求是针对服务器上不存在的网页进行的，那么服务器通常会返回此代码。如果您的网站上没有 robots.txt 文件，而您在 Google Search Console 中的已拦截的网址页上看到此状态，那么这就是正确的状态。但是，如果您有 robots.txt 文件而又看到此状态，则说明您的 robots.txt 文件可能命名错误或位于错误的位置（该文件应当位于顶级域名上，且应当名为 robots.txt）。如果您在 Googlebot 尝试抓取的网址上看到此状态，那么这表示 Googlebot 追踪的可能是另一网页中的无效链接（旧链接或输入有误的链接）。 405 禁用请求中所指定的方法。 406 无法使用请求的内容特性来响应请求的网页。 407 此状态代码与 401（未授权）类似，但却指定了请求者应当使用代理进行授权。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的代理。 408 服务器等待请求超时。 409 服务器在完成请求时遇到冲突。服务器必须在响应中包含该冲突的相关信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，同时会提供两个请求的差异列表。 410 如果请求的资源已被永久移除，那么，服务器会返回此响应。该代码与 404（未找到）代码类似，但在资源以前有但现在已经不复存在的情况下，有时会替代 404 代码出现。如果资源已被永久删除，那么，您应当使用 301 代码指定该资源的新位置。 411 服务器不会接受包含无效内容长度标头字段的请求。 412 服务器未满足请求者在请求中设置的其中一个前提条件。 413 服务器无法处理请求，因为请求实体过大，已超出服务器的处理能力。 414 请求的 URI（通常为网址）过长，服务器无法进行处理。 415 请求的格式不受请求页面的支持。 416 如果相应请求是针对网页的无效范围进行的，那么服务器会返回此状态代码。 417 服务器未满足“期望”请求标头字段的要求。 500 服务器遇到错误，无法完成请求。 501 服务器不具备完成相应请求的功能。例如，当服务器无法识别请求方法时，可能便会返回此代码。 502 服务器作为网关或代理，从上游服务器收到了无效的响应。 503 目前无法使用服务器（由于超载或进行停机维护）。通常，这只是一种暂时的状态。 504 服务器作为网关或代理，未及时从上游服务器接收请求。 505 服务器不支持相应请求中所用的 HTTP 协议版本。","tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"}]},{"title":"Java8 Lambda表达式","date":"2017-04-09T12:05:07.732Z","path":"2017/04/09/Java8 Lambda表达式/","text":"Java8 Lambda表达式1. 什么是λ表达式 λ表达式本质上是一个匿名方法。让我们来看下面这个例子： public int add(int x, int y) { return x + y; } 转成λ表达式后是这个样子： (int x, int y) -&gt; x + y; 参数类型也可以省略，Java编译器会根据上下文推断出来： (x, y) -&gt; x + y; //返回两数之和 或者 (x, y) -&gt; { return x + y; } //显式指明返回值 可见λ表达式有三部分组成：参数列表，箭头（-&gt;），以及一个表达式或语句块。 下面这个例子里的λ表达式没有参数，也没有返回值（相当于一个方法接受0个参数，返回void，其实就是Runnable里run方法的一个实现）： () -&gt; { System.out.println(&quot;Hello Lambda!&quot;); } 如果只有一个参数且可以被Java推断出类型，那么参数列表的括号也可以省略： c -&gt; { return c.size(); } 2. λ表达式的类型（它是Object吗？） λ表达式可以被当做是一个Object（注意措辞）。λ表达式的类型，叫做“目标类型（target type）”。λ表达式的目标类型是“函数接口（functional interface）”，这是Java8新引入的概念。它的定义是：一个接口，如果只有一个显式声明的抽象方法，那么它就是一个函数接口。一般用@FunctionalInterface标注出来（也可以不标）。举例如下： @FunctionalInterface public interface Runnable { void run(); } public interface Callable&lt;V&gt; { V call() throws Exception; } public interface ActionListener { void actionPerformed(ActionEvent e); } public interface Comparator&lt;T&gt; { int compare(T o1, T o2); boolean equals(Object obj); } 注意最后这个Comparator接口。它里面声明了两个方法，貌似不符合函数接口的定义，但它的确是函数接口。这是因为equals方法是Object的，所有的接口都会声明Object的public方法——虽然大多是隐式的。所以，Comparator显式的声明了equals不影响它依然是个函数接口。 你可以用一个λ表达式为一个函数接口赋值： Runnable r1 = () -&gt; {System.out.println(&quot;Hello Lambda!&quot;);}; 然后再赋值给一个Object： Object obj = r1; 但却不能这样干： Object obj = () -&gt; {System.out.println(&quot;Hello Lambda!&quot;);}; // ERROR! Object is not a functional interface! 必须显式的转型成一个函数接口才可以： Object o = (Runnable) () -&gt; { System.out.println(&quot;hi&quot;); }; // correct 一个λ表达式只有在转型成一个函数接口后才能被当做Object使用。所以下面这句也不能编译： System.out.println( () -&gt; {} ); //错误! 目标类型不明 必须先转型: System.out.println( (Runnable)() -&gt; {} ); // 正确 假设你自己写了一个函数接口，长的跟Runnable一模一样： @FunctionalInterface public interface MyRunnable { public void run(); } 那么 Runnable r1 = () -&gt; {System.out.println(&quot;Hello Lambda!&quot;);}; MyRunnable2 r2 = () -&gt; {System.out.println(&quot;Hello Lambda!&quot;);}; JDK预定义了很多函数接口以避免用户重复定义。最典型的是Function： @FunctionalInterface public interface Function&lt;T, R&gt; { R apply(T t); } 这个接口代表一个函数，接受一个T类型的参数，并返回一个R类型的返回值。 另一个预定义函数接口叫做Consumer，跟Function的唯一不同是它没有返回值。 @FunctionalInterface public interface Consumer&lt;T&gt; { void accept(T t); } 还有一个Predicate，用来判断某项条件是否满足。经常用来进行筛滤操作： @FunctionalInterface public interface Predicate&lt;T&gt; { boolean test(T t); } 综上所述，一个λ表达式其实就是定义了一个匿名方法，只不过这个方法必须符合至少一个函数接口。 3. λ表达式的使用 3.1 λ表达式用在何处 λ表达式主要用于替换以前广泛使用的内部匿名类，各种回调，比如事件响应器、传入Thread类的Runnable等。看下面的例子： Thread oldSchool = new Thread( new Runnable () { @Override public void run() { System.out.println(&quot;This is from an anonymous class.&quot;); } } ); Thread gaoDuanDaQiShangDangCi = new Thread( () -&gt; { System.out.println(&quot;This is from an anonymous method (lambda exp).&quot;); } ); 注意第二个线程里的λ表达式，你并不需要显式地把它转成一个Runnable，因为Java能根据上下文自动推断出来：一个Thread的构造函数接受一个Runnable参数，而传入的λ表达式正好符合其run()函数，所以Java编译器推断它为Runnable。 从形式上看，λ表达式只是为你节省了几行代码。但将λ表达式引入Java的动机并不仅仅为此。Java8有一个短期目标和一个长期目标。短期目标是：配合“集合类批处理操作”的内部迭代和并行处理（下面将要讲到）；长期目标是将Java向函数式编程语言这个方向引导（并不是要完全变成一门函数式编程语言，只是让它有更多的函数式编程语言的特性），也正是由于这个原因，Oracle并没有简单地使用内部类去实现λ表达式，而是使用了一种更动态、更灵活、易于将来扩展和改变的策略（invokedynamic）。 3.2 λ表达式与集合类批处理操作（或者叫块操作） 上文提到了集合类的批处理操作。这是Java8的另一个重要特性，它与λ表达式的配合使用乃是Java8的最主要特性。集合类的批处理操作API的目的是实现集合类的“内部迭代”，并期望充分利用现代多核CPU进行并行计算。Java8之前集合类的迭代（Iteration）都是外部的，即客户代码。而内部迭代意味着改由Java类库来进行迭代，而不是客户代码。例如： for(Object o: list) { // 外部迭代 System.out.println(o); } 可以写成 //forEach函数实现内部迭代 list.forEach(o -&gt; {System.out.println(o);}); 集合类（包括List）现在都有一个forEach方法，对元素进行迭代（遍历），所以我们不需要再写for循环了。forEach方法接受一个函数接口Consumer做参数，所以可以使用λ表达式。 这种内部迭代方法广泛存在于各种语言，如C++的STL算法库、Python、ruby、Scala等。 Java8为集合类引入了另一个重要概念：流（stream）。一个流通常以一个集合类实例为其数据源，然后在其上定义各种操作。流的API设计使用了管道（pipelines）模式。对流的一次操作会返回另一个流。如同IO的API或者StringBuffer的append方法那样，从而多个不同的操作可以在一个语句里串起来。看下面的例子： List&lt;Shape&gt; shapes = ... shapes.stream() .filter(s -&gt; s.getColor() == BLUE) .forEach(s -&gt; s.setColor(RED)); 首先调用stream方法，以集合类对象shapes里面的元素为数据源，生成一个流。然后在这个流上调用filter方法，挑出蓝色的，返回另一个流。最后调用forEach方法将这些蓝色的物体喷成红色。（forEach方法不再返回流，而是一个终端方法，类似于StringBuffer在调用若干append之后的那个toString） filter方法的参数是Predicate类型，forEach方法的参数是Consumer类型，它们都是函数接口，所以可以使用λ表达式。 还有一个方法叫parallelStream()，顾名思义它和stream()一样，只不过指明要并行处理，以期充分利用现代CPU的多核特性。 shapes.parallelStream(); // 或shapes.stream().parallel() 来看更多的例子。下面是典型的大数据处理方法，Filter-Map-Reduce： //给出一个String类型的数组，找出其中所有不重复的素数 public void distinctPrimary(String... numbers) { List&lt;String&gt; l = Arrays.asList(numbers); List&lt;Integer&gt; r = l.stream() .map(e -&gt; new Integer(e)) .filter(e -&gt; Primes.isPrime(e)) .distinct() .collect(Collectors.toList()); System.out.println(&quot;distinctPrimary result is: &quot; + r); } 第一步：传入一系列String（假设都是合法的数字），转成一个List，然后调用stream()方法生成流。 第二步：调用流的map方法把每个元素由String转成Integer，得到一个新的流。map方法接受一个Function类型的参数，上面介绍了，Function是个函数接口，所以这里用λ表达式。 第三步：调用流的filter方法，过滤那些不是素数的数字，并得到一个新流。filter方法接受一个Predicate类型的参数，上面介绍了，Predicate是个函数接口，所以这里用λ表达式。 第四步：调用流的distinct方法，去掉重复，并得到一个新流。这本质上是另一个filter操作。 第五步：用collect方法将最终结果收集到一个List里面去。collect方法接受一个Collector类型的参数，这个参数指明如何收集最终结果。在这个例子中，结果简单地收集到一个List中。我们也可以用Collectors.toMap(e-&gt;e, e-&gt;e)把结果收集到一个Map中，它的意思是：把结果收到一个Map，用这些素数自身既作为键又作为值。toMap方法接受两个Function类型的参数，分别用以生成键和值，Function是个函数接口，所以这里都用λ表达式。 你可能会觉得在这个例子里，List l被迭代了好多次，map，filter，distinct都分别是一次循环，效率会不好。实际并非如此。这些返回另一个Stream的方法都是“懒（lazy）”的，而最后返回最终结果的collect方法则是“急（eager）”的。在遇到eager方法之前，lazy的方法不会执行。 当遇到eager方法时，前面的lazy方法才会被依次执行。而且是管道贯通式执行。这意味着每一个元素依次通过这些管道。例如有个元素“3”，首先它被map成整数型3；然后通过filter，发现是素数，被保留下来；又通过distinct，如果已经有一个3了，那么就直接丢弃，如果还没有则保留。这样，3个操作其实只经过了一次循环。 除collect外其它的eager操作还有forEach，toArray，reduce等。 下面来看一下也许是最常用的收集器方法，groupingBy： //给出一个String类型的数组，找出其中各个素数，并统计其出现次数 public void primaryOccurrence(String... numbers) { List&lt;String&gt; l = Arrays.asList(numbers); Map&lt;Integer, Integer&gt; r = l.stream() .map(e -&gt; new Integer(e)) .filter(e -&gt; Primes.isPrime(e)) .collect( Collectors.groupingBy(p-&gt;p, Collectors.summingInt(p-&gt;1)) ); System.out.println(&quot;primaryOccurrence result is: &quot; + r); } 注意这一行： Collectors.groupingBy(p-&gt;p, Collectors.summingInt(p-&gt;1)) 它的意思是：把结果收集到一个Map中，用统计到的各个素数自身作为键，其出现次数作为值。 下面是一个reduce的例子： //给出一个String类型的数组，求其中所有不重复素数的和 public void distinctPrimarySum(String... numbers) { List&lt;String&gt; l = Arrays.asList(numbers); int sum = l.stream() .map(e -&gt; new Integer(e)) .filter(e -&gt; Primes.isPrime(e)) .distinct() .reduce(0, (x,y) -&gt; x+y); // equivalent to .sum() System.out.println(&quot;distinctPrimarySum result is: &quot; + sum); } reduce方法用来产生单一的一个最终结果。 流有很多预定义的reduce操作，如sum()，max()，min()等。 再举个现实世界里的例子比如： // 统计年龄在25-35岁的男女人数、比例 public void boysAndGirls(List&lt;Person&gt; persons) { Map&lt;Integer, Integer&gt; result = persons.parallelStream().filter(p -&gt; p.getAge()&gt;=25 &amp;&amp; p.getAge()&lt;=35). collect( Collectors.groupingBy(p-&gt;p.getSex(), Collectors.summingInt(p-&gt;1)) ); System.out.print(&quot;boysAndGirls result is &quot; + result); System.out.println(&quot;, ratio (male : female) is &quot; + (float)result.get (Person.MALE)/result.get(Person.FEMALE)); } 3.3 λ表达式的更多用法 // 嵌套的λ表达式 Callable&lt;Runnable&gt; c1 = () -&gt; () -&gt; { System.out.println(&quot;Nested lambda&quot;); }; c1.call().run(); // 用在条件表达式中 Callable&lt;Integer&gt; c2 = true ? (() -&gt; 42) : (() -&gt; 24); System.out.println(c2.call()); // 定义一个递归函数，注意须用this限定 protected UnaryOperator&lt;Integer&gt; factorial = i -&gt; i == 0 ? 1 : i * this.factorial.apply( i - 1 ); ... System.out.println(factorial.apply(3)); 在Java中，随声明随调用的方式是不行的，比如下面这样，声明了一个λ表达式(x, y) -&gt; x + y，同时企图通过传入实参(2, 3)来调用它： int five = ( (x, y) -&gt; x + y ) (2, 3); // ERROR! try to call a lambda in-place 这在C++中是可以的，但Java中不行。Java的λ表达式只能用作赋值、传参、返回值等。 4. 其它相关概念 4.1 捕获（Capture） 捕获的概念在于解决在λ表达式中我们可以使用哪些外部变量（即除了它自己的参数和内部定义的本地变量）的问题。 答案是：与内部类非常相似，但有不同点。不同点在于内部类总是持有一个其外部类对象的引用。而λ表达式呢，除非在它内部用到了其外部类（包围类）对象的方法或者成员，否则它就不持有这个对象的引用。 在Java8以前，如果要在内部类访问外部对象的一个本地变量，那么这个变量必须声明为final才行。在Java8中，这种限制被去掉了，代之以一个新的概念，“effectively final”。它的意思是你可以声明为final，也可以不声明final但是按照final来用，也就是一次赋值永不改变。换句话说，保证它加上final前缀后不会出编译错误。 在Java8中，内部类和λ表达式都可以访问effectively final的本地变量。λ表达式的例子如下： ... int tmp1 = 1; //包围类的成员变量 static int tmp2 = 2; //包围类的静态成员变量 public void testCapture() { int tmp3 = 3; //没有声明为final，但是effectively final的本地变量 final int tmp4 = 4; //声明为final的本地变量 int tmp5 = 5; //普通本地变量 Function&lt;Integer, Integer&gt; f1 = i -&gt; i + tmp1; Function&lt;Integer, Integer&gt; f2 = i -&gt; i + tmp2; Function&lt;Integer, Integer&gt; f3 = i -&gt; i + tmp3; Function&lt;Integer, Integer&gt; f4 = i -&gt; i + tmp4; Function&lt;Integer, Integer&gt; f5 = i -&gt; { tmp5 += i; // 编译错！对tmp5赋值导致它不是effectively final的 return tmp5; }; ... tmp5 = 9; // 编译错！对tmp5赋值导致它不是effectively final的 } ... Java要求本地变量final或者effectively final的原因是多线程并发问题。内部类、λ表达式都有可能在不同的线程中执行，允许多个线程同时修改一个本地变量不符合Java的设计理念。 4.2 方法引用（Method reference） 任何一个λ表达式都可以代表某个函数接口的唯一方法的匿名描述符。我们也可以使用某个类的某个具体方法来代表这个描述符，叫做方法引用。例如： Integer::parseInt //静态方法引用 System.out::print //实例方法引用 Person::new //构造器引用 下面是一组例子，教你使用方法引用代替λ表达式： //c1 与 c2 是一样的（静态方法引用） Comparator&lt;Integer&gt; c2 = (x, y) -&gt; Integer.compare(x, y); Comparator&lt;Integer&gt; c1 = Integer::compare; //下面两句是一样的（实例方法引用1） persons.forEach(e -&gt; System.out.println(e)); persons.forEach(System.out::println); //下面两句是一样的（实例方法引用2） persons.forEach(person -&gt; person.eat()); persons.forEach(Person::eat); //下面两句是一样的（构造器引用） strList.stream().map(s -&gt; new Integer(s)); strList.stream().map(Integer::new); 使用方法引用，你的程序会变得更短些。现在distinctPrimarySum方法可以改写如下： public void distinctPrimarySum(String... numbers) { List&lt;String&gt; l = Arrays.asList(numbers); int sum = l.stream().map(Integer::new).filter(Primes::isPrime).distinct().sum(); System.out.println(&quot;distinctPrimarySum result is: &quot; + sum); } 还有一些其它的方法引用: super::toString //引用某个对象的父类方法 String[]::new //引用一个数组的构造器 4.3 默认方法（Default method） Java8中，接口声明里可以有方法实现了，叫做默认方法。在此之前，接口里的方法全部是抽象方法。 public interface MyInterf { String m1(); default String m2() { return &quot;Hello default method!&quot;; } } 这实际上混淆了接口和抽象类，但一个类仍然可以实现多个接口，而只能继承一个抽象类。 这么做的原因是：由于Collection库需要为批处理操作添加新的方法，如forEach()，stream()等，但是不能修改现有的Collection接口——如果那样做的话所有的实现类都要进行修改，包括很多客户自制的实现类。所以只好使用这种妥协的办法。 如此一来，我们就面临一种类似多继承的问题。如果类Sub继承了两个接口，Base1和Base2，而这两个接口恰好具有完全相同的两个默认方法，那么就会产生冲突。这时Sub类就必须通过重载来显式指明自己要使用哪一个接口的实现（或者提供自己的实现）： public class Sub implements Base1, Base2 { public void hello() { Base1.super.hello(); //使用Base1的实现 } } 除了默认方法，Java8的接口也可以有静态方法的实现： public interface MyInterf { String m1(); default String m2() { return &quot;Hello default method!&quot;; } static String m3() { return &quot;Hello static method in Interface!&quot;; } } 4.4 生成器函数（Generator function） 有时候一个流的数据源不一定是一个已存在的集合对象，也可能是个“生成器函数”。一个生成器函数会产生一系列元素，供给一个流。Stream.generate(Supplier s)就是一个生成器函数。其中参数Supplier是一个函数接口，里面有唯一的抽象方法 get()。 下面这个例子生成并打印5个随机数： Stream.generate(Math::random).limit(5).forEach(System.out::println); 注意这个limit(5)，如果没有这个调用，那么这条语句会永远地执行下去。也就是说这个生成器是无穷的。这种调用叫做终结操作，或者短路（short-circuiting）操作。","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"java类加载机制","date":"2017-04-07T06:39:29.810Z","path":"2017/04/07/java类加载机制/","text":"类加载过程 大致过程java中的类只有被JVM加载之后才能在程序中使用，加载的过程大致为加载-连接-初始化，其中连接又分为验证-准备-解析。所以细分为加载-验证-准备-解析-初始化五个阶段。其中加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，有时为了动态绑定也会以在初始化阶段之后开始。类生命周期： 类加载的条件JVM肯定不会无缘无故就去加载.class，只有主动使用时才会初始化。主动使用有以下几种情况： 当创建一个类的实例时，比如使用new或者反射，克隆，反序列化。 当调用类的静态方法时，即使用了字节码invokestatic指令。 当时用类或接口的静态字段时(final常量除外)，即使用了字节码的getstatic和putstatic指令。 当使用了java.lang.reflect包中的方法反射类的方法时。 当初始化子类时，要求先初始化父类。 作为启动虚拟机，含有main()方法那个类。 12345678910111213141516public class Parent&#123; static&#123; System.out.println(&quot;parent init&quot;); &#125; public static int v=100;&#125;public class Child extends Parent&#123; static&#123; System.out.println(&quot;child init&quot;); &#125;&#125;public class Main&#123; public static void main(String args[])&#123; System.out.println(Child.v); &#125;&#125; 运行输出： 12parent init100 可以看到只有父类被初始化，子类没有。可见，引用一个子类时(例子中的v)，只有直接定义该字段的类(例子中的父类)，才会被初始化。注意，child虽然没有被初始化但是已经被加载。 类加载的过程-加载 目的：查找并加载类的二进制数据 加载一个类时，JVM需要完成的工作。 通过类的全名，获取类的二进制数据流。 解析类的二进制数据流为方法区内的数据结构。 创建java.lang.Class类的实例，表示该类型。 类加载的过程-验证 目的：确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响。如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。 验证阶段大致4个阶段： 文件格式验证验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。 元数据验证对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。 字节码验证通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。 符号引用验证确保解析动作能正确执行。 类加载的过程-准备 目的：为类的静态变量分配内存，并将其初始化为默认值 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都在方法区中进行分配。 注意： 这时候进行内存分配的仅包括类变量，而不包括实例变量，实例变量会在对象实例化的时候随着对象一起分配在Java堆中； 这里所说的初始值“通常情况”下是数据类型的零值：假设一个类变量的定义为： public static int value = 123;那变量value在准备阶段过后的初始值为0而不是123，因为此时尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是在程序被编译之后， 存放于类构造器方法中，所以把value赋值为123的动作将在初始化阶段才会执行。但是假设类变量value的定义为：public static final int value = 123;在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。JAVA类变量默认值： 类加载的过程-解析目的： 把类中的符号引用转换为直接引用 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。 符号引用： 符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存当中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。 直接引用: 直接引用可以是直接指向目标的指针、相对偏移量或者是一个能简介定位到目标的句柄。直接引用是和虚拟机实现的内存布局息息相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。 类加载的过程-初始化除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作均由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码（或者说是字节码）。初始化阶段是执行类构造器clinit方法的过程。在Java中对类变量进行初始值设定有两种方式：①声明类变量是指定初始值②使用静态代码块为类变量指定初始值。clinit方法 由编译器收集类中的所有类变量的赋值动作（如果仅仅只是声明，不会被收集）和静态语句块中的语句合并产生的，收集顺序按照语句在源文件中出现的顺序所决定；在静态语句块中只能访问定义在静态语句之前的变量；而对于定义在静态语句块之后的变量，可以进行赋值，但是不能够访问。 不需要显示调用父类构造器，虚拟机会保证在子类的clinit()方法执行之前，父类的clinit()方法已经执行完毕，所以，第一个被执行的clinit()方法的类肯定是java.lang.Object。 父类中定义的静态语句块优先于子类的静态语句。 此方法对类和接口都不是必须的，若类中没有静态语句块和静态变量赋值操作，则不会生成clinit()方法。 接口会生成此方法，因为对接口的字段可以进行赋值操作。执行接口的clinit()方法不需要先执行父接口的clinit()方法，只有在使用父接口的变量时，才会进行初始化；接口的实现类在初始化时也不会执行接口的clinit()方法。 此方法在多线程环境中会被正确的加锁、同步。 类加载器 类加载器种类1. Bootstrap ClassLoader(启动类加载器)一般由C++实现，是虚拟机的一部分。该类加载器主要职责是将JAVA_HOME路径下的\\lib目录中能被虚拟机识别的类库(比如rt.jar)加载到虚拟机内存中。Java程序无法直接引用该类加载器2. Extension ClassLoader(扩展类加载器)由Java实现，独立于虚拟机的外部。该类加载器主要职责将JAVA_HOME路径下的\\lib\\ext目录中的所有类库，开发者可直接使用扩展类加载器。 该加载器是由sun.misc.Launcher$ExtClassLoader实现。3 Application ClassLoader(应用程序类加载器)该加载器是由sun.misc.Launcher$AppClassLoader实现，该类加载器负责加载用户类路径上所指定的类库。开发者可通过ClassLoader.getSystemClassLoader()方法直接获取，故又称为系统类加载器。当应用程序没有自定义类加载器时，默认采用该类加载器。 双亲委托模式 如果一个类加载器收到了类加载请求，他不会尝试自己去加载，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有类加载的请求最终都应该传到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个类加载的请求时，子类才会尝试自己加载。但也有弊端， 顶层的ClassLoader无法访问底层的ClassLoader所加载的类所造成的问题。 使用双亲委托模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，例如java.lang.Object存放在rt.jar之中，无论那个类加载器要加载这个类，最终都是委托给启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类，相反，如果没有双亲委托模型，由各个类加载器去完成的话，如果用户自己写一个名为java.lang.Object的类，并放在classpath中，应用程序中可能会出现多个不同的Object类，java类型体系中最基本安全行为也就无法保证。 java.lang.ClassLoaderjava.lang.ClassLoader类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个Java类,还负责加载 Java 应用所需的资源，如图像文件和配置文件等.ClassLoader 中与加载类相关的方法: 方法 说明 getParent() 返回该类加载器的父类加载器。 loadClass(String name) 加载名称为 name 的类，返回的结果是 java.lang.Class 类的实例。 findClass(String name) 查找名称为 name 的类，返回的结果是 java.lang.Class 类的实例。 findLoadedClass(String name) 查找名称为 name 的已经被加载过的类，返回的结果是 java.lang.Class 类的实例。 defineClass(String name, byte[] b, int off, int len) 把字节数组 b 中的内容转换成 Java 类，返回的结果是 java.lang.Class 类的实例。这个方法被声明为 final 的。 resolveClass(Class&lt;?&gt; c) 链接指定的 Java 类。 自定义类加载器定义类加载器可以选择 继承ClassLoader类，重写里面的方法来实现。loadClass()方法重写的话可能会破坏双亲委托模型，不推荐重写；defineClass：主要用于将原始字节转换为Class对象，不需要重写；findClass：根据名称来查找类，一般就重写这个方法。12345678910111213141516171819202122232425262728293031323334 public class Main &#123; static class MyClassLoader extends ClassLoader &#123; private String classPath; public MyClassLoader(String classPath) &#123; this.classPath = classPath; &#125; private byte[] loadByte(String name) throws Exception &#123; name = name.replaceAll(&quot;\\\\.&quot;, &quot;/&quot;); FileInputStream fis = new FileInputStream(classPath + &quot;/&quot; + name + &quot;.class&quot;); int len = fis.available(); byte[] data = new byte[len]; fis.read(data); fis.close(); return data; &#125; protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; try &#123; byte[] data = loadByte(name); return defineClass(name, data, 0, data.length); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new ClassNotFoundException(); &#125; &#125; &#125;; public static void main(String args[]) throws Exception &#123; MyClassLoader classLoader = new MyClassLoader(&quot;D:/test&quot;); Class clazz = classLoader.loadClass(&quot;com.huachao.cl.Test&quot;); Object obj = clazz.newInstance(); Method helloMethod = clazz.getDeclaredMethod(&quot;hello&quot;, null); helloMethod.invoke(obj, null); &#125;&#125; 参考 《实战java虚拟机》 http://www.jianshu.com/p/11cc2de9dbc2 http://www.cnblogs.com/leesf456/p/5269545.html http://www.jsondream.com/2016/11/16/jvm-class-load-parent-Delegate.html https://www.ibm.com/developerworks/cn/java/j-lo-classloader/#download http://www.jianshu.com/p/acc7595f1b9d?utm_source=tuicool&amp;utm_medium=referral","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"java注解总结","date":"2017-04-07T06:33:42.788Z","path":"2017/04/07/java注解总结/","text":"注解分类 源码注解： 只在源码中存在，编译成.class就不存在了。 编译时注解： 源码和.class中都存在，比如@Override，@Deprecated等 运行时注解： 在运行时注解，比如spring的@Component，@AutoWired等 标准注解 注解标识 作用 @Override 覆盖超类中的方法 @Deprecated 声明过期 @SuppressWarnings 关闭不当的编译器警告信息 自定义注解 元注解 用于自定义注解 元注解类型 @Target @Retention @Documented @Inherited @Target 定义注解将应用于什么地方,当注解未指定Target值时，此注解可以使用任何元素之上,取值(ElementType)有: TYPE: 接口、类、枚举、注解 FIELD: 字段、枚举的常量 METHOD: 方法 PARAMETER: 方法参数 CONSTRUCTOR: 构造器 LOCAL_VARIABLE: 局部变量 ANNOTATION_TYPE: 注解类型 PACKAGE: 包 TYPE_PARAMETER: 类型参数声明(1.8新增)。 比如public class MyList&lt;@MySet T&gt; {}，在定义@MySet，必须在MySet的@Target设置 ElementType.TYPE_PARAMETER ，表示这个注解可以用来标注类型参数。 TYPE_USE: 类型使用声明(1.8新增)。只要是类型名称，都可以进行注解，以下的使用注解都是可以的: 123456List&lt;@Test Comparable&gt; list1 = new ArrayList&lt;&gt;();List&lt;? extends Comparable&gt; list2 = new ArrayList&lt;@Test Comparable&gt;();@Test String text;text = (@Test String)new Object();java.util. @Test Scanner console;console = new java.util.@Test Scanner(System.in); @Retention 定义注解在哪一个级别可用，当注解未定义Retention值时，默认值是CLASS，在源代码中，类文件中或者运行时，取值(RetentionPoicy)有： SOURCE ：注解将被编译器丢弃（该类型的注解信息只会保留在源码里，源码经过编译后，注解信息会被丢弃，不会保留在编译好的class文件里) CLASS ：注解在class文件中可用，但会被JVM丢弃（该类型的注解信息会保留在源码里和class文件里，在执行的时候，不会加载到虚拟机（JVM）中） RUNTIME ：JVM将在运行期也保留注解信息，因此可以通过反射机制读取注解的信息（源码、class文件和执行的时候都有注解的信息） @Documented 用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。是一个标记注解，没有成员。 @Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。是一个标记注解，没有成员。 示例 12345678@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Desc &#123; String value(); String desc() default &quot;description：&quot;;&#125; 注意事项 注解可以设定初始值，使用default就可以实现。 注解只有一个元素的时候，该元素名称必须是value，并且在使用该注解的时候可以省略”value=”。 注解的值必须是确定的，且不能使用null作为值。 注解可能的类型： 基本类型（int,float,boolean,byte,double,char,long,short） String Class enum Annotation 以上类型的数组 如果使用了其他类型，那编译器就会报错。也不允许使用任何包装类型。注解也可以作为元素的类型，也就是注解可以嵌套。 元素的修饰符，只能用 public 或 default 编写注解解析器 要想注添加逻辑，需要反射或者字节码操作获取注解信息 被注解的测试类 123@Desc(value = &quot;test&quot;,desc = &quot;Test is a type&quot;) public class Test &#123;&#125; 反射获取注解信息 123456789101112 public class Main &#123; public static void main(String[] args) throws Exception&#123; Class&lt;?&gt; c=Class.forName(&quot;me.jcala.tip.annotation.Test&quot;); Annotation annotation=c.getAnnotation(Desc.class); if (annotation!=null)&#123; Desc desc=(Desc)annotation; System.out.println(&quot;value:&quot;+desc.value()); System.out.println(&quot;description:&quot;+desc.desc()); &#125; &#125; &#125;&#125;","tags":[{"name":"java,注解","slug":"java-注解","permalink":"http://yoursite.com/tags/java-注解/"}]},{"title":"volatile 学习","date":"2017-04-07T06:32:41.368Z","path":"2017/04/07/volatile 学习/","text":"volatile 作用: 保证变量对所有线程的可见性，即一个线程修改了某个值，新值对其他线程来说是立即可见的。(强制从公共堆栈中取得变量的值，而不是从线程私有数据栈中取得变量的值。) Java内存模型规定，对于多个线程共享的变量，存储在主内存当中，每个线程都有自己独立的工作内存（比如CPU的寄存器），线程只能访问自己的工作内存，不可以访问其它线程的工作内存。工作内存中保存了主内存共享变量的副本，线程要操作这些共享变量，只能通过操作工作内存中的副本来实现，操作完毕之后再同步回到主内存当中。volatile保在每次访问变量时都会进行一次刷新，因此每次访问都是主内存中最新的版本。 禁止指令重排序 指令重排序是JVM为了优化指令，提高程序运行效率，在不影响单线程程序执行结果的前提下，尽可能地提高并行度。但是指令重排序在多线程时会出现一些问题。如下： 1234567891011121314在线程A中:context = loadContext();inited = true;在线程B中:while(!inited )&#123; //根据线程A中对inited变量的修改决定是否使用context变量 sleep(100);&#125;doSomethingwithconfig(context);假设线程A中发生了指令重排序:inited = true;context = loadContext();那么B中很可能就会拿到一个尚未初始化或尚未初始化完成的context,从而引发程序错误。 而volatile使用内存屏障可以禁用指令重排序，避免这种问题。 与synchronized对比: volatile可以保证数据的可见性，但不可以保证原子性 synchronized可以保证原子性，也可以间接保证可见性 synchronized有volatile同步的功能 volatile性能一般高于synchronized 正确使用 volatile 变量的条件 对变量的写操作不依赖于当前值。(不能是自增自减等操作) 该变量没有包含在具有其他变量的不变式中。包含在具有其他变量的不变式中的情况(包含了一个不变式 —— 下界总是小于或等于上界)：123456789101112131415public class NumberRange &#123; private int lower, upper; public int getLower() &#123; return lower; &#125; public int getUpper() &#123; return upper; &#125; public void setLower(int value) &#123; if (value &gt; upper) throw new IllegalArgumentException(&quot;&quot;); lower = value; &#125; public void setUpper(int value) &#123; if (value &lt; lower) throw new IllegalArgumentException(&quot;&quot;); upper = value; &#125;&#125; 如果凑巧两个线程在同一时间使用不一致的值执行 setLower 和 setUpper 的话，则会使范围处于不一致的状态.例如，如果初始状态是(0, 5)，同一时间内，线程 A 调用 setLower(4) 并且线程 B 调用 setUpper(3)，显然这两个操作交叉存入的值是不符合条件的，那么两个线程都会通过用于保护不变式的检查，使得最后的范围值是 (4, 3) —— 一个无效值。 volatile可以解决的问题示例:123456789101112131415161718192021222324252627282930public class RunThread extends Thread&#123; private boolean isRunning=true; public boolean isRunning()&#123; return isRunning; &#125; public void setRunning(boolean isRunning)&#123; this.isRunning=isRunning; &#125; @Override public void run()&#123; System.out.println(&quot;进入run了&quot;); while (isRunning==true)&#123; &#125; System.out.println(&quot;线程被停止了&quot;); &#125;&#125;public class Main&#123; public static void main(String args[])&#123; try&#123; RunThread thread=new RunThread(); thread.start(); Thread.sleep(1000); thread.setRunning(false); System.out.println(&quot;已经赋值为false&quot;); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 运行时加入JVM参数, -server。查看结果发现System.out.println(“线程被停止了”);从未执行。 因为JVM被设置为-server模式时为了线程的运行效率，线程一直在私有堆栈中取得isRunning的值为true，而更新的却是公共堆栈中的isRunning。 解决方法：volatile private boolean isRunning=true; 线程工作内存和主工作内存之间通过8中原子操作实现 lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。 unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其它线程锁定。 read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。 load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。 assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送给主内存中，以便随后的write操作使用。 write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。 ***对于volatile修饰的变量，只能保证从主内存到工作内存的值是最新的，但像use和assign这些操作并不是原子性的，因此volatile无法保证原子性*** 使用原子类进行i++操作123456789101112131415161718192021import java.util.concurrent.atomic.AtomicInteger; public class AddCountThread extends Thread&#123; private AtomicInteger count=new AtomicInteger(0); @Override public void run()&#123; for (int i=0;i&lt;1000;i++)&#123; System.out.println(count.incrementAndGet()); &#125; &#125;&#125;public class Main&#123; public static void main(String args[])&#123; AddCountThread thread=new AddCountThread(); new Thread(thread).start(); new Thread(thread).start(); new Thread(thread).start(); new Thread(thread).start(); new Thread(thread).start(); &#125;&#125; 原子类也不完全安全123456789101112131415161718192021222324252627282930313233343536373839import java.util.concurrent.atomic.AtomicLong;public class MyService&#123; public static AtomicLong aiRef=new AtomicLong(); public void addNum()&#123; System.out.println(Thread.currentThread().getName()+&quot;加了100后的值是:&quot;+aiRef.addAndGet(100)); aiRef.addAndGet(1); &#125;&#125;public class MyThread extends Thread&#123; private MyService myService; public MyThread(MyService myService)&#123; super(); this.myService=myService; &#125; @Override public void run()&#123; myService.addNum(); &#125;&#125;public class Main&#123; public static void main(String args[])&#123; try&#123; MyService service=new MyService(); MyThread[] myThreads=new MyThread[5]; for (int i=0;i&lt;myThreads.length;i++)&#123; myThreads[i]=new MyThread(service); &#125; for (int i=0;i&lt;myThreads.length;i++)&#123; myThreads[i].start(); &#125; Thread.sleep(1000); System.out.println(service.aiRef.get()); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 运行发现打印出错，这是因为addAndGet()方法虽然是原子性的，但方法与方法之间的调用不是原子性的。 参考: JAVA多线程编程核心技术 深入理解Java虚拟机 http://www.codeceo.com/article/jvm-memory-model-visual.html?utm_source=tuicool&amp;utm_medium=referral http://www.importnew.com/23535.html?utm_source=tuicool&amp;utm_medium=referral http://www.jianshu.com/p/03a8f06ede46?utm_source=tuicool&amp;utm_medium=referral","tags":[{"name":"java,volatile","slug":"java-volatile","permalink":"http://yoursite.com/tags/java-volatile/"}]},{"title":"JPA参考手册","date":"2017-04-07T06:31:15.800Z","path":"2017/04/07/JPA参考手册/","text":"1. JPA普通注解 @Entity: 声明为一个实体。(修饰实体类) @Table: 指定实体所映射的表。(修饰实体类) 属性 是否必要 说明 name 否 设置实体映射的表名。不指定则与实体类的类名相同 catalog 否 设置实体映射的表放入指定的catalog中。不指定则放入默认的catalog中 schema 否 设置实体映射的表放入指定的schema中。 不指定则放入默认的schema中 uniqueConstraints 否 为实体映射的表设置唯一的约束。该属性可以是一个@UniqueConstraint Annotation数组 @Indexed：定义索引 12345678910111213141516@Entity@Table(name=&quot;person_table&quot;, indexes = &#123; @Index(name=&quot;idx_person&quot;, columnList=&quot;name&quot;) &#125;)@NamedQuery( name=&quot;simpleByTest&quot;, query=&quot;SELECT x FROM SimpleModel x WHERE x.test LIKE :test&quot; )public class Person &#123; @Id @GeneratedValue private Long id; private String name; //...&#125; @secondaryTable: 把实体的部分属性映射到第二个数据表。可通过@secondaryTable指定多个额外的数据表。(修饰实体类) 属性 是否必要 说明 name 否 指定新数据表的表名 catalog 否 设置实体映射的表放入指定的catalog中。不指定则放入默认的catalog中 schema 否 设置实体映射的表放入指定的schema中。 不指定则放入默认的schema中 uniqueConstraints 否 为实体映射的表设置唯一的约束。 pkJoinColumns 否 指定新数据表的一个或多个外键列，只有通过该外键列才可让新数据表中的记录参照到主表记录。该属性值是一个@PrimaryKeyJoinColumn数组 @PrimaryKeyJoinColumn: 用于定义在从表中定义的外键列的映射信息。 属性 是否必要 说明 name 否 指定从表中的外键列的列名 columnDefinition 否 指定JPA使用该属性值指定的SQL片段来创建外键列 referencedColumnName 否 指定从表中外键参照的数据列的列名 1234567891011121314@Entity@Table(name=&quot;person_table&quot;)@SecondaryTable(name=&quot;person_detail&quot;,pkJoinColumns=@PrimaryKeyJoinColumn(name=&quot;person_id&quot;))public class Person&#123;@Idprivate int id;@Column(name=&quot;person_name&quot;,length=50)private String name;@Column(table=&quot;person_detail&quot;,name=&quot;email&quot;)private String email;@Column(table=&quot;person_detail&quot;,name=&quot;phone&quot;)private String phone;&#125;指定将实体状态放入第二个person_detail数据表中，并指定email,phone两个属性放入person_detail数据表中 @Column: 指定属性映射的列信息，如列名，长度等。(修饰属性) 属性 是否必要 说明 name 否 指定该列的列名。默认为属性名 length 否 指定该列所能保存的数据的最大长度。默认为255 nullable 否 指定该列是否允许为null。默认为true unique 否 指定该列是否具有唯一约束。默认为false updatable 否 指定该列是否包含在JPA生成的update语句的列列表中。默认为true insertable 否 指定该列是否包含在JPA生成的insert语句的列列表中。默认为true @Id和@GeneratedValue：映射实体类的主键。(修饰属性)@Id定义主键，可以是基本类型，基本类型的包装类，String，Date等类型。@GeneratedValue：设置自动生成属性值，属性如下： 属性 是否必要 说明 strategy 否 使用怎样的主键生成策略。GenerationType.AUTO：JPA自动选择最适合底层数据库的主键生成策略; GenerationType.IDENTITY: 对于mysql，sqlserver这样的数据库选择自增长的主键生成策略；GenerationType.SEQUENCE: 对于oracle这样的数据库，选择使用基于sequence的主键生成策略，应与@SequenceGenderator一起使用；GenerationType.TABLE：使用一个辅助表来生成主键，应与@TableGenderator一起使用 generator 否 当使用GenerationType.SEQUENCE,GenerationType.TABLE主键生成策略时，该属性指定sequence,辅助表的名称 @Transient: 修饰不想持久保存的属性。(修饰属性) @Enumerated： 修饰枚举类型。(修饰属性) 123当@Enumerated的value属性为EnumType.STRING时，底层数据库保存的是枚举值的名称；当@Enumerated的value属性为EnumType.ORDINAL时，保存枚举值的序号。如@Enumerated(EnumType.ORDINAL). @Lob:修饰大数据类型，对应JDBC的java.sql.Clob类型或者java.sql.Blob类型。(修饰属性) 12当修饰的属性为byte[],Byte[],java.io.Serializable类型时，将映射为数据库底层的Blob列；当修饰的属性为char[],Character[]或java.lang.String类型时，映射为底层的Clob列。 @Basic：用于延迟加载操作。(修饰属性) 12345678比如JPA加载Person实体时并不需要立即加载它的pic属性，而只加载一个&quot;虚拟的&quot;代理，真正需要pic属性再从数据库加载。@Basic可以指定的属性：fetch:指定是否需要延迟加载该属性。FetchType.EAGER不使用延迟加载，Fetch.LAZY使用延迟加载。optional：指定映射的数据列是否允许使用null值。例如：@Lob@Basic(fetch=FetchType.LAZY)private byte[] pic; @Temporal: 修饰日期类型。(修饰属性) 123@Temporal可以指定一个value属性，该属性支持Temporal.DATE,Temporal.TIME,Temporal.TIMESTAMP，分别对应于数据库date,time,timestamp类型的数据列。 @Embedded和@Embeddable: 映射复合类型。@Embeadded修饰这个复合类型属性，@Embeaddable修饰这个复合类。@AttributeOverride用来指定复合类型的成员属性的映射配置，它支持的属性： 属性 是否必要 说明 name 是 指定对复合类型中哪个属性进行配置 column 是 指定该属性所映射的数据列的列名 12345678910111213141516171819@Entity@Table(name=&quot;person_table&quot;)public class Person&#123;@Idprivate int id;@Column(name=&quot;person_name&quot;,length=50)private String name;@Embedded@AttributeOverrides(&#123; @AttributeOverride(name=&quot;name&quot;,column=@Column(name=&quot;cat_name&quot;,length=35)), @AttributeOverride(name=&quot;color&quot;,column=@Column(&quot;cat_color&quot;))&#125;)private Cat cat;&#125;@Embeddablepublic class Cat&#123; private String name; private String color;&#125; @IdClass和@EmbeddedId: 定义复合类型的主键。(修饰属性)定义复合类型的主键有两种方式：(1). 使用@IdClass和多个@Id;(2). 使用一个@EmbeddedId即可。 123456789101112131415161718192021222324252627282930313233方式一：使用@IdClass和多个@Id @Entity @Table(name=&quot;person_table&quot;) @IdClass(Cat.class) public class Person&#123; //两个@Id定义联合主键 @Id private int id; @Id private String name; private Cat cat; &#125;方式二：用一个@EmbeddedId @Entity @Table(name=&quot;person_table&quot;) public class Person&#123; @Id private int id; @Column(name=&quot;person_name&quot;,length=50) private String name; @EmbeddedId @Embedded @AttributeOverrides(&#123; @AttributeOverride(name=&quot;name&quot;,column=@Column(name=&quot;cat_name&quot;,length=35)), @AttributeOverride(name=&quot;color&quot;,column=@Column(&quot;cat_color&quot;)) &#125;) private Cat cat; &#125; @Embeddable public class Cat&#123; private String name; private String color; &#125; @OrderBy: 对关联实体进行排序 123456789101112131415161718192021222324252627282930313233//Example 1: @Entity public class Course &#123; @ManyToMany @OrderBy(&quot;lastname ASC&quot;) public List&lt;Student&gt; getStudents() &#123;&#125;; &#125; //Example 2: @Entity public class Student &#123; @ManyToMany(mappedBy=&quot;students&quot;) @OrderBy // ordering by primary key is assumed public List&lt;Course&gt; getCourses() &#123;&#125;; &#125; //Example 3: @Entity public class Person &#123; @ElementCollection @OrderBy(&quot;zipcode.zip, zipcode.plusFour&quot;) public Set&lt;Address&gt; getResidences() &#123;&#125;; &#125; @Embeddable public class Address &#123; protected String street; protected String city; protected String state; @Embedded protected Zipcode zipcode; &#125; @Embeddable public class Zipcode &#123; protected String zip; protected String plusFour; &#125; @JoinColumn: 定义外键。(修饰属性) 属性 是否必要 说明 columnDefinition 否 指定JPA使用该属性值指定的SQL片段来创建外键列 name 否 指定该外键列的列名 insertable 否 指定该列是否包含在JPA生成的insert语句的列列表中。默认为true updatable 否 指定该列是否包含在JPA生成的update语句的列列表中。默认为true nullable 否 指定该列是否允许为null。默认为true table 否 指定该列所在的数据表的表名 unique 否 指定是否为该列增加唯一约束 referenceColumnName 否 指定该列所参照的主键列的列名 @ManyToOne: 映射多对一关系。(修饰属性) 属性 是否必要 说明 cascade 否 指定JPA对关联实体采用怎样的级联策略，该级联策略支持四个属性值。CascadeType.ALL：指定JPA将所有的持久化操作都级联到关联实体；CascadeType.MERGE: 指定JPA将merge操作都级联到关联实体；CascadeType.PERSIST：指定JPA将persist操作级联到关联实体；CascadeType.REFRESH: 指定JPA将refresh操作级联到关联实体；CascadeType.REMOVE: 指定JPA将remove操作关联到关联实体 fetch 否 指定抓取关联实体时抓取策略，该属性支持两个值。FetchType.EAGER: 抓取实体时，立即抓取关联实体，默认值；FetchType.LAZY：抓取实体时延迟抓取关联实体，等到真到用到时再去抓取。 optional 否 该属性指定关联关系是否可选。 targetEntity 否 该属性指定关联实体的类名。 在默认情况下，JPA通过反射判断 @OneToOne: 映射一对一关系。(修饰属性) 属性 是否必要 说明 cascade 否 指定JPA对关联实体采用怎样的级联策略，该级联策略支持四个属性值。CascadeType.ALL：指定JPA将所有的持久化操作都级联到关联实体；CascadeType.MERGE: 指定JPA将merge操作都级联到关联实体；CascadeType.PERSIST：指定JPA将persist操作级联到关联实体；CascadeType.REFRESH: 指定JPA将refresh操作级联到关联实体；CascadeType.REMOVE: 指定JPA将remove操作关联到关联实体 fetch 否 指定抓取关联实体时抓取策略，该属性支持两个值。FetchType.EAGER: 抓取实体时，立即抓取关联实体，默认值；FetchType.LAZY：抓取实体时延迟抓取关联实体，等到真到用到时再去抓取。 optional 否 该属性指定关联关系是否可选。 targetEntity 否 该属性指定关联实体的类名。 在默认情况下，JPA通过反射判断 mappedBy 否 该属性合法的属性值为关联实体的属性名，该属性指定关联实体中哪一个属性可引用到关联实体时采取抓取。 @OneToMany：映射一对多关系。(修饰属性) 属性 是否必要 说明 cascade 否 指定JPA对关联实体采用怎样的级联策略，该级联策略支持四个属性值。CascadeType.ALL：指定JPA将所有的持久化操作都级联到关联实体；CascadeType.MERGE: 指定JPA将merge操作都级联到关联实体；CascadeType.PERSIST：指定JPA将persist操作级联到关联实体；CascadeType.REFRESH: 指定JPA将refresh操作级联到关联实体；CascadeType.REMOVE: 指定JPA将remove操作关联到关联实体 fetch 否 指定抓取关联实体时抓取策略，该属性支持两个值。FetchType.EAGER: 抓取实体时，立即抓取关联实体，默认值；FetchType.LAZY：抓取实体时延迟抓取关联实体，等到真到用到时再去抓取。 targetEntity 否 该属性指定关联实体的类名。 在默认情况下，JPA通过反射判断 mappedBy 否 该属性合法的属性值为关联实体的属性名，该属性指定关联实体中哪一个属性可引用到关联实体时采取抓取。 @ManyToMany：映射多对多关系。(修饰属性) 属性 是否必要 说明 cascade 否 指定JPA对关联实体采用怎样的级联策略，该级联策略支持四个属性值。CascadeType.ALL：指定JPA将所有的持久化操作都级联到关联实体；CascadeType.MERGE: 指定JPA将merge操作都级联到关联实体；CascadeType.PERSIST：指定JPA将persist操作级联到关联实体；CascadeType.REFRESH: 指定JPA将refresh操作级联到关联实体；CascadeType.REMOVE: 指定JPA将remove操作关联到关联实体 fetch 否 指定抓取关联实体时抓取策略，该属性支持两个值。FetchType.EAGER: 抓取实体时，立即抓取关联实体，默认值；FetchType.LAZY：抓取实体时延迟抓取关联实体，等到真到用到时再去抓取。 targetEntity 否 该属性指定关联实体的类名。 在默认情况下，JPA通过反射判断 mappedBy 否 该属性合法的属性值为关联实体的属性名，该属性指定关联实体中哪一个属性可引用到关联实体时采取抓取。 @JoinTable：专门用于多对多关联关系指定连接表的配置信息。 属性 是否必要 说明 name 否 指定该连接表的表名 catalog 否 设置将该连接表放入指定的catalog内。如果没有指定该属性，连接表放入默认的catalog中。 schema 否 设置将该连接表放入指定的schema内。 如果没有指定该属性，连接表放入默认的schema中。 joinColumns 否 该属性值可接受多个@JoinColumn，用于配置连接表中外键列的列信息，这些列参照当前实体对应表的主键列 inverseJoinColumns 否 该属性值可接受多个@JoinColumn，用于配置连接表中外键列的列信息，这些列参照当前实体的关联实体对应表的主键列 uniqueConstraints 否 该属性为连接表增加唯一约束。 @MapKey: 使用Map集合记录关联实体。 MappedSuperClass: 映射为非实体父类，该实体父类不会生成对应的数据表 12345678910111213141516171819202122232425262728293031323334353637@MappedSuperclass public class Employee &#123; @Id protected Integer empId; @Version protected Integer version; @ManyToOne @JoinColumn(name=&quot;ADDR&quot;) protected Address address; public Integer getEmpId() &#123; &#125; public void setEmpId(Integer id) &#123; &#125; public Address getAddress() &#123; &#125; public void setAddress(Address addr) &#123; &#125; &#125; // Default table is FTEMPLOYEE table @Entity public class FTEmployee extends Employee &#123; // Inherited empId field mapped to FTEMPLOYEE.EMPID // Inherited version field mapped to FTEMPLOYEE.VERSION // Inherited address field mapped to FTEMPLOYEE.ADDR fk // Defaults to FTEMPLOYEE.SALARY protected Integer salary; public FTEmployee() &#123;&#125; public Integer getSalary() &#123; &#125; public void setSalary(Integer salary) &#123; &#125; &#125; @Entity @Table(name=&quot;PT_EMP&quot;) @AssociationOverride( name=&quot;address&quot;, joincolumns=@JoinColumn(name=&quot;ADDR_ID&quot;)) public class PartTimeEmployee extends Employee &#123; // Inherited empId field mapped to PT_EMP.EMPID // Inherited version field mapped to PT_EMP.VERSION // address field mapping overridden to PT_EMP.ADDR_ID fk @Column(name=&quot;WAGE&quot;) protected Float hourlyWage; public PartTimeEmployee() &#123;&#125; public Float getHourlyWage() &#123;&#125; public void setHourlyWage(Float wage) &#123;&#125; &#125; @Inheritance：指定映射策略 InheritanceType.SINGLE_TABLE： 整个类层次对应一张表策略,这是继承映射的默认策略。 InheritanceType.JOINED：连接子类策略。父亲的放在一张表，儿子只是保存和父亲不一样的，增加的属性。 InheritanceType.TABLE_PER_CLASS： 每个具体的类一个表的策略。 @DiscriminatorColumn:在整个类层次对应一张表策略的映射策略中配置辨别列。 属性 是否必要 说明 columnDefinition 否 指定JPA使用该属性值指定的SQL片段来创建外键列 name 否 指定辨别列的名称，默认值为”DTYPE” discriminatorType 否 指定该辨别者列的数据类型。 DiscriminatorType.CHAR: 辨别者列的类型是字符类型，即该列只接受单个字符；DiscriminatorType.INTEGER：辨别者列的类型是整数类型，即该列只接受整数值；DiscriminatorType.STRING：辨别者列的类型是字符串类型，即该列只接受字符串值，为默认值 length 否 该属性指定辨别者的字符长度 2. JPA生命周期注解 @PerPersist：保存实体之前回调它修饰的方法。 @PostPersist：保存实体之后回调它修饰的方法。 @PreRemove：删除实体之前回调它修饰的方法。 @PostRemove：删除实体之后回调它修饰的方法。 @PreUpdate：更新实体之前回调它修饰的方法。 @PostUpdate：更新实体之后回调它修饰的方法。 @PostLoad：记载实体之后回调它修饰的方法。 @EntityListeners: 自定义专门的监听器 123@Entity@EntityListeners(PersonListener.class)public class Person implements Serializable&#123;&#125; @ExcludeDefaultListeners和@ExcludeSuperclassListeners：排除监听器。 3. 关联 单向N-1关联：使用@ManyToOne注解。比如一个人对应多个手机号,仅通过手机号获取用户，无需获取用户的手机号的场景。当使用@JoinColumn通过外键实现，否则通过第三方表实现。1234567891011121314151617181920212223242526272829303132333435363738@Entity(name = &quot;Person&quot;)public static class Person &#123; @Id @GeneratedValue private Long id; public Person() &#123; &#125;&#125;@Entity(name = &quot;Phone&quot;)public static class Phone &#123; @Id @GeneratedValue private Long id; @Column(name = &quot;`number`&quot;) private String number; @ManyToOne(optional=false,cascade=CascadeType.ALL,fetch=FetchType.LAZY,targetEntity=Person.class) @JoinColumn(name = &quot;person_id&quot;, foreignKey = @ForeignKey(name = &quot;PERSON_ID_FK&quot;) ) private Person person; public Phone() &#123; &#125; public Phone(String number) &#123; this.number = number; &#125; public Long getId() &#123; return id; &#125; public String getNumber() &#123; return number; &#125; public Person getPerson() &#123; return person; &#125; public void setPerson(Person person) &#123; this.person = person; &#125;&#125; 对应的sql语句：12345678910111213CREATE TABLE Person ( id BIGINT NOT NULL , PRIMARY KEY ( id ))CREATE TABLE Phone ( id BIGINT NOT NULL , number VARCHAR(255) , person_id BIGINT , PRIMARY KEY ( id ) )ALTER TABLE PhoneADD CONSTRAINT PERSON_ID_FKFOREIGN KEY (person_id) REFERENCES Person 单向1-1关联: 使用@OneToOne注解。比如一个人对应一个身份证Id,只需获取一个人的身份证号，而无需通过身份证号获取用户的情况。当使用@JoinColumn通过外键实现，否则通过第三方表实现。 1234567891011121314151617@Entity@Table(name=&quot;person_table&quot;)public class Person&#123;@Idprivate int personid;private String name;@OneToOne(optional=false,cascade=CascadeType.ALL,fetch=FetchType.LAZY,targetEntity=IdCard.class)@JoinColumn(name=&quot;id_card_id&quot;,nullable=false,updatable=false)//映射外键列private IdCard idCard;&#125;@Entity@Table(name=&quot;id_card_table&quot;)public class IdCard&#123;@Idprivate int idCardId;private String cardNumber;&#125; 单向1-N关联：使用@OneToMany注解。-对于1-N关联，应尽量设计为双向关联，而不是单向比如一个人有多个手机号，仅需要获取一个人的手机号，而无需通过手机号获取用户的场景。当使用@JoinColumn通过外键实现，否则通过第三方表实现。 1234567891011121314151617181920212223242526272829303132@Entity(name = &quot;Person&quot;)public static class Person &#123; @Id @GeneratedValue private Long id; @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true) private List&lt;Phone&gt; phones = new ArrayList&lt;&gt;(); public Person() &#123; &#125; public List&lt;Phone&gt; getPhones() &#123; return phones; &#125;&#125;@Entity(name = &quot;Phone&quot;)public static class Phone &#123; @Id @GeneratedValue private Long id; @Column(name = &quot;`number`&quot;) private String number; public Phone() &#123; &#125; public Phone(String number) &#123; this.number = number; &#125; public Long getId() &#123; return id; &#125; public String getNumber() &#123; return number; &#125;&#125; 对应的sql：12345678910111213141516171819202122CREATE TABLE Person ( id BIGINT NOT NULL , PRIMARY KEY ( id ))CREATE TABLE Person_Phone ( Person_id BIGINT NOT NULL , phones_id BIGINT NOT NULL)CREATE TABLE Phone ( id BIGINT NOT NULL , number VARCHAR(255) , PRIMARY KEY ( id ))ALTER TABLE Person_PhoneADD CONSTRAINT UK_9uhc5itwc9h5gcng944pcaslfUNIQUE (phones_id);ALTER TABLE Person_PhoneADD CONSTRAINT FKr38us2n8g5p9rj0b494sd3391FOREIGN KEY (phones_id) REFERENCES Phone;ALTER TABLE Person_PhoneADD CONSTRAINT FK2ex4e4p7w1cj310kg2woisjl2FOREIGN KEY (Person_id) REFERENCES Person 单向N-N关联：使用@ManyToMany注解。比如一个人有多个住址，一个住址又对应多个用户，仅需通过用户获取住址列表的场景。对于多对多关系，数据库底层只能通过关联表实现。方式一：使用默认12345678910111213141516171819202122232425262728293031323334353637@Entity(name = &quot;Person&quot;)public static class Person &#123; @Id @GeneratedValue private Long id; @ManyToMany(cascade = &#123;CascadeType.PERSIST, CascadeType.MERGE&#125;) private List&lt;Address&gt; addresses = new ArrayList&lt;&gt;(); public Person() &#123; &#125; public List&lt;Address&gt; getAddresses() &#123; return addresses; &#125;&#125;@Entity(name = &quot;Address&quot;)public static class Address &#123; @Id @GeneratedValue private Long id; private String street; @Column(name = &quot;`number`&quot;) private String number; public Address() &#123; &#125; public Address(String street, String number) &#123; this.street = street; this.number = number; &#125; public Long getId() &#123; return id; &#125; public String getStreet() &#123; return street; &#125; public String getNumber() &#123; return number; &#125;&#125; 对应的sql：1234567891011121314151617181920CREATE TABLE Address ( id BIGINT NOT NULL , number VARCHAR(255) , street VARCHAR(255) , PRIMARY KEY ( id ))CREATE TABLE Person ( id BIGINT NOT NULL , PRIMARY KEY ( id ))CREATE TABLE Person_Address ( Person_id BIGINT NOT NULL , addresses_id BIGINT NOT NULL)ALTER TABLE Person_AddressADD CONSTRAINT FKm7j0bnabh2yr0pe99il1d066uFOREIGN KEY (addresses_id) REFERENCES Address;ALTER TABLE Person_AddressADD CONSTRAINT FKba7rc9qe2vh44u93u0p2auwtiFOREIGN KEY (Person_id) REFERENCES Person 方式二：通过@JoinTable配置关联表123456789101112131415161718@Entity(name = &quot;Person&quot;)public static class Person &#123; @Id @GeneratedValue private Long id; @ManyToMany(cascade = &#123;CascadeType.PERSIST, CascadeType.MERGE&#125;,targetEntity=Address.class) @JoinTable( name=&quot;person_address&quot;, joinColumns=@JoinColumn(name=&quot;person_id&quot;), inverseJoinTableColumns=@JoinColumn(name=&quot;address_id&quot;) ) private List&lt;Address&gt; addresses = new ArrayList&lt;&gt;(); public Person() &#123; &#125; public List&lt;Address&gt; getAddresses() &#123; return addresses; &#125;&#125; 双向1-1关联: 使用两边@OneToOne注解和mappedBy属性双向需要两边实体类都增加@OneToOne，可在一边的实体类增加mappedBy属性。当使用mappedBy属性后表示当前实体不再控制关联联系，因此不可使用@JoinColumn。比如一个人一个精确住址，既可以通过用户获取住址，又可以通过住址获取该住户的场景。 1234567891011121314151617181920212223@Entity@Table(name=&quot;person_table&quot;)public class Person&#123;@Id@GeneratedValue(strategy=GenerationType.IDENTITY)private int personId;private String name;private int age;@OneToOne(mappedBy=&quot;person&quot;,cascade=CascadeType.ALL)private Address address;//...&#125;@Entity@Table(name=&quot;address_table&quot;)public class Address&#123; @Id private int addressId; private String detail; @OneToOne(optional=false,cascade=CascadeType.ALL) @JoinColumn(name=&quot;person_id&quot;,nullable=false,updatable=false) private Person person; //...&#125; 双向1-N关联：使用@OneToMany和@ManyToOne注解和mappedBy属性对于1-N关联，应尽量设计为双向关联，而不是单向，并且尽量使用N的一端来控制关联。1的一端使用@OneToMany注解和mappedBy属性，N的一端使用@ManyToOne和@JoinColumn。比如一个人有多个住址，既可以通过用户获取住址，又可以通过住址获取用户的场景。 1234567891011121314151617181920212223@Entity@Table(name=&quot;person_table&quot;)public class Person&#123;@Id@GeneratedValue(strategy=GenerationType.IDENTITY)private int personId;private String name;private int age;@OneToMany(mappedBy=&quot;person&quot;,cascade=CascadeType.ALL)private Set&lt;Address&gt; addresses=new HashSet&lt;Address&gt;();//...&#125;@Entity@Table(name=&quot;address_table&quot;)public class Address&#123; @Id private int addressId; private String detail; @ManyToOne(optional=false,cascade=CascadeType.ALL) @JoinColumn(name=&quot;person_id&quot;,nullable=true) private Person person; //...&#125; 双向N-N关联: 使用两边@ManyToMany注解，一边mapperBy属性和。对于N-N关联，底层数据库必须通过关联表来关联实体之间的关系。对于双向N-N关联，两边实体对等，一边通过mappedBy不再控制关系，另一边通过@JoinTable控制关系即可。比如多个人住在同一个地址，但一个人也可有多个住址，既可以通过用户找到住址列表，又可以通过住址找到用户列表的场景。 12345678910111213141516171819202122232425262728@Entity@Table(name=&quot;person_table&quot;)public class Person&#123;@Id@GeneratedValue(strategy=GenerationType.IDENTITY)private int personId;private String name;private int age;@ManyToMany(mappedBy=&quot;persons&quot;,cascade=CascadeType.ALL)private Set&lt;Address&gt; addresses=new HashSet&lt;Address&gt;();//...&#125;@Entity@Table(name=&quot;address_table&quot;)public class Address&#123; @Id private int addressId; private String detail; @ManyToMany(optional=false,cascade=CascadeType.ALL) @JoinColumn(name=&quot;person_id&quot;,nullable=true) @JoinTable( name=&quot;person_address&quot;, joinColumns=@JoinColumn(name=&quot;address_id&quot;), inverseJoinTableColumns=@JoinColumn(name=&quot;person_id&quot;) ) private Set&lt;Person&gt; persons=new HashSet&lt;Person&gt;(); //...&#125; 使用Map集合记录关联实体：使用@MapKey注解：比如一个人有多个住址，既可以通过用户获取住址，又可以通过住址获取用户的场景。使用@MapKey时必须指定一个name属性，name属性的属性值为当前实体的关联实体中标识属性的属性名。 12345678910111213@Entity@Table(name=&quot;person_table&quot;)public class Person&#123;@Id@GeneratedValue(strategy=GenerationType.IDENTITY)private int personId;private String name;private int age;@OneToMany(mappedBy=&quot;person&quot;,cascade=CascadeType.ALL)@MapKey(name=&quot;pk&quot;)private Map&lt;AddressPk,Address&gt; addresses=new HashMap&lt;AddressPk,Address&gt;();//...&#125; 4. JPA映射策略1234567891011121314JPA提供了3种映射策略：(1)、 整个类层次对应一张表策略,这是继承映射的默认策略。即如果实体类B继承实体类A，实体类C也继承自实体A，那么只会映射成一个表，这个表中包括了实体类A、B、C中所有的字段，JPA使用一个叫做“discriminator列”来区分某一行数据是应该映射成哪个实体。注解为：@Inheritance(strategy = InheritanceType.SINGLE_TABLE)(2)、 连接子类策略。父亲的放在一张表，儿子只是保存和父亲不一样的，增加的属性。这种情况下子类的字段被映射到各自的表中，这些字段包括父类中的字段，并执行一个join操作来实例化子类。注解为：@Inheritance(strategy = InheritanceType.JOINED)(3)、 每个具体的类一个表的策略。注解为：@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)可使用@Inheritance指定映射策略InheritanceType.SINGLE_TABLE：第一种InheritanceType.JOINED：第二种InheritanceType.TABLE_PER_CLASS：第三种 整个类层次对应一张表策略。这种策略下，整个类层次所有的实体都存放在一张数据表中，系统通过在该表增加额外的一个辨别列，用来区分每行记录到底是哪一个类的实例。使用@DiscriminatorColumn来配置辨别列。 123456789101112131415161718192021@Entity@Inheritance(strategy=InheritanceType.SINGLE_TABLE)// 定义辨别者列的列名为person_type，列类型为字符串@DiscriminatorColumn(name=&quot;person_type&quot; , discriminatorType=DiscriminatorType.STRING)// 指定Person实体对应的记录在辨别者列的值为&quot;普通人&quot;@DiscriminatorValue(&quot;普通人&quot;)@Table(name=&quot;person_inf&quot;)public class Person&#123;&#125;// 顾客类继承了Person类@Entity// 指定Customer实体对应的记录在辨别者列的值为&quot;顾客&quot;@DiscriminatorValue(&quot;顾客&quot;)@Table(name=&quot;customer_inf&quot;)public class Customer extends Person&#123;&#125;// 员工类继承了Person类@Entity// 指定Employee实体对应的记录在辨别者列的值为&quot;员工&quot;@DiscriminatorValue(&quot;员工&quot;)@Table(name=&quot;employee_inf&quot;)public class Employee extends Person&#123;&#125; 连接子类的映射策略这种策略中父类实体保存在父类表中，而子类实体由父亲表和子类表共同存储，父类和子类共有部分存储在父类表，子类单独存在属性存储在子类表中。无需使用辨别者，只需要在继承树的根实体类上使用@Inheritance,指定strategy=InheritanceType.JOINED即可 12345678910@Entity@Inheritance(strategy=InheritanceType.JOINED)@Table(name=&quot;person_inf&quot;)public class Person&#123;&#125;@Entity@Table(name=&quot;customer_inf&quot;)public class Customer extends Person&#123;&#125;@Entity@Table(name=&quot;employee_inf&quot;)public class Employee extends Person&#123;&#125; 每个具体的类一个表的策略子类实例仅保存在子类表中，在父类表中没有任何记录。单从数据库来看，几乎难以看出继承关系，只是多个实体之间主键存在某种连续性，因此不能让数据库自动生成主键，因此不能使用GenerationType.IDENTITY和GenerationType.AUTO这两种主键生成策略。无需使用辨别者，只需要在继承树的根实体类上使用@Inheritance,指定strategy=InheritanceType.TABLE_PER_CLASS即可 1234@Entity@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)@Table(name=&quot;person_inf&quot;)public class Person&#123;&#125; 5. spring data注解 @CreatedBy：Declares a field as the one representing the principal that created the entity containing the field. @CreatedDate：Declares a field as the one representing the date the entity containing the field was created. @Id：Demarcates an identifier. @LastModifiedBy：Declares a field as the one representing the principal that recently modified the entity containing the field. @LastModifiedDate：Declares a field as the one representing the date the entity containing the field was recently modified. @ReadOnlyProperty：Marks a field to be read-only for the mapping framework and therefore will not be persisted. @Reference：Meta-annotation to be used to annotate annotations that mark references to other objects. @Transient：Marks a field to be transient for the mapping framework. Thus the property will not be persisted and not further inspected by the mapping framework. @TypeAlias：Annotation to allow String based type aliases to be used when writing type information for PersistentEntitys. @version: 定义一个属性为版本字段用于实现乐观锁 参考 《经典JAVAEE企业应用实战》 JPA API spring data commons源码 http://blog.csdn.net/u012881904/article/details/51059156","tags":[{"name":"java,JPA","slug":"java-JPA","permalink":"http://yoursite.com/tags/java-JPA/"}]},{"title":"GitLearn in 15 minutes","date":"2017-03-22T05:44:44.325Z","path":"2017/03/22/GitLearn in 15 minutes/","text":"学习来源：https://try.github.io/levels/1/challenges/1Git是一个开源的分布式版本控制系统（DVCS），可以显着改善您在项目中的工作方式和协作。 Git允许您保留对本地文件进行重大更改的历史记录。它还可以通过像GitHub这样的远程托管服务来备份这个历史记录。1.1 Got 15 minutes and want to learn Git?Git allows groups of people to work on the same documents (often code) at the same time, and without stepping on each other’s toes. It’s a distributed version control system. Our terminal prompt below is currently in a directory we decided to name “octobox”. To initialize a Git repository here, type the following command: Git允许一群人同时处理相同的文档（通常是代码），而不会踩在彼此的脚趾上。它是一个分布式版本控制系统。 我们的终端提示如下，目前我们决定命名为“octobox”。要在此处初始化Git存储库，请键入以下命令： 1git init 现在就创建了一个Git储存仓库并且生成了 .git文件夹 这个文件夹是用来存放有关仓库的所有的信息 1.2 Checking the Status （检查状态） Good job! As Git just told us, our “octobox” directory now has an empty repository in /.git/. The repository is a hidden directory where Git operates. To save your progress as you go through this tutorial – and earn a badge when you successfully complete it – head over to create a free Code School account. We’ll wait for you here. Next up, let’s type the git status command to see what the current state of our project is: 做得好！正如Git刚刚告诉我们的，我们的“octobox”目录现在在/.git/中有一个空的存储库。存储库是Git操作的隐藏目录。 通过本教程来节省您的进度，并在成功完成课程时获得徽章，以创建免费的Code School帐户。我们会在这里等你 接下来，我们输入git status命令来查看我们项目的当前状态： 1git status 经常运行git status是很健康的。有时事情改变，你不注意它。 可以看到当前的状态是 master 也就是主分支的状态 初始化commit 检查到没有东西要提交 因为仓库中是空的现在 1.3 Adding &amp; Committing I created a file called octocat.txt in the octobox repository for you (as you can see in the browser below). You should run the git status command again to see how the repository status has changed: 我在octobox存储库中为您创建了一个名为octocat.txt的文件（您可以在下面的浏览器中看到）。 您应该再次运行git status命令以查看存储库状态如何更改： staged: Files are ready to be committed. 这时候是用红色字体来显示的 说明文件已准备好提交。 unstaged: Files with changes that have not been prepared to becommitted. 在检查的时候发现一个具有尚未准备提交的更改的文件 Files aren’t tracked by Git yet. This usually indicates a newlycreated file. deleted: Git尚未跟踪文件。这通常表示新创建的文件。 deleted: File has been deleted and is waiting to be removed from Git.文件已被删除，正在等待从Git中删除 1.4 Adding ChangesGood, it looks like our Git repository is working properly. Notice how Git says octocat.txt is “untracked”? That means Git sees that octocat.txt is a new file. To tell Git to start tracking changes made to octocat.txt, we first need to add it to the staging area by using git add. 好的，看起来我们的Git仓库正常工作。注意Git如何说octocat.txt是“未被追踪的”？这意味着Git看到octocat.txt是一个新的文件。 要告诉Git开始跟踪对octocat.txt进行的更改，我们首先需要使用git add将其添加到暂存区域。 add all: You can also type git add -A . where the dot stands for thecurrent directory, so everything in and beneath it is added. The -Aensures even file deletions are included. 您也可以输入git add -A。代表当前目录下的所有文件都被添加到暂存仓库中。 -A 确保包括文件删除。 git reset: You can use git reset &lt;filename&gt; to remove a file or filesfrom the staging area 您可以使用git reset 从分段区域中删除文件。 1.5 Checking for Changes再次检查状态 Staging Area: A place where we can group files together before we“commit” them to Git. Commit 暂存区域：在我们将“提交”到Git之前，我们可以将文件暂存在一起的地方。 A “commit” is a snapshot of our repository. This way if we ever needto look back at the changes we’ve made (or if someone else does), wewill see a nice timeline of all changes. 一次“提交”是我们存储库的一个快照。这样，如果我们需要回顾我们所做的更改（或者如果有人做的），我们将会看到一个很好的时间轴关于这些的改变。 1.6 CommittingNotice how Git says changes to be committed? The files listed here are in the Staging Area, and they are not in our repository yet. We could add or remove files from the stage before we store them in the repository. To store our staged changes we run the commit command with a message describing what we’ve changed. Let’s do that now by typing: 注意Git如何说改变被提交了？这里列出的文件位于“暂存区”中，它们不在我们的存储库中。我们可以在将它们存储在存储库之前，从暂存区添加或删除文件。 要存储我们改变了什么，我们运行commit命令，并附带一条描述我们已经更改的消息。现在我们来输入： 1$ git commit -m \"Add cute octocat story\" Wildcards: We need quotes so that Git will receive the wildcard before our shell can interfere with it.Without quotes our shell will only execute the wildcard search within the current directory.Git will receive the list of files the shell found instead of the wildcard andit will not be able to add the files inside of the octofamily directory. 通配符： 我们需要引号，以便在我们的shell可以干扰之前，Git会收到通配符。没有引号，我们的shell只会在当前目录中执行通配符搜索。 Git将收到shell找到的文件列表，而不是通配符，它​​将无法在octofamily目录中添加文件。 1.7 Adding All Changes Great! You also can use wildcards if you want to add many files of the same type. Notice that I’ve added a bunch of .txt files into your directory below. I put some in a directory named “octofamily” and some others ended up in the root of our “octobox” directory. Luckily, we can add all the new files using a wildcard with git add. Don’t forget the quotes! 棒极了，如果要添加相同类型的许多文件，也可以使用通配符。请注意，我已经将一堆.txt文件添加到您的目录下面。 一个名为“octofamily”的目录中有两个，其他一些最终在我们的“octobox”目录的根。幸运的是，我们可以使用git add通配符添加所有新文件。不要忘记引号！ Check all the things!When using wildcards you want to be extra careful when doing commits. Make sure to check what files and folders &gt;are staged by using git status before you do the actual commit. This way you can be sure you’re committing only the things you want. 检查所有的事情！ 当使用通配符时，你在做提交时要特别小心。确保在执行实际提交之前使用git status检查要暂存的文件和文件夹。这样，你可以确保你t提交的只是你想要的东西。 1.8 Committing All Changes Okay, you’ve added all the text files to the staging area. Feel free to run git status to see what you’re about to commit. If it looks good, go ahead and run: More useful logs:Use git log –summary to see more information foreach commit. You can see where new files were added for the first timeor where files were deleted. It’s a good overview of what’s going on in the project. 更有用的日志： 使用git log –summary查看每个提交的更多信息。您可以看到第一次添加新文件的位置或删除文件的位置。这是一个很好的概述，在项目中发生了什么。 1.9 HistorySo we’ve made a few commits. Now let’s browse them to see what we changed. Fortunately for us, there’s git log. Think of Git’s log as a journal that remembers all the changes we’ve committed so far, in the order we committed them. Try running it now: 所以我们做了一些提交。现在让我们浏览他们看看我们改变了什么。 幸运的是，我们有git log。想想Git的日志是一本记录，记录我们迄今为止所做的所有变化，按照我们提交的顺序。尝试运行它： git remote: Git doesn’t care what you name your remotes, but it’s typical to name your main one origin. It’s also a good idea for your main repository to be on a remote server like GitHub in case yourmachine is lost at sea during a transatlantic boat cruise or crushedby three monkey statues during an earthquake. git远程 Git不在乎你命名你的远程，但它的典型名称是你的主要来源（orign）。 如果您的主机位于远程服务器，如GitHub，如果您的机器在海洋中丢失，在跨大西洋的船只巡航或在地震期间被三只猴子雕像压碎，这也是一个好主意。 1.10 Remote Repositories（远程仓库）Great job! We’ve gone ahead and created a new empty GitHub repository for you to use with Try Git at https://github.com/try-git/try_git.git. To push our local repo to the GitHub server we’ll need to add a remote repository. This command takes a remote name and a repository URL, which in your case is https://github.com/try-git/try_git.git. Go ahead and run git remote add with the options below: 做得好！我们已经开始创建了一个新的空的GitHub存储库，供您与Try Git一起使用，网址为https：//github.com/try-git/try_git.git。要将我们的本地repo推送到GitHub服务器，我们需要添加一个远程仓库。 此命令使用远程名称和存储库URL，在您的情况下，它是https://github.com/try-git/try_git.git。 继续运行git远程添加与以下选项： 1git remote add origin https://github.com/try-git/try_git.git Cool Stuff:When you start to get the hang of git you can do some really cool things with hooks when you push.For example, you can upload directly to a webserver whenever you push to your master remoteinstead of having to upload your site with an ftp client. Check outCustomizing Git - Git Hooks for more information. 很酷的东西： 当你开始得到git的挂起，你可以做一些非常酷的东西与钩子，当你push。 例如，您可以直接上传到网络服务器，只要您推送到主控远程，而不必使用ftp客户端上传您的站点。查看自定义Git - Git Hooks了解更多信息。 1.11 Pushing RemotelyThe push command tells Git where to put our commits when we’re ready, and now we’re ready. So let’s push our local changes to our origin repo (on GitHub). The name of our remote is origin and the default local branch name is master. The -u tells Git to remember the parameters, so that next time we can simply run git push and Git will know what to do. Go ahead and push it! push命令告诉Git当我们准备好时，在哪里放置我们的提交，现在我们准备好了。所以我们把我们的地方变化推到我们的起始地位（在GitHub上）。 我们的远程的名称是origin，默认的本地分支名称是master。 -u告诉Git记住参数，所以下次我们可以简单的运行git push，Git会知道该怎么做。继续推动！ 1$ git push -u origin master 1.12 Pulling RemotelyLet’s pretend some time has passed. We’ve invited other people to our GitHub project who have pulled your changes, made their own commits, and pushed them. We can check for changes on our GitHub repository and pull down any new changes by running: 假设有一段时间过去了我们邀请其他人加入我们的GitHub项目，他们已经拉下了你的修改，提交了自己的提交，并推送他们。 我们可以检查我们的GitHub存储库中的更改，并通过运行以下命令来删除任何新的更改 1git pull origin master HEADThe HEAD is a pointer that holds your position within all yourdifferent commits. By default HEAD points to your most recent commit,so it can be used as a quick way to reference that commit withouthaving to look up the SHA. 头 HEAD是一个指针，可以在您所有不同的提交内保持您的位置。默认情况下，HEAD指向您最近的提交，因此可以将其用作引用该提交的快速方式，而无需查找SHA 1.13 DifferencesUh oh, looks like there have been some additions and changes to the octocat family. Let’s take a look at what is different from our last commit by using the git diff command. In this case we want the diff of our most recent commit, which we can refer to using the HEAD pointer. 呃哦，看起来已经有了一些补充和改变octocat家庭。让我们通过使用git diff命令来看看与上一次提交不同的是什么。 在这种情况下，我们需要我们最近提交的diff，我们可以参考使用HEAD指针。 1git diff HEAD Commit Etiquette: You want to try to keep related changes together in separate commits. Using ‘git diff’ gives you a good overview ofchanges you have made and lets you add files or directories one at atime and commit them separately. 提交礼仪： 您想尝试将相关更改保留在单独的提交中。使用’git diff’可以很好地概述所做的更改，并允许您一次添加一个文件或目录，并单独提交它们。 1.14 Staged DifferencesAnother great use for diff is looking at changes within files that have already been staged. Remember, staged files are files we have told git that are ready to be committed. Let’s use git add to stage octofamily/octodog.txt, which I just added to the family for you. diff的另一个很好的用途是查看已经上架的文件中的更改。记住，暂存文件是我们已经告诉git的文件，可以提交。 让我们使用git add来分配octofamily / octodog.txt，我刚刚为你添加了家庭。 1git add octofamily/octodog.txt 1.15 Staged Differences (cont’d)Good, now go ahead and run git diff with the –staged option to see the changes you just staged. You should see that octodog.txt was created.好，现在继续运行git diff与–staged选项，以查看刚刚暂存的更改。你应该看到octodog.txt被创建。 1git diff --staged 1.16 Resetting the StageSo now that octodog is part of the family, octocat is all depressed. Since we love octocat more than octodog, we’ll turn his frown around by removing octodog.txt. You can unstage files by using the git reset command. Go ahead and remove octofamily/octodog.txt. 所以现在octodog是家庭的一部分，octocat是所有郁闷。因为我们喜欢octocat超过octodog，我们将转过他的皱眉，删除octodog.txt。 您可以使用git reset命令来解压缩文件。继续去除octofamily / octodog.txt。 1git reset octofamily/octodog.txt The ‘–’So you may be wondering, why do I have to use this ‘–’ thing? git checkout seems to work fine without it. It’s simply &gt;promising the command line that there are no more options after the ‘–’. This way if you happen to have a branch &gt;named octocat.txt, it will still revert the file, instead of switching to the branch of thesame name. ‘ - ‘ 所以你可能会想，为什么我必须使用这个’ - ‘的东西？ git结帐似乎工作正常没有它。它只是承诺命令行，在’ - ‘之后没有更多的选项。这样，如果碰巧有一个名为octocat.txt的分支，它仍然会还原文件，而不是切换到相同名称的分支。 1.17 Undogit reset did a great job of unstaging octodog.txt, but you’ll notice that he’s still there. He’s just not staged anymore. It would be great if we could go back to how things were before octodog came around and ruined the party. Files can be changed back to how they were at the last commit by using the command: git checkout – . Go ahead and get rid of all the changes since the last commit for octocat.txt git reset做了一个伟大的工作，不在暂存octodog.txt，但你会注意到，他还在那里。他只是没有在暂存区了。如果我们可以回到上次的时候，那将是很美好的。 可以使用以下命令将文件更改回上次提交的方式：git checkout - &lt;target&gt;。继续前进，摆脱上次提交octocat.txt以来的所有更改 1git checkout -- octocat.txt Branching Branches are what naturally happens when you want to work onmultiple features at the same time. You wouldn’t want to end up with amaster branch which has Feature A half done and Feature B half done.Rather you’d separate the code base into two “snapshots” (branches)and work on and commit to them separately. As soon as one was ready,you might merge this branch back into the master branch and push it tothe remote server. 分枝 当您想同时处理多个功能时，分支机构是自然会发生的。你不想结束一个主分支，其中功能A一半完成，功能B一半完成。 相反，你会将代码库分成两个“快照”（分支），并分别处理和提交。一旦准备就绪，您可以将该分支合并回主分支并将其推送到远程服务器。 1.18 Branching OutWhen developers are working on a feature or bug they’ll often create a copy (aka. branch) of their code they can make separate commits to. Then when they’re done they can merge this branch back into their main master branch. We want to remove all these pesky octocats, so let’s create a branch called clean_up, where we’ll do all the work: 当开发人员正在开发一个功能或错误时，他们经常会创建一个他们的代码的副本（也称为分支），他们可以单独提交。然后当他们完成后，他们可以合并这个分支回他们的主要分支。 我们想删除所有这些讨厌的octocats，所以让我们创建一个名为clean_up的分支，我们将在其中完成所有的工作： 1$ git branch clean_up You can use:git checkout -b new_branch to checkout and create abranch at the same time. This is the same thing as doing: git branchnew_branch git checkout new_branch 中文(简体)您可以使用： git checkout -b new_branch 同时创建并且创建一个分支。他们和这样是在做事情： git branch new_branch git checkout new_branch Remove all the things! Removing one file is great and all, but what if you want to remove an entire folder? You can use the recursive option on git rm: git rm -r folder_of_cats This will recursively remove allfolders and files from the given directory. 删除一个文件是伟大的，所有，但如果要删除整个文件夹怎么办？您可以在git rm上使用递归选项： git rm -r folder_of_cats 这将递归地删除给定目录中的所有文件夹和文件。 1.20 Removing All The ThingsOk, so you’re in the clean_up branch. You can finally remove all those pesky octocats by using the git rm command which will not only remove the actual files from disk, but will also stage the removal of the files for us. You’re going to want to use a wildcard again to get all the octocats in one sweep, go ahead and run: 的，所以你在clean_up分支。您可以使用git rm命令，最终删除所有那些讨厌的octocats，它不仅可以从磁盘中删除实际的文件，还可以为我们移除文件。 您将要再次使用通配符将所有octocats一次性扫描，然后运行： 1git rm '*.txt' The ‘-a’ option If you happen to delete a file without using ‘git rm’you’ll find that you still have to &#39;git rm&#39; the deleted files from the working tree. You can save this step by using the ‘-a’ option on &#39;git commit&#39;, which auto removes deleted files with the commit. git commit -am &quot;Delete stuff&quot; ‘-a’选项 如果你碰巧删除一个文件而不使用’git rm’，你会发现你仍然需要从工作树中删除已删除的文件。您可以使用’git commit’上的’-a’选项来保存此步骤，该选项会通过提交自动删除已删除的文件。 git commit -am“删除东西” 1.21 Commiting Branch ChangesNow that you’ve removed all the cats you’ll need to commit your changes. Feel free to run git status to check the changes you’re about to commit.现在你已经删除了所有需要提交更改的猫。 随意运行git状态以检查您要提交的更改。 1.22 Switching Back to masterGreat, you’re almost finished with the cat… er the bug fix, you just need to switch back to the master branch so you can copy (or merge) your changes from the clean_up branch back into the master branch. Go ahead and checkout the master branch:好的，你几乎完成了这个错误修复，你只需要切换回主分支，所以你可以将你的更改从clean_up分支复制（或合并）到主分支中。 继续检查主分支： 1git checkout master Pull RequestsIf you’re hosting your repo on GitHub, you can do something called a pull request.A pull request allows the boss of the project to look through your changes and make comments before deciding to merge in the change. It’s a really great feature that is used all the time for remote workers and open-source projects.Check out the pull request help page for more information. 拉取请求 如果您在GitHub上托管您的项目，您可以进行一些称为拉动请求的操作。 拉动请求允许项目的老板在决定合并更改之前，先查看更改并发表评论。这是一个非常好的功能，它一直用于远程工作和开源项目。 请查看拉动请求帮助页面以获取更多信息。 1.23 Preparing to MergeAlrighty, the moment has come when you have to merge your changes from the clean_up branch into the master branch. Take a deep breath, it’s not that scary. We’re already on the master branch, so we just need to tell Git to merge the clean_up branch into it: 好的，当你必须将clean_up分支中的更改合并到主分支时，现在已经到了。深吸一口气，这不是那么可怕。 我们已经在主分支上，所以我们只需要告诉Git将clean_up分支合并到它中： 1git merge clean_up Merge ConflictsMerge Conflicts can occur when changes are made to afile at the same time. A lot of people get really scared when aconflict happens, but fear not! They aren’t that scary, you just needto decide which code to keep. Merge conflicts are beyond the scope ofthis course, but if you’re interested in reading more, take a look thesection of the Pro Git book on how conflicts are presented. 合并冲突 合并冲突可能会发生在同时对文件进行更改时。很多人在发生冲突时真的害怕，但不要害怕！他们不是那么可怕，你只需要决定保留哪些代码。 合并冲突超出了本课程的范围，但如果您有兴趣阅读更多内容，请查看Pro Git书中有关如何呈现冲突的部分 Force deleteWhat if you have been working on a feature branch and youdecide you really don’t want this feature anymore? You might decide todelete the branch since you’re scrapping the idea. You’ll notice thatgit branch -d bad_feature doesn’t work. This is because -d won’t letyou delete something that hasn’t been merged. You can either add the--force (-f) option or use -D which combines -d -f together into one command. 强制删除 如果您在功能部门工作，而且您决定不再需要此功能，该怎么办？你可能会决定删除分支，你会注意到git branch -d bad_feature不工作。这是因为-d不会让您删除未合并的内容。 您可以添加–force（-f）选项，或者使用-D组合-d -f到一个命令中。 1.24 Keeping Things CleanCongratulations! You just accomplished your first successful bugfix and merge. All that’s left to do is clean up after yourself. Since you’re done with the clean_up branch you don’t need it anymore. You can use git branch -d &lt;branch name&gt; to delete a branch. Go ahead and delete the clean_up branch now: 恭喜！你刚刚完成了你的第一个成功的修正和合并。所有剩下要做的就是清理自己。因为你已经完成了clean_up分支，你不再需要它。 你可以使用git branch -d &lt;branch name&gt;删除一个分支。继续并删除clean_up分支： 1.25 The Final PushHere we are, at the last step. I’m proud that you’ve made it this far, and it’s been great learning Git with you. All that’s left for you to do now is to push everything you’ve been working on to your remote repository, and you’re done! 在这里，我们在最后一步。我很自豪，你已经做到这一点，这是伟大的学习Git与你。现在剩下的一切就是把你一直在做的一切都推送到你的远程仓库，你已经完成了！ 1git push Learning more about GitWe only scratched the surface of Git in this course. There is so much more you can do with it. Check out the Git documentation for a full list of functions.The Pro Git book, by Scott Chacon, is an excellent resource to teach you the inner workings of Git.help.github and GitHub Training are also great for anything related to Git in general and using Git with GitHub. 学习更多关于Git 我们在这个课程中只刮了Git的表面。还有更多的你可以做到这一点。查看Git文档的完整功能列表。 由Scott Chacon撰写的Pro Git书是教你Git内部工作的绝佳资源。 help.github和GitHub培训对于与Git有关的任何事情也是非常好的，并且使用Git与GitHub。","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"通过Git上传项目的Github","date":"2017-03-22T03:15:43.018Z","path":"2017/03/22/通过Git上传项目的Github/","text":"通过Git上传项目的Github首先我们先来介绍一下GitGit 与版本控制 版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 虽然基于 Git 的工作流可能并不是一个非常好的实践，但是在这里我们以这个工作流做为实践来开展我们的项目。如下图所示是一个基于 Git 的项目流： 我们日常会工作在 “develop” 分支（那条线）上，通常来说每个迭代我们会发布一个新的版本，而这个新的版本将会直接上线到产品环境。那么上线到产品环境的这个版本就需要打一个版本号——这样不仅可以方便跟踪我们的系统，而且当出错的时候我们也可以直接回滚到上一个版本。如果在上线的时候有些 Bug 不得不去修复，并且由于上线的新功能很重要，我们就需要 修补程序。而从整个过程来看，版本控制起了一个非常大的作用。 不仅仅如此，版本控制的最大重要是在开发的过程中扮演的角色。通过版本管理系统，我们可以： 将某个文件回溯到之前的状态。 将项目回退到过去某个时间点。 在修改 Bug 时，可以查看修改历史，查出修改原因 只要版本控制系统还在，你可以任意修改项目中的文件，并且还可以轻松恢复。 常用的版本管理系统有 Git、SVN，但是从近年来看 Git 似乎更受市场欢迎。 ##Git 从一般开发者的角度来看，Git 有以下功能： 从服务器上克隆数据库（包括代码和版本信息）到单机上。 在自己的机器上创建分支，修改代码。 在单机上自己创建的分支上提交代码。 在单机上合并分支。 新建一个分支，把服务器上最新版的代码 fetch 下来，然后跟自己的主分支合并。 -生成补丁（patch），把补丁发送给主开发者。 看主开发者的反馈，如果主开发者发现两个一般开发者之间有冲突（他们之间可以合作解决的冲突），就会要求他们先解决冲突，然后再由其中一个人提交。如果主开发者可以自己解决，或者没有冲突，就通过。 一般开发者之间解决冲突的方法，开发者之间可以使用 pull 命令解决冲突，解决完冲突之后再向主开发者提交补丁。从主开发者的角度（假设主开发者不用开发代码）看，Git 有以下功能：1.查看邮件或者通过其它方式查看一般开发者的提交状态。2.打上补丁，解决冲突（可以自己解决，也可以要求开发者之间解决以后再重新提交，如果是开源项目，还要决定哪些补丁有用，哪些不用）。3.向公共服务器提交结果，然后通知所有开发人员。 Git 初入如果是第一次使用 Git，你需要设置署名和邮箱： 12$ git config --global user.name \"用户名\"$ git config --global user.email \"电子邮箱\" 你可以在 GitHub 新建免费的公开仓库或在 Coding.net 新建免费的私有仓库。 新建一个Repository 按照 GitHub 的文档 或 Coding.net 的文档 配置 SSH Key，然后将代码仓库 clone 到本地，其实就是将代码复制到你的机器里，并交由 Git 来管理： 12$ git clone git@github.com:username/repository.git或$ git clone git@git.coding.net:username/repository.git 或使用 HTTPS 地址进行 clone： 123$ git clone https://username:password@github.com/username/repository.git或$ git clone https://username:password@git.coding.net/username/repository.git 复制地址： 克隆到本地： 克隆完成后的样子，会在文件夹下生成.git这就说明已经和远程仓库建立了连接 这里的代码我后来加进去的 如果项目是空的 只有.git 你可以修改复制到本地的代码了（ symfony-docs-chs 项目里都是 rst 格式的文档）。当你觉得完成了一定的工作量，想做个阶段性的提交： 向这个本地的代码仓库添加当前目录的所有改动： 1$ git add . 或者只是添加某个文件： 1$ git add -p 我在项目中添加了了一个文件用 ==ｇｉｔ ｓｔａｔｕｓ== 来查看状态 红色的说明还没有被添加到ｇｉｔ仓库中 添加完之后 我们再次查看状态 发现已经变绿了 我们可以输入 1$ git status 可以看到状态的变化是从红色色到绿色，即 unstage 到 add。在完成添加之后，我们就可以写入相应的提交信息——如这次修改添加了什么内容 、这次修改修复了什么问题等等。在我们的工作流程里，我们使用 Jira 这样的工具来管理我们的项目，也会在我们的 Commit Message 里写上作者的名字，如下： 1$ git commit -m \"nengneng : first commit\" 在这里的nengneng 对应于用户名，后面的提交信息也会写明这个任务是干嘛的。 由于有测试的存在，在完成提交之后，我们就需要运行相应的测试来保证我们没有破坏原来的功能。因此，我们就可以PUSH我们的代码到服务器端： 1$ git push 最后 我们去github 上传的仓库看看我们上传的项目： 大功告成","tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"Web开发全栈工程师2017路线图","date":"2017-03-20T02:10:00.484Z","path":"2017/03/20/Web开发全栈工程师2017路线图/","text":"100+免费资源用于学习全栈Web开发下面的列表并不意味着是排他性的，它更像是一个链接的集合，帮助我一路上（并希望可以帮助你）。如你所见，我专注于Javascript，React和Node.js.还有大量关于面试准备和申请工作的信息 我还有很多书签，所以我会更新和添加链接，因为我去。如果你有贡献，请随时提交公关！目录 开始 怎么学 什么是最有用的CS书签 程序和类 Learn HTML Learn CSS Learn Javascript Learn React.js Full Stack Tutorials Learn Node.js Learn APIs Learn Databases 学习认证 Learn Git Games &amp; Challenge Websites Free Programming Books Open Source Contribution Opportunities Am I Ready to be a Developer? Software Developer Success Stories Resume’s，Portfolio，LinkedIn，面试准备和薪资信息 Start Here Take a look at the big picture: Web Developer Roadpath Youtube video outlining what to learn (similar to above, but in video format) - Watch this if you want to become a web developer My journey to becoming a web developer from scratch without a CS degree (and what I learned from it) (Medium) What happens when you type google into your address bar? [Reddit Link] Tuts Plus - The http protocol every web developer must know Find a local Web Development related Meetup! How to Learn How to Learn. Coursera Course (Not CS Specific) - Learning how to learn Repetition, Repetition, Repetition - A great discussion on study techniques Reddit Post What is the Single most useful CS Bookmark you have? What is the single most useful CS Bookmark you have? [Reddit Link] Learn X in Y Minutes What CS Majors Should Know Google’s Technical Development Guide CSS Tricks - Complete Flexbox Guide Regex Cheat Sheet DevDocs Awesome List of Everything Programming How to Break Into the Tech Industry—a Guide to Job Hunting and Tech Interviews Programs and Classes Programs The Odin Project freeCodeCamp The Essential Web Developer Course Classes SANITIZED list of 530+ free online programming/CS courses (MOOCs) with feedback(i.e. exams/homeworks/assignments) that you can start this month (December 2016) - Needs Updating Udacity Free Web Development Courses (Google) Assorted Reddit Links (Still need to sort) Tutorial/Screencast: Let’s Learn Algorithms: An Intro to Binary Search Thoughts on Coding Boot camps The Complete Guide to Bootcamps Self Study - My programming notes. 275 Pages of Content [Updated Reddit Link] [Original Reddit Link] Javascript / Node / Angular 1 &amp; 2 / React / Elm / C# / PHP / SQL / Git Google Drive What to do after Colt Steele’s course Watch And Code RegexOne - Learn Regular Expressions Google University Github Repo Learn HTMLAnyone have any cool HTML links? Learn CSS Everything you need to know about Flexbox Seriously the best Flexbox resource I’ve found A visual guide to CSS - CSS Reference CSS Pro Tips - A collection of tips to help take your CSS skills pro. 10 principles for smooth web animations Learn Javascript Javascript Docs Courses/Tutorials Courses.AngularClass.com - Topics Include: webpack, nodejs, npm, es5, es6, esnext, &amp; rxjs, typescript [Course Link] [Reddit Post] Edabit - Learn Javascript With Interactive Challenges: Earn XP, Unlock Achievements &amp; Climb The Leaderboard [Edabit - Website Link] [Reddit Post] Free Advanced JavaScript Courses - Learn Object Oriented Programming, Call Apply, and Bind, Testing, Functional Programming, and much more Intermediate Course - Udacity - OOP JS Projects JS 30 For 30 - 30 Projects for 30 Days Learn to Code with Projects - enlight.ml 13 Weeks of Javascript (Medium) - TONS of links to JS resources Articles/Books Recursion, Recursion, Recursion (Medium) Eloquent JS - Free Javascript Ebook You don’t know JS - Free, hosted on Github Javascript Garden - learn about the quirky parts of JS JS - The Good Parts .pdf Learning js Design patterns - Reusable solutions to commonly occurring problems Asynchronous Module Definition Learn React JS Official React Docs Official React Tutorial 3rd Party Tutorials 10 React Mini Patterns Top 5 Tutorials for getting started with React 10 best ReactJS tutorials React Starter Project Search Exploring the react Ecosystem! - Article Code academy React program Great Free React books - Use this link first Medium Links: React Components, Elements, and Instances (Medium) Working with React Beginners guide to React Router (Medium) Angular JS vs React JS (Medium) Full Stack Tutorials Intro to Back End Web Development Deploying Applications with Heroku Client Server Communication Serverless Stack is a comprehensive guide to creating full-stack serverless applications. Create a note taking app from scratch using React.js, AWS Lambda, API Gateway, DynamoDB, and Cognito. Express - Using a DB with Mongoose Node JS and Databases Node JS and Authentication Express JS Database Integration MERN Stack Tutorial - Mongo, Express, React, Node MongoDB MERN Tutorial Series Full Stack MERN Tutorial - Youtube Build a URL Shortener with Node, Hapi, and Mongo How to Create a Complete Express.js + Node.js + MongoDB CRUD and REST Skeleton Building web app using react.js, express.js, node.js and mongodb - Part 1, 2 Trello tribute with Phoenix, React, Redux, PostgreSQL - 12 parts Create a character voting app using React, Node.js, MongoDB and Socket.IO Building a React Universal Blog App: A Step-by-Step Guide Building a Secure RESTful Node.js app Cool stuff other people have built: Belgian Beer Explorer with React, Bootstrap, Node.js and Postgres 90 Full Stack React Examples (some with tuts) Learn Node JS Official Node.js Docs Best Resource for learning Node.js [Reddit Link] Youtube Colt Steele’s Bootcamp Node School Medium - Why the hell would you use Node? Building a modern backend API with Node Node JS Login with Passport - Youtube 10 Best Practices for Writing Node.js REST APIs Learn APIs Where to start with learning APIs [Reddit Link] What is an API? In English Please. (Medium) Build Node.js RESTful APIs in 10 Minutes Free Intro to APIs Book/Course by Zapier Google Maps API Distance Calculator Web Services API Build and Secure a Backend API Server Learn Databases SQL vs NoSQL Intro to Relational Databases - SQL, DB-API, and More! MongoDB University - Numerous classes on learning MongoDB PostgreSQL Tutorial PostgreSQL Exercises Learn PostgreSQL (Github) Try Redis Redis Tutorial Learn Authentication Authentication &amp; Authorization: OAuth Learn about JSON Web Tokens OAuth 2 Passwordless Authentication with React and Auth0 Learn Git Official Tutorial - Learn Git in 15 Minutes Official Docs Other Tuts: Git, the simple guide Learn Git Branching - Level by Level learning Learn Git in 30 Minutes - Article Here are all the Git commands I used last week and what they do (Medium) Why to Use GIT No, I have no side projects to show you Games and Challenge Websites Games to learn Programming in an easy and fun way [Reddit Link] Flex Box Froggy Flex Box Defense Edabit Coding Game Elevator Saga - JS Scratch - Absolute Basics Hacked - Mobile App teaching through puzzles Coding Challenge Websites [Reddit Link] [Reddit Link #2] Medium - 10 most popular coding challenge sites of 2016 Code Wars Coding Game Hacker Rank (some debate about this being good/bad Project Euler (math focus) Exercism Free Programming Books O’Reilly Offering Programming eBooks for Free (Reddit) GitHub - Thousands of free programming Books on every topic Non-Technical Books to make you a better Programmer (Reddit) Open Source Contribution Opportunities Contributing to Open Source on GitHub - The official GitHub guide. How do I get skilled enough to work on open source projects? Open Source Contribution Opportunites [Reddit Discussion] Redditor Form to fill out to get notified about Open Source Opportunities Up For Grabs - Browse a list of projects with curated tasks Hacktoberfest - Open source activity held every October. Easy to participate, and you get a free t-shirt! I’m afraid if I say anything on Github people will laugh at me and I will die. Am I Ready to be a Developer? Readiness Self taught front end devs… When did you know that you were “Job ready”? People who are self-taught developers, how long did it take you to get your first job? When do you know when you’re ready to start interviewing? Software developers- what is the best advice you have for people learning CS? I want a career in programming What should you know as a web dev just out of college? Reddit Discussion - newer What CS Majors Should Know - older How I got started with Side Projects - link What are some goals a beginning Self-Taught Developer should have? Computer programmers of Reddit, what is your best advice to someone who is currently learning how to code? I began teaching myself to code a year ago. I got hired at my first job 4 months ago. Here is a breakdown of somethings I was not ready for (FYI job is remote ruby/rails dev) Software Developer Success Stories Success Stories 18 months ago I didn’t know how to code, I’m now a self-taught programmer who’s made apps for the NBA, NHL, and schools like Purdue, Notre Dame, Alabama and Clemson. I’m now releasing my software under the MIT license for anyone’s use — AMA! Last year I was unemployed and miserable. Using this sub and resources, I’ve been full time employed for a year. I did it with all free resources. I wanna share with you how I did it. (IOS) I began teaching myself to code a year ago. I got hired at my first job 4 months ago. Here is a breakdown of somethings I was not ready for (FYI job is remote ruby/rails dev) I’m 32 years old, and just started my first full-time job as a developer. One year ago my programming knowledge was basically nil. Everything I learned, I found via /r/learnprogramming, so just wanted to share my experience. From zero to software developer - Not really a success story, but a lot of redditors share how they learned. Great for beginners with no path Get The JobResume, Portfolio, LinkedIn, Interview Prep, and Salary Information How to Apply I spent 3 months applying to jobs after a coding bootcamp. Here’s what I learned. (Medium) Lessons from my Post-bootcamp Job search (Medium) How to land a six figure job in tech with no connections (Medium) Resume &amp; LinkedIn What are some of the best resuмe formats you’ve seen? Model examples for Fullstack Developer LinkedIn profiles Personal Projects Recruiters, what kind of CS projects impress? Interview Prep CS50 - Prep and Practice for Technical Interviews [YouTube] How to Break Into the Tech Industry—a Guide to Job Hunting and Tech Interviews Common Javascript Interview Questions Repo Github Repo - All questions and answers Reddit Post - Discussion, with additional questions and answers Ammon Bartram - Ask an interviewer anything: interview questions, answers, mistakes Sharing some interview tips (Silicon valley employee) Job interview questions to ask the interviewer I suck at programming interviews. When solving an interview problem, talk all the time. Hiring managers (or other seasoned developers), what qualities do you look for in your ideal candidate? Post your best interview questions Been interviewing with a lot of tech startups as a frontend dev, here are the technical questions I’ve been asked (MID-SENIOR LEVEL) 10 Interview Questions every JS Developer should know (Medium) Salary Information 12/2016 Salary Sharing Thread (&lt;2 yrs Experience) Salary Negotiations and how not to set a bunch of money on fire (Medium) 10 Rules for negotiating a job offer (Medium) How not to bomb your offer negotiation (Medium)","tags":[{"name":"Web开发","slug":"Web开发","permalink":"http://yoursite.com/tags/Web开发/"}]},{"title":"Web开发者2017路线图","date":"2017-03-20T01:38:27.548Z","path":"2017/03/20/Web开发者2017路线图/","text":"2017年Web开发者的学习路线图 下面您将找到一组图表，说明您可以采取的路径和您想要采用的技术，以便成为前端，后端或devops。我为我的一位老教授制作了这些图表，他想要与大学生分享他们的观点。 如果你认为这些都可以改进反正，请做建议。 🚀 介绍 🎨前端路线图 👽 后端路线图对于后端，我个人喜欢Node JS和PHP-7的全时间，我已经尝试了最近的Go和我非常喜欢它。除了这些，如果我要选择另一个，我会去Ruby。但这只是我个人的喜好，你可以选择任何显示的语言，你会好的。 👷 DevOps的路线图 🚦 Wrap Up如果你认为任何路线图可以改进，请打开公关与任何更新，并提交任何问题。此外，我会继续改进这一点，所以你可能想要观察/ star这个存储库重新访问。 ☑ TODO [X] Add Frontend Roadmap [X] Add Backend Roadmap [X] Add DevOps Roadmap [ ] Add relevant resources for each 👬 ContributionThe roadmaps are built using Balsamiq. Project file can be found at /ROADMAPS.bmpr, open it in balsamiq, do the necessary modifications, export the diagrams as PNG files, put them in the Readme at relevant places and create a PR. Open pull request with improvements Discuss ideas in issues Spread the word Reach out to me directly at kamranahmed.se@gmail.com or on twitter @kamranahmedse Licence Roadmap to becoming a web developer in 2017 Below you find a set of charts demonstrating the paths that you can take and the technologies that you would want to adopt in order to become a frontend, backend or a devops. I made these charts for an old professor of mine who wanted something to share with his college students to give them a perspective. If you think that these can be improved in anyway, please do suggest. 🚀 Introduction 🎨 Frontend Roadmap 👽 Backend RoadmapFor the backend, personally I would prefer Node JS and PHP-7 for the full time plus I have been experimenting lately with Go and I quite like it. Apart from these, if I have to choose another one, I would go for Ruby. However this is just my personal preference, you can choose any of the shown languages and you will be good. 👷 DevOps Roadmap 🚦 Wrap UpIf you think any of the roadmaps can be improved, please do open a PR with any updates and submit any issues. Also, I will continue to improve this, so you might want to watch/star this repository to revisit. ☑ TODO [X] Add Frontend Roadmap [X] Add Backend Roadmap [X] Add DevOps Roadmap [ ] Add relevant resources for each 👬 ContributionThe roadmaps are built using Balsamiq. Project file can be found at /ROADMAPS.bmpr, open it in balsamiq, do the necessary modifications, export the diagrams as PNG files, put them in the Readme at relevant places and create a PR. Open pull request with improvements Discuss ideas in issues Spread the word Reach out to me directly at kamranahmed.se@gmail.com or on twitter @kamranahmedse Licence","tags":[{"name":"Web开发","slug":"Web开发","permalink":"http://yoursite.com/tags/Web开发/"}]},{"title":"JVM学习笔记（三）垃圾收集器与内存分配策略","date":"2017-03-18T05:20:25.061Z","path":"2017/03/18/JVM学习笔记（三）垃圾收集器与内存分配策略/","text":"第二部分 垃圾收集器与内存分配策略Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人想出来。概述垃圾收集（Garbage Collection，GC）需要完成的三件事情: 1 哪些内存需要回收？ -[] 内存区域-回收条件2 什么时候回收？ -[] 多线程/安全点3 如何回收？ -[] 回收算法 当要排查各种内存溢出、内存泄漏问题时，当垃圾收集称为系统达到更高并发量的瓶颈时，我们就需要对这些”自动化”的技术实施必要的监控和调节。 1.程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；每一个栈帧中分配多少内存基本上在类结构确定下来的时候就已知。因此这几个区域的内存分配和回收都具有确定性，不需过多考虑回收问题，方法结束或者线程结束时，内存自然就随之回收了。2.Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，只有在程序处于运行期间才知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存！ 对象已死吗？垃圾回收器在对堆进行回收前，首要确定的事情就是这些对象之间哪些还存活着，哪些已经死去？ 引用计数算法 定义：引用计数算法（Reference Counting）:给对象添加一个引用计数器，每当一个地方引用它时，计数器值就+1；当引用失效时，计数器值就-1；任何时刻计数器为0的对象就是不可能被再使用的； 优点：实现简单，判定效率高；微软的COM技术、Python中都使用了Reference Couting算法进行内存管理 缺点：由于其很难解决对象之间相互循环引用的问题，主流Java虚拟机里面都没有选用Refrence Couting算法来管理内存； 程序计数器 程序计数器（Program Counter Register）是一块比较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器； PCR为线程私有内存； 是唯一一个在Java虚拟机规范中没有规定任何OOM情况的区域； 可达性分析算法 定义：可达性分析（Reachability Analysis）判断对象存活的基本思路：通过一系列的称为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）,当一个对象到GC Roots没有任何引用链相连（即GC Roots到这个对象不可达）时，则证明此对象是不可用的； ![enter description here][1] Java语言中，可作为GC Roots对象包括： 虚拟机栈（栈帧中的本地变量表）中引用的对象； 方法区中类静态属性引用的对象； 方法区中产量引用的对象； 本地方法栈中JNI（即一般的Native方法）引用的对象 再谈引用JDk1.2之后，Java对引用概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用4种，4种强度一次逐渐减弱。 强引用（Strong Reference）是指在程序代码之中普遍存在的，类似Object obj=new Object()这类的引用，只要强引用存在，对象就不会发生GC； 软引用（Soft Reference）是用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生OOM异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收后还没有足够的内存，才会抛出OOM异常。 弱引用（Weak Reference）是用来描述非必须对象的，强度比软引用更弱，被弱引用关联的对象只能生存到下一次GC发生之前。当垃圾回收器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象 虚引用（Phantom Reference）也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。 回收方法区 在方法区中进行垃圾收集的性价比一般比较低；而在Heap中，尤其是在新生代，常规应用进行一次垃圾收集一般回收70%~95%的空间，而永久代的垃圾收集效率远低于此； 永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类； 回收废弃常量与回收Java堆中的对象类似； 判定一个类是否是无用的类条件相对苛刻： 该类所有实例都已被回收，即Java堆中不存在该类的任何实例； 加载该类的ClassLoader已经被回收； 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该方法。 在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。 垃圾收集算法只介绍内存回收的方法论（算法思想及发展过程），不讨论具体算法实现。 G1收集器（Garbage-First）面向服务器端应用的垃圾收集器，计划未来替代CMS收集器。 理解GC日志垃圾收集器参数总结内存分配与回收策略对象优先在Eden分配大对象直接进入老年代长期存活的对象将进入老年代动态对象年龄判定空间分配担保","tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"JVM学习笔记（二）Java内存区域与内存溢出异常","date":"2017-03-18T02:35:33.376Z","path":"2017/03/18/JVM学习笔记（二）Java内存区域与内存溢出异常/","text":"第二部分 自动内存管理机制《深入理解Java虚拟机 JVM高级特性与最佳实践》 第二章 Java内存区域与内存溢出异常运行时的数据区域 程序计数器 程序计数器（Program Counter Register）是一块比较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器； PCR为线程私有内存； 是唯一一个在Java虚拟机规范中没有规定任何OOM情况的区域； Java虚拟机栈 Java虚拟机栈（Java Virtual Machine Stacks）描述的是Java方法执行的内存模型：每个方法在在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法接口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈出栈的过程。 Java虚拟机栈也是线程私有，它的生命周期与线程相同。 Java内存区常分为堆内存（Heap）和栈内存（Stack）； OOM情况：（1）线程请求的栈深度&gt;虚拟机所运行的最大深度；（2）虚拟机动态扩展时无法申请到足够的内存 本地方法栈 本地方法栈（Native Method Stack）与虚拟机所发挥的作用非常相似的，他们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机所使用的Native方法服务。 HotSpot虚拟机把本地方法栈和虚拟机栈合二为一； 此区域会抛StackOverflowError 和 OutofMemoryError异常 Java堆 Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块，Java Heap是所有线程共享的一块内存区域，在VM启动时创建 所有的对象实例以及数组都要在堆上分配（不绝对：栈上分配、标量替换优化技术）； Java堆是垃圾收集器管理的主要区域，也可称做GC堆（Garbage Collected Heap） 从内存回收的角度，现代收集器基本都采用分代收集算法，Java Heap可细分为新生代和老年代，再细致可分为Eden空间、From Survivor空间、To Survivor空间等–&gt;更好回收内存。 从内存分配的角度，线程共享的Java堆中可能分出多个线程私有的分配缓存区（TLAB：Thread Local Allocation Buffer）–&gt;更快分配内存。 Java堆出于逻辑连续的内存空间中，物理上可不连续，如磁盘空间一样； Java堆在实现上可时，可以实现成固定大小的，也可以按照可扩展实现（-Xmx和-Xms控制）； OOM情况：堆中没有内存完成实例分配，堆也无法再扩展时 方法区方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 也称为永久代（Permanent Generation）但随着Java8的到来，已放弃永久代改为采用Native Memory来实现方法区的规划。 此区域回收目标主要是针对常量池的回收和对类型的卸载。 运行时常量池 运行时常量池（Runtime Constants Pool）是方法区的一部分 Class文件中除了有类的版本、字段、方法、接口等描述的信息外，还有一项信息是常量池（Constant Pool Table）,用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 直接内存直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域。 能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。 直接内存的分配不会受到Java堆大小的限制，但会收到本机总内存（RAM以及SWAP/分页文件）大小以及处理器寻址空间的限制。 设置Xmx等参数信息时注意不能忽略直接内存，不然会引起OOM。 HotSpot虚拟机对象的创建为新生对象分配内存的分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾回收器是否带有压缩整理功能决定。 指针碰撞（Bump the Pointer）分配方式：Serial、ParNew等带有Compact过程的收集器 空闲列表（Free List）分配方式：类CMS这种基于Mark-Sweep算法的收集器 对分配内存空间的动作进行同步处理—VM采用CAS配上失败重试的方式保证更新操作的原子性； 本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）：把内存分配动作按线程划分在不同 空间中进行，即每个线程在Java堆中预先分配一小块内存，虚拟机是否启用TLAB，可由-XX:+/-UseTLAB参数设定； 对象的内存布局 对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）、和对齐填充（Padding）; 对象头包含2部分信息 Mark Word,存储对象自身的运行时数据（如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳）；由于对象头与对象自身定义的数据存储大小无关，考虑到VM的空间效率，Mark Word被设计成非固定的数据结构以便在极小的空间内存储尽量多的信息，他会根据对象的状态复用自己的存储空间。 类型指针，即对象指向它的类元数据的指针，VM通过这个指针来确定这个对象是哪个类的实例。 实例数据是对象真正存储的有效信息，也似乎程序代码中定义的各种类型的字段内容。 对齐填充，并不必然存在，没有特别含义，仅仅起占位符的作用，8byte对齐。 对象的访问定位Java程序需要通过栈上的reference数据来操作堆上的具体对象，对象访问方法取决于VM实现而定，目前主流访问方式有使用句柄和直接指针2种： 句柄访问Java堆中划分出一块内存作为句柄池，reference中存储对象的句柄地址，句柄中包含对象实例数据与类型数据各自的具体地址信息； 直接指针访问 Java堆对象的布局中必须考虑如何放置访问类型数据的相关信息，reference中存储对象地址； 两种访问方式各有优势 使用句柄访问最大的好处是reference中存储的是稳定的句柄地址，在对象被移动（GC时移动对象是很普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改； 使用直接指针访问方式的最大好处是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本； HotSpot虚拟机采用指针访问方式进行对象访问，从整个软件开发范围看，各种语言和框架使用句柄来访问的情况也非常常见。 实战OOM异常Java堆溢出 Java堆用于存储对象实例，只要不断创建对象，并保证GC Roots到对象之间有可达路径来避免回收机制清除这些对象，那么当对象数量到达最大堆的容量限制后就会产生OOM。 控制参数 -Xms：堆最小值 -Xmx：堆最大值 -XX:+HeapDumpOnOutOfMemoryError：让虚拟机在出现OOM异常时Dump出当前内存堆转储快照以便事后进行分析 异常信息Java.lang.OutOfMemory + Java Heap Space 解决办法以内存映像分析工具（Eclipse Memory Analyzer）对Dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，即判断是内存泄漏（Memory Leak）还是内存溢出（Memory Overflow） 如果是内存泄漏：通过工具查看泄漏对象到GC Roots的引用链，掌握泄漏对象的类型信息及引用链的信息后可较准确的定位代码位置； 如果是内存溢出：可通过检查VM的堆参数（-Xmx和-Xms），与机器物理内存对比看是否可以调大；从代码检查是否存在某些对象生命周期过长，持有状态时间过长的情况，尝试减少程序运行期的内存消耗 虚拟机栈和本地方法栈溢出控制参数HotSpot虚拟机不区分虚拟机栈和本地方法栈， -Xoss（设置本地方法栈大小）：参数设置无效; -Xss（栈容量）; 异常信息关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常： 如果线程请求的栈深度 &gt; 虚拟机所允许的最大深度，抛出StackOverFlowError异常 如果虚拟机在扩展栈时无法申请到足够的内存空间，抛出OutOfMemoryError异常 解决办法 操作系统分配给每个进程的内存是有限制的，如32位Windwos限制为2G。虚拟机提供了参数来控制Java堆和方法区这两部分内存的最大值， 虚拟机栈和本地方法栈可瓜分的剩余内存=2G（操作系统限制）-Xmx（最大堆容量）-MaxPermSize（最大方法区容量）-虚拟机进程本身耗费内存；程序计数器消耗内存很小，可以忽略。 每个线程分配到的栈容量越大，可以建立的线程数就越少，建立线程时候就越容易耗尽剩余内存。 按虚拟机默认参数，栈深度在大多数情况下达到1000~2000完全没问题，对于正常方法调用（包括递归），这个深度应该完全够用；但如果是建立过多线程导致内存溢出，在不能减少线程数或者更换X64位虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程 方法区和运行时常量区溢出运行时常量池是方法区的一部分，因此这两个区域的溢出可放在一起进行。 控制参数 -XX:PermSize（方法区最小容量） -XX:MaxPermSize （方法区最大容量） 异常信息OutOfMemoryError 后面跟随PermGen space 说明运行时常量池属于方法区（HotSpot虚拟机中的永久代）的一部分 本机直接内存溢出控制参数 DirectMemory容量可通过-XX:MaxDirectMemorySize指定，不指定默认与-Xmx(Java堆最大值)一样。 异常信息由DirectMemory导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显的异常； 如果发现OOM之后Dump文件很小，而程序又直接或简介使用了NIO，可以考虑是不是这方面的原因。","tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"深入理解Java虚拟机（一）","date":"2017-03-17T03:47:06.765Z","path":"2017/03/17/深入理解Java虚拟机（一）/","text":"第一部分 走进Java世界上没有完美的程序，但我们不能因此而沮丧，因为写程序本来就是一个不断追求完美的过程。1.1 概述Java不仅仅是一门变成语言，还是一个由一系列计算机软件和规范形成的技术体系，这个技术体系提供的完整的 用于软件开发和跨平台部署的支持环境，并且广泛应用于嵌入式系统，移动终端，企业服务器，大型机等各种场所。 Java能获得如此广泛的认可，除了他拥有一门结构严谨，面向对象的编程语言之外，还有许多不可忽视的优点：他摆脱了硬件平台的束缚，实现了一次编写，到处运行的理想，他提供了一个向对安全的内存管理和访问机制，避免了绝大部分的内存泄漏和指针越界问题，它实现了热点检测代码和运行时编译以及优化，这使得Java应用能随着运行使劲按的增加而获得更高的性能，它有一套完整的应用程序接口，还有无数来自商业机构和开源社区的第三方库莱帮着它实现各种各样的功能。。。。。 当我们在使用一种技术的时候，如果不在依赖书本和他人就能得到这些答案，那才算是得到了“不惑”的境界 1.2 Java技术体系从广义上讲，Clojure，JRuby，Groovy等运行在Java虚拟机上的语言以及相关的程序都属于Java中技术体系中的一部分，如果型传统意义上来说，Sun公司官方定义的Java技术体系包括以下几个组成部分： Java程序设计语言 各种硬件平台上的Java虚拟机 Class文件格式 Java的API 来自商业机构和开源社区的第三方Java类库 JDK 包含了Java程序设计语言，Java虚拟机，和Java的API，来用于支持Java开发的最小的环境，另外的，Java API中的Java SE API子集和Java虚拟机这两部分统称为JRE（Java Runtime Environment），JRE 支持Java运行的标准环境。 以上Java技术体系图是根据各个组成部分的功能来进行划分的。如果按照Java技术服务的领域来划分，可分为以下4个平台： 1.Java Caard2.Java ME3.JavaSE（Standard Edition）：支持面向桌面级应用的java平台，提供了完整的Java核心API，这个版本以前称为J2SE。 JavaEE（Enterprise Edition）：支持使用多层架构的企业应用（如ERP、CRM应用)的Java平台，除了提高Java SE API外，还对其做了打了扩充，并提供了相关部署支持，这个版本以前称为J2EE。javaEE对JavaSE提供的扩展一般以java.作为包名，而以java.为包名的都是javaSE API的核心包，但由于历史原因，一部分曾经是扩展包的API后来进入了核心包，因此核心包中也包含了不少javax.*的包名。 Java语言口号 Write Once , Run Anywhere。 JDK命名JDK从1.5版本开始，官方在正式文档与宣传上不再使用类似JDK1.5的命名，只在程序内部使用的的开发版本号（Developer Version，例如java –version的输出）中才继续沿用1.5,1.6…。而攻克版本号（Product Version）则改为JDK5、JDK6、JDK7的命名方式。Java开源 2006年11月13日的JavaOne大会上，Sun公司宣布开源java,JDK1.6在12月11日发布。并建立了OpenJDK组织对浙西源码进行独立管理，除了极少量的产权代码（Encumbered Code，这部分代码大多史Sun本身也无权限进行开源处理的）外，OpenJDK几乎包括了Sun JDK的全部代码。Java虚拟机发展史 Sun公司的java虚拟机Sun Classic VM： JDK1.0提供的一个纯解释执行的Java虚拟机。Exact VM:JDK1.2提供，具有两级及时编译器、编译器与解释器混合工作模式，使用了准确式内存管理（Exact Memory Management，也叫Non-Conservative/Accurate Memory Management）而得名，即虚拟机可以知道内存中某个位置的数据具体式什么类型。譬如内存中有一个32位的整数123456，它到底式一个reference类型指向123456的内存地址还是一个数值位123456的整数，虚拟机将有能力分辨出来，这样才能在GC（垃圾收集）的时候准确判断堆上的数据是否还可能被使用。Exact VM抛弃了Classic VM基于handler的对象查找方式（原因是进行GC后对象将可能会被移动位置，如果将地址为123456的对象移动到654321，在没有明确信息表明内存中哪些数据是reference的前提，虚拟机不敢把内存中所有为123456的值改成654321的，所以要使用句柄来保持reference值的稳定），这样每次对象都少了一次间接查找的开销，提升执行性能。HotSpot VM：(目前一直使用)JDK1.2提供，内置了JIT(Just in Time)编译器，继承了前面2款虚拟机的优点如：Exact Memory Management。自己新技术，如其名：HotSpot指的就是它的热点代码探测技术，ExactVM中也有，热点探测可以通过执行计数器找出最具有编译价值的代码，然后通知JIT编译器以方法为单位进行编译。其它公司的Java虚拟机 JRockit VM：BEA公司收购的，并将其发展为一款专门为服务器硬件和服务器端应用场景高度优化的虚拟机，由于不太关注程序启动速度只专注与服务端应用，因此JRockit内部不包含解析器实现，全部代码都靠即使编译器编译执行，JRockit的垃圾收集器和MissionControl服务套件等部分的实现，在众多Java虚拟机中也处于领先。 可以运行在Java虚拟机上的语言 对于这些运行于java虚拟机之上，Java语言之外的语言，来自系统级的、底层底层的支持正在迅速增强，JSR-292为核心的一系列项目和功能改进，推动java虚拟机从“Java语言的虚拟机”向“多语言虚拟机”的方向发展 编写JDK使用的语言 OpenJDK的各个组成部分（Hotspot、JDK API、JAXWS、JAXP….)有的是使用C++编写的，更多的代码则是使用Java自身实现的。","tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"深入理解Java虚拟机（目录）","date":"2017-03-17T02:48:59.770Z","path":"2017/03/17/深入理解Java虚拟机（目录）/","text":"本书一共分为5个章节，13个小结第一部分 走进Java本书的第一部分为后文的讲解建立了良好的基础，尽管了解Java技术的来龙去脉，以及编译自己的OpenJDK对于读书理解Java虚拟机并不是必需的，但是这些准备可以过程可以为走进Java技术和虚拟机提供良好的引导，第一分部只有第一章： 第一章介绍了Java技术体系的过去，现在和未来的一些发展趋势，并且介绍了如何独立的编译一个OpenJDK 7。 第二部分 自动内存管理机制因为程序员把内存控制的权利交给了Java虚拟机，所以可以在编码的时候享受自动内存管理的诸多优势，不过也正是这个原因，一旦出现内存泄漏和溢出得问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会成为一项艰难的工作。第二部分有2~5章。 第二章讲解了虚拟机内存是如何划分的，以及那部分区域，什么样的操作和代码可以导致内存溢出异常，讲解了各个区域出现内存溢出异常常见的原因。 第三章分析了垃圾收集的算法和JDK 1.7 中提供的几款垃圾收集器的特点以及运行的原理，通过代码示例验证了Java虚拟机中自动内存分配以及回收的主要规则。 第四章加少了JDK发布的6个命令工具和两个可视化的故障处理工具的使用方法。 第五章与读者分享了几个比较比较有代表性的实际案例。还准备了所有开发人员都能亲身实战的练习，读者可以通过实践来获得故障处理和调优的经验。 第三部分 虚拟机执行子系统执行子系统是虚拟机中必不可少的组成部分，了解了虚拟机如何执行程序，才能写出优秀的代码。第三部分包括6~9章： 第六章讲解了Class文件中的各个组成部分，以及每个部分中的定义，数据结构和使用方法，以实战的方法演示了Class文件的数据是如何储存和访问的。 第七章介绍了类加载过程中的“加载”，“验证”，“准备”，“解析”和“初始化”的5个阶段和虚拟机分别执行了那些动作，还介绍了类加载器的工作原理以及其对虚拟机的意义。 第八章分析了虚拟机在执行代码的时候如何找到正确的方法，如何执行方法内的字节码，以及执行代码时设计的内存结构。 第九章通过四个类加载以及执行子系统的案例，分享了使用类加载器和处理字节码的一些值得欣赏和借鉴的思路，并且通过一些实战练习来加深对前面理论知识的理解。 第四部分Java程序从源码编译到字节码以及从字节码编译成本地机器码的两个过程，合并起来就等同于一个传统编译器所执行的编译过程，第四部分主要包括10~11章 第十章分析了Java语言中的泛型，主动装箱和拆箱，条件编译等多种语法糖的前因后果。并且通过实战演示了如何插入式注解处理器来实现一个检查程序命名规范的编译器插件。 第十一章讲解了虚拟机的热点探测方法，HotSpot的即时编译器。编译触发条件，以及如何从虚拟机外部观察和分析JIT编译的数据和结果，此外，还讲解了几种常见的编译优化技术。 第五部分Java语言和虚拟机提供的原生的，完善的多线程支持，这使得它天生就适合开发多线程并发的应用程序。不过我们不能期望系统来完成所有的并打相关的处理，了解并发的内幕也是一个高级程序员不可缺少的课程，第五部分有12~13章 第十二章讲解了虚拟机Java内存的结构和操作，以及原子性，可见性和有序性在Java内存模型中的体现，介绍了先行发生原则的规则和使用，还了解了线程在Java语言中是如何实现的。 第十三章介绍了线程安全涉及的概念和分类，同步实现的方法以及虚拟机的底层运作原理，并且介绍了虚拟机实现高效并发所采取的一系列的锁优化措施。","tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"undertow嵌入式web服务器初体验","date":"2017-03-16T02:15:54.206Z","path":"2017/03/16/undertow嵌入式web服务器初体验/","text":"Github源码做的一个项目，在这里开源，删除了大部分业务代码，将逐步改为一个基于netty5的框架，目前只算得上是一个手脚架吧 netty同时处理HTTP和Websocket，并将HTTP请求路由到相应Action中;使用ehcache实现Session；spring IOC做管理容器，mybatis做sql数据库ORM；spring data mongoDB做mongo的ORM；HikariCP做sql数据库连接池；Gson用于json解析和生成；logback日志处理 ####netty处理HTTP和websocket smart.core.netty.HttpHandler：是一个自定义的ChannelHandler用于处理HTTP和Websocket请求 Handler分别处理HTTP和Websocket 1234567public void messageReceived(ChannelHandlerContext ctx, Object msg) &#123; if (msg instanceof FullHttpRequest) &#123;//如果是HTTP请求，进行HTTP操作 handleHttpRequest(ctx, (FullHttpRequest) msg); &#125; else if (msg instanceof WebSocketFrame) &#123;//如果是Websocket请求，则进行websocket操作 handleWebSocketFrame(ctx, (WebSocketFrame) msg); &#125; &#125; 由于websocket也是基于HTTP的，需要判断是websocket后，将HTTP升级为Websocket 12345678910111213141516171819202122private void handleHttpRequest(ChannelHandlerContext ctx, FullHttpRequest req) &#123; logger.warn(\"uri:\" + req.uri()); if (req.uri().startsWith(\"/ws/join\")) &#123;//如果urL开头为/ws/join则升级为websocket mac = wsBeforeHandler(ctx, req); if (mac == null || mac.length() &lt; 1) &#123; RespTools.paraErrorBack(ctx,req,null); return; &#125; WebSocketServerHandshakerFactory wsFactory = new WebSocketServerHandshakerFactory( getWebSocketLocation(req), null, true); handshaker = wsFactory.newHandshaker(req); if (handshaker == null) &#123; WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx.channel()); &#125; else &#123; handshaker.handshake(ctx.channel(), req); &#125; &#125; else &#123;//是HTTP请求则路由到Action RouteResult&lt;Action&gt; routeResult = rs.getRouter().route(req.method(), req.uri()); Action action = routeResult.target(); action.act(ctx, req); &#125; &#125; websocket请求处理,这里是从websocket请求中获取客户端传来的json字符串，并将字符串转为javabean 12345678910111213141516171819private void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame) &#123; // Check for closing frame if (frame instanceof CloseWebSocketFrame) &#123; handshaker.close(ctx.channel(), (CloseWebSocketFrame) frame.retain()); return; &#125; if (frame instanceof PingWebSocketFrame) &#123; ctx.write(new PongWebSocketFrame(frame.content().retain())); return; &#125; if (frame instanceof TextWebSocketFrame) &#123; devicePool.join(ctx.channel(), mac); String json = ((TextWebSocketFrame) frame).text(); Logic.ReqRespType data= JsonTools.read(json,Logic.ReqRespType.class); //... return; &#125; &#125; 如果是HTTP则需在RouterSetting中配置路由.比如r.POST(“api/get_verify_code”, getVerifyCodeAct):将url为”api/get_verify_code”的POST请求路由到LoginAct中 123456789101112131415161718192021public class RouterSetting &#123; @Autowired private Router&lt;Action&gt; router; @Autowired private GetVerifyCodeAct getVerifyCodeAct;//w @Autowired private LoginAct loginAct; @Autowired private RegisterAct registerAcc; public Router&lt;Action&gt; getRouter() &#123; routerConfig(this.router); return this.router; &#125; private void routerConfig(Router&lt;Action&gt; r) &#123; r.POST(\"api/get_verify_code\", getVerifyCodeAct); r.ANY(\"api/login\", loginAct); r.GET(\"api/register\", registerAcc); &#125;&#125; Action处理HTTP请求并返回 12345678910111213@Controllerpublic class LoginAct implements Action &#123; private static final Logger logger = LoggerFactory.getLogger(LoginAct.class); @Override public void act(ChannelHandlerContext ctx, FullHttpRequest req) &#123; String ip = HttpTools.getIp(req); String body = Convert.buf2Str(req.content()); Get.Login get = JsonTools.read(body, Get.Login.class);//1.得到HTTP传来的json数据解析为javabean Sub.Register back;//构建返回给客户端的javabean的实例 //... HttpTools.sendCorrectResp(ctx, req, back);//返回给客户端HTTP Response &#125;&#125; 添加Session(依靠ehcache) 12345private void addSession(long userId, String ip) &#123; Logic.DeviceSession session = new Logic.DeviceSession(ip, \"\"); Cache.add(userId + \"\", session, \"6mn\");//设置session的缓存时间为6分钟 //debugSession(userId); &#125; 从HTTP请求中获取IP地址1String ip = HttpTools.getIp(req)； ####netty参数设置12345port=8090netty.boss.thread.count=2netty.worker.thread.count=1netty.so.keepalive=truenetty.so.backlog=100 ####项目依赖1234567891011121314151617181920212223242526272829//---------------------单元测试---------------------------- testCompile group: 'junit', name: 'junit', version: '4.11' //--------------------数据库驱动---------------------------- compile 'org.mongodb:mongodb-driver:3.2.2' compile 'mysql:mysql-connector-java:5.1.38' //-------------------数据库连接池--------------------------- compile 'com.zaxxer:HikariCP:2.4.5' //----------------------ORM------------------------------ compile group: 'org.mybatis', name: 'mybatis', version:mybatisVersion compile group: 'org.mybatis', name: 'mybatis-spring', version:mybatisSpringVersion //-----------------------缓存---------------------------- compile group: 'net.sf.ehcache', name: 'ehcache', version:ehcacheVersion //----------------------工具包---------------------------- compile 'commons-httpclient:commons-httpclient:3.1-rc1' compile 'org.javassist:javassist:3.20.0-GA' //---------------------日志处理---------------------------- compile 'org.slf4j:slf4j-api:1.7.21' compile 'ch.qos.logback:logback-core:1.1.7' compile 'ch.qos.logback:logback-classic:1.1.7' //---------------------json处理--------------------------- compile 'com.google.code.gson:gson:2.6.2' //---------------------netty----------------------------- compile group: 'io.netty', name: 'netty-all', version:nettyVersion //---------------------spring---------------------------- compile group: 'org.springframework', name: 'spring-test', version:springVersion compile group: 'org.springframework', name: 'spring-jdbc', version:springVersion compile(group: 'org.springframework', name: 'spring-context', version:springVersion) &#123; exclude(module: 'commons-logging') &#125;","tags":[{"name":"undertow","slug":"undertow","permalink":"http://yoursite.com/tags/undertow/"}]},{"title":"Springboot 整合 Mybatis","date":"2017-03-16T02:14:30.993Z","path":"2017/03/16/Springboot 整合 Mybatis/","text":"为什么使用Mybatis？ Mybatis是目前很火的SSM框架中的ORM组件，相比Hibernate更加灵活小巧，学习成本也更低，我觉得可维护性也更好些。 但是spring boot官方更只提供了自家的spring data jpa及hibernate的整合方案，而没有给出Mybatis的整合组件。于是上Github，发现了Mybatis提供了它的spring-boot-starter。 ##整合方法 gradle中加入依赖1compile(\"org.mybatis.spring.boot:mybatis-spring-boot-starter:1.1.1\") spring.boot:mybatis-spring-boot-starter中已经包含了对mybatis和mybatis-spring的依赖 在application.yml中配置mybatis12345mybatis: #指定mapper和domain(实体)所在的包 type-aliases-package: me.jcala.blog.domain,me.jcala.blog.mapping #指定使用的类型转换器 type-handlers-package: org.apache.ibatis.type.LocalDateTypeHandler 除此之外mybatis还提供了一下配置12345mybatis: config-location: #mybatis的xml注册文件位置 mapper-locations: #Mapper xml config files (optional) executor-type: #执行类型为: SIMPLE, REUSE还是BATCH configuration: #mybatis的其他配置 在Spring Boot中配置好数据源DataSource可以使用任意数据源，mybatis会自动使用spring boot中所配置的数据库连接池 以上就完成了spring boot对mybatis的整合，超级简单啊 测试一下因为在type-aliases-package: me.jcala.blog.domain,me.jcala.blog.mapping中指定的mapping扫描包为me.jcala.blog.mapping，所以要把写的mapper放到me.jcala.blog.mapping包下。 在me.jcala.blog.mapping下新建一个TestMapper接口123456@Repository@Mapperpublic interface TestMapper &#123; @Insert(\"insert into users set username='zzp',password='zzp105'\") void insert();&#125; 再随便写一个测试的类12345678public class TestForMapper&#123;@AutowiredTestMapper testMapper;@Testpublic void testInsert()&#123; testMapper.insert(); &#125;&#125;","tags":[{"name":"springboot mybatis","slug":"springboot-mybatis","permalink":"http://yoursite.com/tags/springboot-mybatis/"}]},{"title":"微服务","date":"2017-03-16T02:03:09.621Z","path":"2017/03/16/微服务/","text":"欢迎使用 {小书匠}(xiaoshujiang)编辑器，您可以通过==设置==里的修改模板来改变新建文章的内容。 微服务一个新架构术语的定义微服务架构是将软件应用程序设计为一套可独立部署的服务组件。虽然在架构风格上没有精确的定义，但在业务功能、自动化部署、端点智能化以及对语言与数据的离散化控制能力上具备通用特征 “微服务” 是在已经人满为患的软件架构领域出现的新名词。虽然我们对于新的事物往往会抱有一种轻视的态度去认识它。但慢慢的会发现这种软件架构风格变得越发的吸引人。过去几年，我们看到许多实际的项目去使用它。应用后的结果至今也是蛮不错的。更有甚一些同事干脆把它当作构建企业级应用程序的首选。遗憾的是，到目前为止没有更多官方的信息指导我们如何在项目中使用它。 简而言之， 微服务架构的风格 1 是将单一的应用程序作为一组小服务套件来开发的一种方法，每个服务都运行在各自的进程中，并利用轻量化机制（通常是HTTP资源API）实现通信。并且围绕着业务能力构建，通过自动化部署机制实现独立部署。这些服务匹配一套最低限度的中央式管理机制，每个服务可通过不同的编程语言编写，使用不同数据存储技术。 对比着单体式架构风格来理解为服务是再好不过了，一个单体式应用作为一个单一的单元进行构建。构建企业级应用程序通常包含一下三个主要部分： 客户端用户界面（由运行在用户设备上的浏览器中的HTML页面以及JavaScript代码构成） 后端数据库（由大量插入至数据库管理系统的表构成，通常采用关系数据库） 服务器端应用程序 服务器端的应用程序将会处理HTTP请求，执行域逻辑。检索与更新数据库。同时选定HTML视图并将其发送至浏览器端。服务器端应用程序通常为单一逻辑的可执行程序 [15]。任何针对该系统的变更都需要对该服务器端应用程序进行新版本构建与部署。 这样的单体服务器机制在构建此类系统中可谓不可或缺。我们用于处理请求的全部逻辑都运行在单一进程当中，允许大家使用语言中的基本功能以将该应用程序拆分为类、函数以及命名空间。通过这种方式，我们能够在开发人员的笔记本设备上运行并测试应用程序，同时利用一整套部署流程以确保全部变更都经过妥善测试而后被部署在生产环境当中。大家可以将大量实例运行在一套负载均衡方案之后，从而实现横向扩展能力。 单体式应用程序当然能够切实起效，但人们却逐渐发现其中存在着诸多弊端，特别是在将大量应用程序部署在云环境当中的情况下。由于变更周期被大量集中于一处，即使仅仅指向应用程序中的一小部分，单一变更亦要求我们对应用程序整体进行重构与重新部署。随着时间推移，我们往往很难保证理想的模块化结构，这意味着本应只影响单一模块的变更往往会扩散至该模块之外。规模伸缩亦要求我们对整体应用程序进行规模调整，而非单纯为其中必要的部分进行资源扩容。 单体应用程序与微服务应用程序图一：单体应用程序与微服务应用程序 正是这些弊端造就了如今的微服务架构风格：即以服务套件的形式构建应用程序。除了各服务能够单独进行部署与规模伸缩之外，每项服务还具备牢固的模块边界，甚至允许我们在不同的服务当中使用不同的编程语言进行代码编写。另外，各服务亦可由不同团队负责管理。 我们认为微服务风格并不算什么新鲜事物或者创新成果，其历史至少可以追溯至Unix设计时代。但我们同时亦坚信，微服务架构一直未能受到足够的重视，而其确实能够帮助大家更好地完成软件开发工作。 微服务架构的特性我们无法给微服务架构风格出具一条确切的定义，但我们却可以根据该架构表现出的各类共同特性对其加以描述。正如各类根据共同特性做出的定义一样，并不是所有微服务架构都符合这些特性，但可以肯定的是具备这些特性的微服务架构占据大部分比例。尽管我们各部分内容的作者仅仅是相关技术社区中的活跃成员，但制作这份文档是为了对采用微服务架构的工作流程及成果做出总结，而且其中仍有相当一部分表述并非严格定义，只应作为常见情况考量。 通过服务实现组件化长久以来，我们一直参与软件行业之内并意识到人们对利用组件整合方式构建系统的渴望——这种思路与我们在物理世界中采取的构建机制非常相似。而在过去几十年当中，我们发现已经有大量公共库渗透到多数语言平台当中并成为其坚实的组成部分。 在谈到我们所使用的组件时，大家可能会发现不同群体对组件的定义也有所区别。我们对组件做出的定义是，其属于软件中的一类单元，且具备可更替性与可升级性。 微服务架构会使用这些库，但其实现组件化的主要手段则是将软件拆分成多个服务。我们将“库”定义为与程序相对接且可通过内存内函数调用发挥作用的组件，而“服务”则为进程之外的组件，其可通过Web服务请求或者远程程序调用等方式实现通信。（这里的服务概念与多数OO程序 3 中的服务对象概念有所区别）。 将服务作为组件加以使用（而非库）的一大原因在于，服务具备独立可部署能力。如果大家的应用程序 4 由单一进程中的多个库 构成，那么指向任何单一组件的变更都会致使该应用程序必须进行重新部署。但如果该应用程序被拆分成多项服务，那么单一服务变更将只会致使该服务进行重新部署。虽然这并非绝对，例如某些变更会导致服务接口受到影响，但一套优秀的微服务架构旨在尽可能少地对服务协议中的服务边界及演进机制产生干扰。 将服务作为组件的另一个理由在于实现更为明确的组件接口。大多数编程语言并不具备用于定义明确发布接口的良好机制。一般来讲，其只会提供说明文档及规则以防止用户打破组件封装，但这同时亦会导致不同组件之间的耦合程度过高。利用明确的远程调用机制，服务能够轻松避免此类难题。 但以这种方式使用服务亦存在一定弊端。远程调用在资源需求方面往往远高于进程内调用，因此远程API需要采取粗粒度设计，但这亦会增加API的使用难度。如果大家需要更改不同组件间的职能分配，那么这类需求在跨越进程边界时往往不易实现。 通过粗略观察，我们往往会发现这些服务会与各运行时进程相映射——但这仅仅只是第一印象。一项服务可能由多个进程构成，且各进程始终共同进行开发与部署——这方面实例包括只由单一服务所使用的应用程序进程以及数据库。 围绕业务功能构建组织当着眼于将单一大型应用程序拆分成多个组成部分时，管理人员通常更重视技术层，其中具体包括UI团队、服务器端逻辑团队以及数据库团队。当这些团队据此进行拆分时，即使是最简单的变更也将给项目造成跨团队协作负担，并因此导致时间与预算的双重支出。睿智的团队会对此进行优化，同时采取两害相权取其轻的办法——即强制要求逻辑存在于一切与之相对接的应用程序当中。换言之，也就是实现逻辑的普遍存在性。这正是所谓康威法则 5 的一种实际表现形式。 任何组织在设计一套系统（广义层面的系统）时，其设计成果都会直接体现该组织所使用的沟通结构。 –梅尔文·康威，1967年 康威定律的实际体现图二：康威定律的实际体现 微服务方案对于各部门而言是一种不同于以往，且以业务功能为核心的服务拆分及组织途径。此类服务采用软件方案在业务层面中的广泛实现堆栈，具体包括用户界面、持久性存储以及任何外部协作机制。因此，各团队将拥有跨职能特性，包括开发过程当中要求的全部技能组合：用户体验、数据库以及项目管理等等。 由团队边界决定的服务边界图三：由团队边界决定的服务边界 采取此类组织方式的企业实例可参见comparethemarket，其各职能团队共同负责构建并运营每款产品，而每款产品则被拆分为一系列独立的服务——且各服务间通 过一套消息收发总线实现通信。 大型整体应用程序亦可以始终围绕业务功能实际模块化，不过这种状况并不常见。诚然，我们都听说过由大型团队构建的单一整体应用程序根据自身业务线进行设计与划分。然而在这类情况下，最大的问题在于整体应用程序在组织当中需要考虑太多背景信息。如果其整体范畴当中包含太多模块边界，那么团队中的单一成员将很难通过短期记忆对其进行管理。除此之外，我们发现这种模块化业务线的维护工作还要求相关人员具备极高的专业技能水平。相比之下，服务组件能够令拆分方式更为明确，从而大大简化团队边界的设定与认知。 微服务架构有多“微”？ 尽管“微服务”早已成为一种极具人气的架构类型，但这一名称却并不能准确反映服务的实际规模——换言之，“微”服务并不一定微。在与众多微服务从业者的交流当中，我们发现服务的具体规模可谓多种多样。其中规模最大的成果源自Amazon公司旗下的“两块披萨”团队（即整个团队只需两块披萨即可填饱肚子），这意味着其总人数在十位左右。而规模较小的团队则由六人组成，负责支持六项服务。那么这就带来了新的问题：这种十二人对单项服务的机制同一人对单项服务之间存在着怎样的差别？二者也许不可一概而论。就目前而言，我们姑且认为双方属于同类团队结构，但随着对微服务认识的持续深入，也许我们未来将抱持新的观点。 产品而非项目大部分应用程序开发工作都会遵循项目模式：其目标在于交付软件方案中的特定部分，并拥有直观的完成指标。在软件开发工作完成后，其会被传递至运维部门，这时负责构建该软件的团队也将即刻解散。 微服务的支持者们则认为这种模式并不可取——他们的主张是相关团队应该伴随产品走过整个生命周期。这方面最典型的例子应该是Amazon公司提出的“谁构建，谁运行”原则，其中开发团队需要对生产环境下的软件成果承担全部责任。这就要求开发人员在日常工作中全程关注其软件的生产运行情况，同时掌握来自用户的反馈意见，意味着他们需要在一定程度上为用户提供技术支持服务。 产品的定位应始终与业务功能相协调。相较于以往将软件视为一整套已经完成的功能集的心态，微服务架构要求我们全程与之保持关联，并思考该软件能够如何协助用户加强业务功能。 当然，我们完全可以将同样的思路引入整体应用程序当中，不过大量小型服务集合能够显著简化服务开发人员与及用户之间的个人联系。 智能化端点与傻瓜式流程在跨越不同进程构建通信结构时，我们发现很多产品及方案会直接把智能化机制塞进通信机制本体当中。这方面的典型实例就是企业服务总线（简称ESB），ESB产品当中通常包含复杂度极高的消息跌幅、编排、转换以及业务规则应用等机制。 微服务社区则倾向于使用另一种实现方式：智能化端点与傻瓜式流程。采用微服务架构的应用程序旨在尽可能实现解耦化与关联性——它们各自拥有自己的域逻辑，而且在经典Unix场景下的运作方式更像是过滤器机制——接收请求、应用合适的逻辑并生成响应。这一切都通过简单的REST类协议实现编排，而非经由WS-Choreography或者BPEL等复杂协议以及中央编排工具实现。 目前最常用的两类协议为配合源API的HTTP请求-响应与轻量化消息收发协议 6 。对于前者，最简练而准确的说明是： 立足于Web，而非居于Web背后。– Ian Robinson 微服务团队采用的正是万维网（在很大程度上亦包括Unix在内）所遵循的原则与协议。一般来讲，其使用的资源能够为开发人员或者运维人员轻松实现缓存处理。 第二类作法则是立足于轻量化消息总线实现消息收发。这类基础设施选项通常具备傻瓜式特性（这种傻瓜特性体现在实现操作上，即只需匹配消息路由机制，再无其它）——以RabbitMQ或者ZeroMQ为代表的简单实现方案仅仅需要提供一套可靠的异步结构，而服务的全部智能化元素仍然存在于端点当中并负责消息的生成与消费。 在整体应用程序当中，各组件在进程内执行并通过方法调用或者函数调用的方式实现彼此通信。将整体应用程序转化为微服务形式的最大难题在于改变这种通信模式。由内存内方法调用指向PC通信机制的简单转换往往无法良好起效。相反，大家需要利用粗粒度方式取代原本的细粒度通信机制。 微服务与SOA当我们探讨微服务时，经常出现的问题就是其到底是不是我们十年前就听说过的面向服务架构（简称SOA）的另一种表现形式？二者之间确实存在一定联系，因为微服务风格拥有与SOA相似的逻辑主张。然而问题在于，SOA的实际含义太过广泛，而且当我们提到所谓“SOA”时，实际所指的对象往往跟这里提到的微服务概念差之千里——具体来讲，其通常代表那些专注于利用ESB实现的集成化整体应用程序。 值得强调的是，我们也见证了大量表现糟糕的面向服务实现手段——从将复杂性隐藏在ESB当中 7 的作法，到投入多年以及数百万资金却毫无成效的尝试，再到以聚合型治理模式抑制变更，我们几乎看不到面向服务架构能够带来什么显著的积极影响。 诚然，微服务社区当中使用的不少技术成果都源自开发人员在大型企业当中积累到的集成化服务成果。Tolerant Reader模式正是其中的典型代表。对Web的运用确实带来可观回报，而使用简单协议正是经验积累的直接产物——这显然是为了解决标准汇聚所导致的高复杂性难题（无论何时，如果大家需要利用一种实体来管理其它实体，那么就意味着各位已经面临着大麻烦）。 SOA的这些弊端导致一部分微服务布道者很讨厌人们把SOA的标签加在微服务头上——尽管也有一些人认为微服务正是SOA的一种实现方式 8，或者说我们可以将微服务称为“面向服务的正确实现”。无论如何，事实上SOA含义的宽泛性意味着其更适合作为一种用于定义架构风格的术语，而非具体解决方案。 离散化治理聚合型治理的一大影响在于使得单一技术平台上出现标准化趋势。经验表明这类方案具备收缩特性——意味着各个实际问题并不能够轻松与解决方案对应起来。我们更倾向于使用正确的工具执行正确的任务，而且虽然部分整体应用程序能够发挥不同编程语言的独特优势，但这种情况并不常见。 通过将整体应用程序的各组件拆分成服务，我们能够对各服务进行分别构建。各位可能希望利用Node.js建立一套简单报告页面？照此办理即可。打算利用C++构建特定的近实时组件？没问题。打算利用不同类型的数据库以匹配单一组件的读取行为？目前的技术方案已经能够实现这种独立重构需求。 当然，我们能够实现以上目标，并不代表我们必须这么做——但对系统进行拆分意味着大家能够拥有更多备用选项。 采用微服务架构的团队倾向于以不同的方式实现所谓标准。相较于以往编写一整套定义标准集的作法，他们更乐于开发实用工具并交付给其他开发人员，从而利用其解决自身面临的类似问题。这些工具通常能够在更为广泛的层面得到实现与共享，但同时又不至于转化为排他性内部开源模式。现在git与github都已经成为客观层面的版本控制系统选项，而开源实践也越来越多地成为内部环境中的常见组成部分。 Netflix公司就是个很好的例子，他们遵循的正是这样一种理念。将具备实用性且经过严格考验的代码作为库，并鼓励其他开发人员利用其以类似的方式解决的类似的问题，这就为各团队成员在必要时选择其它工具保留了空间。共享式库专注于数据存储、进程间通信以及我们在后文中将要探讨的基础设施自动化等问题的解决。 对于微服务社区而言，资源成本显然是种不受欢迎的因素。这并不是说该社区不承认服务协议的价值。恰恰相反，这是因为他们希望构建起大量服务协议。他们希望能够采用多种完全不同的方式对这些协议进行管理。像Tolerant Reader以及Consumer-Driven Contacts这样的模式在微服务架构中非常常见。这些服务协议也各自以独立方式不断演进。将消费者驱动型协议作为构建工作组成部分的作法能够显著增强参与者信心，同时快速获取服务功能能否确切实现的反馈意见。事实上，澳大利亚的某个团队就在积极利用消费者驱动型协议进行新服务构建。他们使用的简单工具确保其能够针对单一服务实现协议定义。其甚至在面向新服务的代码被编写出来之前就已经成为自动化构建流程中的一部分。这意味着服务只有在切实满足该协议要求的前提下才能够实现构建——这就有效解决了构建新软件时经常出现的“YAGNI” [9] 难题。这些技术与工具成果围绕协议而生，并通过降低不同服务间的耦合性限制了其对中央协议管理机制的依赖。 多种语言，多种选项JVM作为平台的快速发展已经成为多种语言混成于单一通用平台内的最新明证。这种作法已经成为一类常见实践，旨在充分发挥高级语言在过去数十年中发展所实现的种种高级抽象优势。其甚至以涓滴效应影响到裸机以及通过低级语言编写的性能敏感型代码。然而，众多整体应用程序并不需要这种级别的性能优化效果，亦非常见的DSL与高级别抽象开发成果。相反，整体应用程序往往使用单一语言，这也严重限制了其能够使用的技术手段。[10] 也许离散化治理的人气正是源自Amazon方面提出的“谁构建，谁运行”原则。各团队需要为其构建的软件的各个方面承担责任，包括为软件提供24/7全天候运维支持。这种程度的责任下放当然还没有成为常态，不过我们已经看到越来越多的企业开始将责任交付至开发团队。Netflix公司亦是另一家采取这种理念 [11] 的企业。为了不至于在凌晨三点被紧急来电叫醒，开发人员们当然会全力以赴提升所编写代码的质量水平。这些思路与传统的集中化治理模式明显相去甚远。 离散化数据管理数据管理离散化拥有多种不同的表现形式。从最为抽象的级别来看，这意味着全局概念模型将在不同系统之间有所区别。这种问题常见于解决方案在大型企业当中的部署，毕竟销售团队对于客户概念的理解方式必须不同于技术支持团队的理解方式。被销售人员视为客户的对象也许根本不会出现的技术支持团队的视野当中。不同属性甚至是相同属性的不同理解方式都可能在语义层面产生细微的差异。 这一问题通常出现在不同应用程序之间甚至是应用程序之内，特别是在将应用程序拆分为多个独立组件的情况下。解决问题的一类可行思路在于基于背景边界化的区域驱动型设计（简称DDD）方案。DDD机制将一个复杂的区域拆分成多个具备边界的背景单元，并对各单元之间的关系加以映射。这种方式同时适用于整体与微服务架构，但服务与背景边界间的自然关联性有助于声明我们曾在业务功能章节中提到过的区分效果。 除了对概念模式进行离散化处理，微服务同时也能够拆分数据存储决策。尽管整体性应用程序倾向于使用单一逻辑数据库保存持久性数据，但企业通常更乐于利用单一数据库涵盖一系列应用程序——而且大多数此类决策立足于具体供应商提供的授权商业模式。微服务机制则选择由每项服务管理其自身数据库的方式，而非不同实例基于同一数据库技术或者完全使用多种不同数据库系统——这种方式亦被称为混合持久化。大家可以利用混合持久化方案打理整体应用程序，但其在微服务架构中的亮相频率明显更高一些。 对微服务架构内数据责任关系的离散化处理也影响到了更新管理工作。常见的更新处理方案是在更新多种资源时，利用事务处理机制来保证其一致性。这种方式通常被用于整体性应用程序汉中。 这种事务处理使用方式确实有助于保障一致性，但却会带来显著的临时性耦合效果，而这在跨越多项服务时会带来新的难题。分布式事务处理非常难以实现，因此微服务架构更强调服务之间的事务处理协调性，同时明确强调只需保障最终一致性并通过补偿运算解决其中的冲突问题。 利用这种方式管理一致性问题已经成为众多开发团队的新困境，但其却能够切实匹配业务实践。一般来讲，企业需要保留一定程度的不一致性以实现某种程度的逆转能力，从而利用快速响应处理错误状况。这种权衡有其必要性，只要确定失误成本要低于高一致性条件下可能造成的业务损失成本即可。 实践性规范与执行标准这种态度实际有点二分法的意味：微服务团队倾向于回避由企业架构部门制定的硬性执行标准，但却乐于使用甚至积极推广HTTP、ATOM以及其它微格式开放标准。 二者之间的本质区别在于标准的开发方式以及执行方式。由IETF等组织管理的标准只会在得到广泛采用之后才能真正成为业界规范，而且其往往脱胎自成功的开源项目。 这些标准拥有与商业世界完全不同的立场与定位——事实上，商业标准的制定工作往往由那些几乎不具备编程经验的团队所负责，或者受到具体厂商的过度影响。 基础设施自动化基础设施自动化技术在过去几年中得到了长足发展——而云与AWS的演进则显著降低了构建、部署及运维微服务架构所带来的复杂性水平。 大部分利用微服务机制构建的产品或者系统都是由具备丰富的持续交付及其前者——持续集成——经验的团队所完成。通过这种方式构建软件的团队能够充分发挥基础设施自动化技术成果的潜在能力。我们可以将整个流程整理成以下图表： 基本构建流程图五：基本构建流程 整体应用程序的构建、测试与推送流程能够在此类环境下顺利完成。事实证明，一旦大家利用自动化流程进行整体应用开发，那么部署更多应用程序也将成为顺理成章的轻松任务。请记住，持续交付的目标之一就是令部署变得无脑化，这意味着无论是一款应用还是三款，其实际部署流程都不会有什么区别 [12]。 我们还发现，不少团队在利用这种广泛的基础设施自动化能力管理生产环境下的微服务架构。相较于前面提到的整体与微服务应用在部署层面并没有太大区别，实际运维环境下的具体条件则存在着巨大差异。 模块部署的具体方式往往差别巨大 图六：模块部署的具体方式往往差别巨大 让正确决定更易于执行 作为一项连带效应，我们发现实现持续交付与部署能够帮助开发人员及运维人员创造出高实用性工具。这类工具能够创建artifact、管理代码库、建立简单服务或者实现标准监控与记录等常见功能。这方面最典型的实例当数Netflix公司发布的一系列开源工具，险些之外Dropwizard等方案亦得到广泛使用。 故障应对设计将服务作为组件加以使用的结果之一在于，应用程序需要经过针对性设计以确保其具备服务故障容错能力。任何服务调用都有可能因为供应程序不可用而发生问题。在这种情况下，客户端必须要尽可能做出适当的回应。相较于整体应用程序来说，服务即组件机制会增加额外的处理复杂性，这也是微服务架构的一大弊端。在这种情况下，微服务团队需要不断审视服务故障对用户体验造成的影响。Netflix公司的“猴子军团”项目就专门负责在正常运营期间对服务进行破坏，甚至利用数据中心故障来测试应用程序的弹性及监控能力。 这类自动化测试机制往往会令正等待周末下班的运维团队们感到不寒而慄。这并不是说整体架构风格就无法使用高复杂性监控机制——只不过这种情况确实不太常见。 由于服务随时可能发生故障，因此最重要的就是保持对故障的快速检测能力，并在可能的情况下对其进行自动恢复。微服务应用程序高度强调对应用程序的实时监控能力，同时不断对架构元素（数据库每秒钟接收到的请求数量）以及业务相关指标（例如每分钟收到的订单数量）进行记录。语义监控能够通过早期预警系统抢先一步做出警示，并引导开发团队对问题加以跟进与调查。 这一点对于微服务架构尤为重要，因为微服务更倾向于采用由编排及事件协作实现的应急处理方式。尽管很多专家都对应急处理方案偶尔带来的收益表示认同，但其实际上往往也是让事情变糟的罪魁祸首。为了及时阻断糟糕的应急处理并确保其拥有可恢复性，监控系统就变得极为重要。 整体应用程序的构建方式可与微服务架构同样透明——事实上也本应如此。二者的区别在于，在面对整体应用时我们需要在确切了解其运行在不同进程中的服务何时发生断开。考虑到同一进程当中可能包含多套库，这种透明度水平实际上很难实现。 微服务团队需要利用复杂的监控与记录机制处理各项服务，例如通过仪表板显示上线/下线状态以及一系列运营与业务相关指标。另外，我们还需要面对断路器状态、当前数据吞吐量以及延迟等其它常见的衡量数据。 演进设计断路器与可交代生产环境之代码 断路器模式出现在Amazon的Release It!当中，其中提到的其它模式还包括隔板模式与超时模式等。在加以结合之后，这些模式将在构建通信应用方面发挥巨大作用。Netflix公司发布的一系列博文就很好地解释了他们对这些模式选项的具体使用方式。 演进设计微服务从业者通常都具备演进设计工作背景，并将服务拆分视为一种深入型工具，旨在帮助应用程序开发人员在无需拖慢变更速度的前提下实现面向应用程序的变更控制。变更控制并不一定意味着变更数量削减——配合正确的态度与工具，大家完全可以帮助软件提供快速、频繁且经过良好控制的变更。 当尝试将一套软件系统拆分为多个组件时，我们往往面临着与具体拆分工作相关的决策任务——即我们应该遵循怎样的方针对应用程序进行拆分？而组件中的关键属性则在于其独立替换与可升级特性 [13] ——这意味着我们要找到确切的平衡点，保证自身能够在不影响其它协作对象的前提下对单一组件进行重写。事实上，很多微服务团队会更进一步，直接清退某些服务而非对其进行长期升级。 英国《卫报》网站就是个很好的例子，其应用程序在设计与构建方面作为整体应用存在，但却在逐步面向微服务架构演进。该网站的核心部分仍然属于整体性项目，但他们更倾向于通过构建微服务利用整体API实现新功能添加。这套方案对于临时性功能的实现非常重要，例如加设专题页面以显示体育赛事报道。网站中的这类组成部分能够通过快速开发语言在短时间内编写完成，并在对应事件结束后立即下线。我们还发现其它一些金融机构亦采取类似的方式公布突发性市场波动，并在数周或者数月之后将其下线。 这也强调了可替换性在模块化设计中的重要地位，其主旨正在于将模块机制贯彻整个变更模式 [14] 。大家希望只变更其中必须变更的部分，而其它模块则继续保持原样。系统当中那些几乎很少变动的部分应该立足于不同于高变更频率组件的服务。如果大家发现自己经常需要同时对两项服务做出变更，那么明显应该将二者加以合并。 将组件纳入服务也让我们能够以更高的细粒度水平进行规划制定。在整体应用程序当中，任何一项变更都需要对应用整体进行重构与重新部署。但在微服务架构方面，我们只需要重新部署包含对应变更的服务。这能够显著简化并加快发布流程。不过其弊端在于，我们必须考虑针对单一服务的变更是否会影响到其它服务。传统的整体性方案能够通过版本控制解决这类难题，但微服务领域则倾向于将版本控制作为最后一种应急办法。我们可以通过设计保证服务拥有强大的容错能力，从而应对其供应程序中出现的各类代码修改。 同步调用殊不可取 无论何时时，一旦在不同服务之间进行多次同步调用，那么可能引发宕机的概率也会以乘法形式增长。简单来讲，系统的总体宕机时间为各单个部件宕机时间的乘积。这时我们就面临着具体选择，到底是以异步方式进行调用，还是以计划方式管理由同步调用带来的宕机时间。英国《卫报》网站在其全新平台上执行了一项简单的规则——每个用户请求对应一次同步调用，而Netflix公司所使用的API则经历重新设计，确保其结构内采用异步调用机制。 微服务是否代表着未来？我们撰写这篇文章的主要目的在于解释微服务架构的基本思路与原则。而在撰写过程当中，我们明确意识到微服务架构风格确实是一项值得重视的关键成果——企业级应用程序开发人员应当对其加以了解。我们最近利用该架构构建了多套系统，而且了解到亦有其它多家企业将其纳入业务体系。 我们了解到的微服务架构先驱企业包括Amazon、Netflix、英国《卫报》、英国政府数字化服务局、realestate.com.au、Forward以及comparethemarket.com等等。2013年召开的相关会议则公布了更多参与其中的重要厂商。除此之外，另有相当一部分企业一直在使用类似的实现思路——但却并没有使用‘微服务’这样的称谓。（其通常将其冠以SOA标签——不过正如我们之前提到，SOA是一类存在大量矛盾取向的概念组合。[15] ） 尽管拥有这些积极的经验，但我们仍然无法完全肯定微服务架构就代表着软件未来的发展方向。虽然我们的实际经历证明微服务架构截至目前仍拥有优于整体性应用程序的积极优势，但必须承认只有充分的时间积累才能帮助我们做出真正完整则准确的判断结论。 我们的同事Sam Newman曾于2014年倾尽心力撰写出这本关于我们如何构建微服务架构类应用的论著。如果大家希望进一步探讨这个议题，请千万不要错过。 通常来说，架构决策的实际影响可能需要几年之后才能逐步显现出来。我们已经看到不少优秀的团队带着巨大的热情与愿景而投入工作，但最终却构建起一套陈旧不堪的整体性架构。很多人认为同样的情况不太可能发生在微服务架构身上，因为其服务边界非常明确因此不太可能发生相互影响。但由于时间尚短且系统程度不足，我们目前还无法真正评估微服务架构的成熟度水平。 人们对微服务成熟度抱持的怀疑态度也有其理由。在任何组件化尝试工作当中，最终结果的成功与否都取决于该软件与拆分后组件的契合效果。我们目前仍然很难说明组件边界的选择原则。演进设计导致边界划分变得非常困难，因此最重要的是保证其重构的简易性。但一旦将组件作为服务处理以实现远程通信，那么其重构难度将远远高于进程内库。在不同服务边界之间进行代码移动难度极大，而任何接口变更都需要在不同相关服务间实现，同时添加层的向下兼容能力，这无疑会令测试工作更加复杂。 另一大问题在于，如果相关组件间的关系不够简洁，那么我们就相当于把组件内部的复杂性转移到了不同组件间的连接当中。这样做不仅会导致复杂性扩散，同时亦会导致其明确性缺失且难以控制。立足于小型、简单组件审视问题总是更为直观，而在不同服务间进行纵览则往往会错失关注点。 最后，团队的技能水平也将起到决定性作用。新型技术成果往往要求高水平技术团队加以实施。不过高水平团队能够顺畅利用的技术方案并不一定能够在低水平人员手中发挥作用。我们已经见证了众多低水平团队构建起的如一团乱麻般的整体架构，但仍需要时间来了解微服务架构是否会在同样的情况下引发同样的状况。诚然，糟糕的团队创建出的始终只能是糟糕的系统——但我们不知道微服务架构到底是会缓解这种状况，还是令状况更中惨不忍睹。 目前有一种较为理性的论调，认为我们不应将微服务架构作为起步方案。相反，大家可以从整体性开发风格出发，保证其结合模块化机制，并在整体性特征引发实际问题后逐步将其拆分为微服务形式。（不过这样的建议并非完全理想，因为良好的进程内接口往往并不能成为良好的服务接口。） 因此我们对此抱持谨慎的乐观态度。到目前为止，我们已经了解到关于微服务架构的方方面面，而且其应该能够成为一种极具价值的开发手段。虽然还不能做出最终判断，但软件开发工作的固有挑战之一，正是我们只能根据目前掌握的远称不上完美的信息做出决策。 脚注1: “微服务”一词最早被威尼斯附近的一个软件架构师小组于2011年5月首次提及，当时他们用这个词汇来描述自己近期研究项目当中所涉及的通用性架构机制。2012年5月，该小组作出最终决议，认为“微服务”是最适合的架构名称。2012年3月，James在《微服务-Java以及Unix方式》当中就此发表了一篇案例研究报告，而Fred George也几乎在同一时间进行了相同的工作。Netflix公司的Adrian Cockcroft将微服务架构称为“细化SOA”，并认为这是一套在Web规模下具备开创意义的架构类型。Joe Walnes、Dan North、Evan Botcher以及Graham Tackley也分别在这篇文章中对此作出了评论。 2: 文章中所使用的“整体”一词长久以来一直被Unix业界所使用。其首次出现在《Unix编程艺术》一书中，用于描述那些过于庞大的系统方案。 3: 很多面向对象设计人员，也包括我们自己，都会在域驱动设计当中使用“服务对象”这一表述，专指那些并不具备实质性联系但却拥有重要作用的对象。这与我们在本文中所使用的“服务”一词在表意上完全不同。遗憾的是，服务这个词汇同时具备两种含义，而我们对这种多义词也没有更好的处理办法。 4: 我们将一款应用程序视为一套社会性体系，其中融合了代码库、函数组以及供应主体。 5: 大家可以查看梅尔文 康韦网站上的原文论述。 6: 对于规模极为庞大的应用体系，企业通常会采用二进制协议——例如protobufs。使用二进制协议的系统仍然符合智能化端点与傻瓜式通道的特性——并为了规模化而在透明度方面作出妥协。不过大多数Web方案与绝大多数企业不需要在这方面考虑太多——一般来讲，透明度越高、效果就越好。 7: 虽然无关紧要，但Jim Webber曾经将ESB解释成“Egregious Spaghetti Box”，也就是“恐怖意面盒”。 8: Netflix公司最近将其架构类型称为“细化SOA”。 9: “YAGNI”的全称是“You Aren’t Going To Need It（你根本不需要它）”，这是一项经典的用户体验原则，即不要自作聪明地添加非必要性功能。 10: 我们所宣称的整体型应用只支持单一语言确实有些不尽不实——在当下的Web系统构建过程中，大家可能需要掌握JavaScript、XHTML以及CSS，而在服务器端的语言选项则包括SQL以及某种ORM（即对象关系映射）衍生语言。没错，单一语言肯定玩不转，但我相信大家明白我想要强调的意思。 11: Adrian Cockcroft在2013年11月的Flowcon大会上作出了精彩演讲，并特别提到了“开发者自助服务”与“开发者应亲自运行所编写代码”的观点。 12: 我们在这里的说法并不准确。很明显，在更为复杂的拓扑结构中部署大量服务肯定要比在单一整体型架构内进行部署困难得多。幸运的是，各类模式能够显著降低这种复杂性——当然，在工具方面的投入仍然不可或缺。 13: 事实上，Dan North将这种类型称为“可替代式组件架构”而非微服务架构。由于其强调内容属于微服务架构的一类子集，所以我们更倾向于使用后一种表达方式。 14: Kent Beck将此作为其《实施模式》一文中的设计原则之一。 15: SOA几乎是此类架构的历史起源。我记得当SOA一词在本世纪初刚刚出现时，很多人表示“我们几年前就已经将其引入日常工作了”。也有意见认为这种架构类型似乎最早出现于早期企业计算当中，COBOL程序通过数据文件实现通信的处理机制。而在另一方面，也有人认为微服务架构与Erlang编程模型其实是同一回事，不过后者只被应用在企业应用程序当中。 Microservicesa definition of this new architectural term The term “Microservice Architecture” has sprung up over the last few years to describe a particular way of designing software applications as suites of independently deployable services. While there is no precise definition of this architecural style, there are certain commom characteristics around organization around business capablity, automated deployment, intelligence in the endpoints, and decentralized control of languages and data. Microservices “Microservices” - yet another new term on the crowded streets of software architecture. Although our natural inclination is to pass such things by with a contemptuous glance, this bit of terminology describes a style of software systems that we are finding more and more appealing. We’ve seen many projects use this style in the last few years, and results so far have been positive, so much so that for many of our colleagues this is becoming the default style for building enterprise applications. Sadly, however, there’s not much information that outlines what the microservice style is and how to do it. In short, the microservice architectural style 1 is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies. To start explaining the microservice style it’s useful to compare it to the monolithic style: a monolithic application built as a single unit. Enterprise Applications are often built in three main parts: a client-side user interface (consisting of HTML pages and javascript running in a browser on the user’s machine) a database (consisting of many tables inserted into a common, and usually relational, database management system), and a server-side application. The server-side application will handle HTTP requests, execute domain logic, retrieve and update data from the database, and select and populate HTML views to be sent to the browser. This server-side application is a monolith - a single logical executable 2. Any changes to the system involve building and deploying a new version of the server-side application. Such a monolithic server is a natural way to approach building such a system. All your logic for handling a request runs in a single process, allowing you to use the basic features of your language to divide up the application into classes, functions, and namespaces. With some care, you can run and test the application on a developer’s laptop, and use a deployment pipeline to ensure that changes are properly tested and deployed into production. You can horizontally scale the monolith by running many instances behind a load-balancer. Monolithic applications can be successful, but increasingly people are feeling frustrations with them - especially as more applications are being deployed to the cloud . Change cycles are tied together - a change made to a small part of the application, requires the entire monolith to be rebuilt and deployed. Over time it’s often hard to keep a good modular structure, making it harder to keep changes that ought to only affect one module within that module. Scaling requires scaling of the entire application rather than parts of it that require greater resource. Monoliths and MicroservicesFigure 1: Monoliths and Microservices These frustrations have led to the microservice architectural style: building applications as suites of services. As well as the fact that services are independently deployable and scalable, each service also provides a firm module boundary, even allowing for different services to be written in different programming languages. They can also be managed by different teams . We do not claim that the microservice style is novel or innovative, its roots go back at least to the design principles of Unix. But we do think that not enough people consider a microservice architecture and that many software developments would be better off if they used it. Characteristics of a Microservice ArchitectureWe cannot say there is a formal definition of the microservices architectural style, but we can attempt to describe what we see as common characteristics for architectures that fit the label. As with any definition that outlines common characteristics, not all microservice architectures have all the characteristics, but we do expect that most microservice architectures exhibit most characteristics. While we authors have been active members of this rather loose community, our intention is to attempt a description of what we see in our own work and in similar efforts by teams we know of. In particular we are not laying down some definition to conform to. Componentization via Services For as long as we’ve been involved in the software industry, there’s been a desire to build systems by plugging together components, much in the way we see things are made in the physical world. During the last couple of decades we’ve seen considerable progress with large compendiums of common libraries that are part of most language platforms. When talking about components we run into the difficult definition of what makes a component. Our definition is that a component is a unit of software that is independently replaceable and upgradeable. Microservice architectures will use libraries, but their primary way of componentizing their own software is by breaking down into services. We define libraries as components that are linked into a program and called using in-memory function calls, while services are out-of-process components who communicate with a mechanism such as a web service request, or remote procedure call. (This is a different concept to that of a service object in many OO programs 3.) One main reason for using services as components (rather than libraries) is that services are independently deployable. If you have an application 4 that consists of a multiple libraries in a single process, a change to any single component results in having to redeploy the entire application. But if that application is decomposed into multiple services, you can expect many single service changes to only require that service to be redeployed. That’s not an absolute, some changes will change service interfaces resulting in some coordination, but the aim of a good microservice architecture is to minimize these through cohesive service boundaries and evolution mechanisms in the service contracts. Another consequence of using services as components is a more explicit component interface. Most languages do not have a good mechanism for defining an explicit Published Interface. Often it’s only documentation and discipline that prevents clients breaking a component’s encapsulation, leading to overly-tight coupling between components. Services make it easier to avoid this by using explicit remote call mechanisms. Using services like this does have downsides. Remote calls are more expensive than in-process calls, and thus remote APIs need to be coarser-grained, which is often more awkward to use. If you need to change the allocation of responsibilities between components, such movements of behavior are harder to do when you’re crossing process boundaries. At a first approximation, we can observe that services map to runtime processes, but that is only a first approximation. A service may consist of multiple processes that will always be developed and deployed together, such as an application process and a database that’s only used by that service. Organized around Business Capabilities When looking to split a large application into parts, often management focuses on the technology layer, leading to UI teams, server-side logic teams, and database teams. When teams are separated along these lines, even simple changes can lead to a cross-team project taking time and budgetary approval. A smart team will optimise around this and plump for the lesser of two evils - just force the logic into whichever application they have access to. Logic everywhere in other words. This is an example of Conway’s Law 5 in action. Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of &gt; the organization’s communication structure. – Melvyn Conway, 1967 Service boundaries reinforced by team boundariesFigure 2: Conway’s Law in action The microservice approach to division is different, splitting up into services organized around business capability. Such services take a broad-stack implementation of software for that business area, including user-interface, persistant storage, and any external collaborations. Consequently the teams are cross-functional, including the full range of skills required for the development: user-experience, database, and project management. Service boundaries reinforced by team boundariesFigure 3: Service boundaries reinforced by team boundaries One company organised in this way is comparethemarket. Cross functional teams are responsible for building and operating each product and each product is split out into a number of individual services communicating via a message bus. Large monolithic applications can always be modularized around business capabilities too, although that’s not the common case. Certainly we would urge a large team building a monolithic application to divide itself along business lines. The main issue we have seen here, is that they tend to be organised around too many contexts. If the monolith spans many of these modular boundaries it can be difficult for individual members of a team to fit them into their short-term memory. Additionally we see that the modular lines require a great deal of discipline to enforce. The necessarily more explicit separation required by service components makes it easier to keep the team boundaries clear. How big is a microservice? Although “microservice” has become a popular name for this architectural style, its name does lead to an unfortunate focus on the size of service, and arguments about what constitutes “micro”. In our conversations with microservice practitioners, we see a range of sizes of services. The largest sizes reported follow Amazon’s notion of the Two Pizza Team (i.e. the whole team can be fed by two pizzas), meaning no more than a dozen people. On the smaller size scale we’ve seen setups where a team of half-a-dozen would support half-a-dozen services. This leads to the question of whether there are sufficiently large differences within this size range that the service-per-dozen-people and service-per-person sizes shouldn’t be lumped under one microservices label. At the moment we think it’s better to group them together, but it’s certainly possible that we’ll change our mind as we explore this style further. Products not Projects Most application development efforts that we see use a project model: where the aim is to deliver some piece of software which is then considered to be completed. On completion the software is handed over to a maintenance organization and the project team that built it is disbanded. Microservice proponents tend to avoid this model, preferring instead the notion that a team should own a product over its full lifetime. A common inspiration for this is Amazon’s notion of “you build, you run it” where a development team takes full responsibility for the software in production. This brings developers into day-to-day contact with how their software behaves in production and increases contact with their users, as they have to take on at least some of the support burden. The product mentality, ties in with the linkage to business capabilities. Rather than looking at the software as a set of functionality to be completed, there is an on-going relationship where the question is how can software assist its users to enhance the business capability. There’s no reason why this same approach can’t be taken with monolithic applications, but the smaller granularity of services can make it easier to create the personal relationships between service developers and their users. Smart endpoints and dumb pipes When building communication structures between different processes, we’ve seen many products and approaches that stress putting significant smarts into the communication mechanism itself. A good example of this is the Enterprise Service Bus (ESB), where ESB products often include sophisticated facilities for message routing, choreography, transformation, and applying business rules. The microservice community favours an alternative approach: smart endpoints and dumb pipes. Applications built from microservices aim to be as decoupled and as cohesive as possible - they own their own domain logic and act more as filters in the classical Unix sense - receiving a request, applying logic as appropriate and producing a response. These are choreographed using simple RESTish protocols rather than complex protocols such as WS-Choreography or BPEL or orchestration by a central tool. The two protocols used most commonly are HTTP request-response with resource API’s and lightweight messaging 6. The best expression of the first is Be of the web, not behind the web – Ian Robinson Microservice teams use the principles and protocols that the world wide web (and to a large extent, Unix) is built on. Often used resources can be cached with very little effort on the part of developers or operations folk. The second approach in common use is messaging over a lightweight message bus. The infrastructure chosen is typically dumb (dumb as in acts as a message router only) - simple implementations such as RabbitMQ or ZeroMQ don’t do much more than provide a reliable asynchronous fabric - the smarts still live in the end points that are producing and consuming messages; in the services. In a monolith, the components are executing in-process and communication between them is via either method invocation or function call. The biggest issue in changing a monolith into microservices lies in changing the communication pattern. A naive conversion from in-memory method calls to RPC leads to chatty communications which don’t perform well. Instead you need to replace the fine-grained communication with a coarser -grained approach. Microservices and SOA When we’ve talked about microservices a common question is whether this is just Service Oriented Architecture (SOA) that we saw a decade ago. There is merit to this point, because the microservice style is very similar to what some advocates of SOA have been in favor of. The problem, however, is that SOA means too many different things, and that most of the time that we come across something called “SOA” it’s significantly different to the style we’re describing here, usually due to a focus on ESBs used to integrate monolithic applications. In particular we have seen so many botched implementations of service orientation - from the tendency to hide complexity away in ESB’s 7, to failed multi-year initiatives that cost millions and deliver no value, to centralised governance models that actively inhibit change, that it is sometimes difficult to see past these problems. Certainly, many of the techniques in use in the microservice community have grown from the experiences of developers integrating services in large organisations. The Tolerant Reader pattern is an example of this. Efforts to use the web have contributed, using simple protocols is another approach derived from these experiences - a reaction away from central standards that have reached a complexity that is, frankly, breathtaking. (Any time you need an ontology to manage your ontologies you know you are in deep trouble.) This common manifestation of SOA has led some microservice advocates to reject the SOA label entirely, although others consider microservices to be one form of SOA 8, perhaps service orientation done right. Either way, the fact that SOA means such different things means it’s valuable to have a term that more crisply defines this architectural style. Decentralized Governance One of the consequences of centralised governance is the tendency to standardise on single technology platforms. Experience shows that this approach is constricting - not every problem is a nail and not every solution a hammer. We prefer using the right tool for the job and while monolithic applications can take advantage of different languages to a certain extent, it isn’t that common. Splitting the monolith’s components out into services we have a choice when building each of them. You want to use Node.js to standup a simple reports page? Go for it. C++ for a particularly gnarly near-real-time component? Fine. You want to swap in a different flavour of database that better suits the read behaviour of one component? We have the technology to rebuild him. Of course, just because you can do something, doesn’t mean you should - but partitioning your system in this way means you have the option. Teams building microservices prefer a different approach to standards too. Rather than use a set of defined standards written down somewhere on paper they prefer the idea of producing useful tools that other developers can use to solve similar problems to the ones they are facing. These tools are usually harvested from implementations and shared with a wider group, sometimes, but not exclusively using an internal open source model. Now that git and github have become the de facto version control system of choice, open source practices are becoming more and more common in-house . Netflix is a good example of an organisation that follows this philosophy. Sharing useful and, above all, battle-tested code as libraries encourages other developers to solve similar problems in similar ways yet leaves the door open to picking a different approach if required. Shared libraries tend to be focused on common problems of data storage, inter-process communication and as we discuss further below, infrastructure automation. For the microservice community, overheads are particularly unattractive. That isn’t to say that the community doesn’t value service contracts. Quite the opposite, since there tend to be many more of them. It’s just that they are looking at different ways of managing those contracts. Patterns like Tolerant Reader and Consumer-Driven Contracts are often applied to microservices. These aid service contracts in evolving independently. Executing consumer driven contracts as part of your build increases confidence and provides fast feedback on whether your services are functioning. Indeed we know of a team in Australia who drive the build of new services with consumer driven contracts. They use simple tools that allow them to define the contract for a service. This becomes part of the automated build before code for the new service is even written. The service is then built out only to the point where it satisfies the contract - an elegant approach to avoid the ‘YAGNI’ [9] dilemma when building new software. These techniques and the tooling growing up around them, limit the need for central contract management by decreasing the temporal coupling between services. Many languages, many options The growth of JVM as a platform is just the latest example of mixing languages within a common platform. It’s been common practice to shell-out to a higher level language to take advantage of higher level abstractions for decades. As is dropping down to the metal and writing performance sensitive code in a lower level one. However, many monoliths don’t need this level of performance optimisation nor are DSL’s and higher level abstractions that common (to our dismay). Instead monoliths are usually single language and the tendency is to limit the number of technologies in use [10]. Perhaps the apogee of decentralised governance is the build it / run it ethos popularised by Amazon. Teams are responsible for all aspects of the software they build including operating the software 24/7. Devolution of this level of responsibility is definitely not the norm but we do see more and more companies pushing responsibility to the development teams. Netflix is another organisation that has adopted this ethos [11]. Being woken up at 3am every night by your pager is certainly a powerful incentive to focus on quality when writing your code. These ideas are about as far away from the traditional centralized governance model as it is possible to be. Decentralized Data Management Decentralization of data management presents in a number of different ways. At the most abstract level, it means that the conceptual model of the world will differ between systems. This is a common issue when integrating across a large enterprise, the sales view of a customer will differ from the support view. Some things that are called customers in the sales view may not appear at all in the support view. Those that do may have different attributes and (worse) common attributes with subtly different semantics. This issue is common between applications, but can also occur within applications, particular when that application is divided into separate components. A useful way of thinking about this is the Domain-Driven Design notion of Bounded Context. DDD divides a complex domain up into multiple bounded contexts and maps out the relationships between them. This process is useful for both monolithic and microservice architectures, but there is a natural correlation between service and context boundaries that helps clarify, and as we describe in the section on business capabilities, reinforce the separations. As well as decentralizing decisions about conceptual models, microservices also decentralize data storage decisions. While monolithic applications prefer a single logical database for persistant data, enterprises often prefer a single database across a range of applications - many of these decisions driven through vendor’s commercial models around licensing. Microservices prefer letting each service manage its own database, either different instances of the same database technology, or entirely different database systems - an approach called Polyglot Persistence. You can use polyglot persistence in a monolith, but it appears more frequently with microservices. Decentralizing responsibility for data across microservices has implications for managing updates. The common approach to dealing with updates has been to use transactions to guarantee consistency when updating multiple resources. This approach is often used within monoliths. Using transactions like this helps with consistency, but imposes significant temporal coupling, which is problematic across multiple services. Distributed transactions are notoriously difficult to implement and and as a consequence microservice architectures emphasize transactionless coordination between services, with explicit recognition that consistency may only be eventual consistency and problems are dealt with by compensating operations. Choosing to manage inconsistencies in this way is a new challenge for many development teams, but it is one that often matches business practice. Often businesses handle a degree of inconsistency in order to respond quickly to demand, while having some kind of reversal process to deal with mistakes. The trade-off is worth it as long as the cost of fixing mistakes is less than the cost of lost business under greater consistency. Battle-tested standards and enforced standards It’s a bit of a dichotomy that microservice teams tend to eschew the kind of rigid enforced standards laid down by enterprise architecture groups but will happily use and even evangelise the use of open standards such as HTTP, ATOM and other microformats. The key difference is how the standards are developed and how they are enforced. Standards managed by groups such as the IETF only become standards when there are several live implementations of them in the wider world and which often grow from successful open-source projects. These standards are a world apart from many in a corporate world, which are often developed by groups that have little recent programming experience or overly influenced by vendors. Infrastructure Automation Infrastructure automation techniques have evolved enormously over the last few years - the evolution of the cloud and AWS in particular has reduced the operational complexity of building, deploying and operating microservices. Many of the products or systems being build with microservices are being built by teams with extensive experience of Continuous Delivery and it’s precursor, Continuous Integration. Teams building software this way make extensive use of infrastructure automation techniques. This is illustrated in the build pipeline shown below. basic build pipelineFigure 5: basic build pipeline Since this isn’t an article on Continuous Delivery we will call attention to just a couple of key features here. We want as much confidence as possible that our software is working, so we run lots of automated tests. Promotion of working software ‘up’ the pipeline means we automate deployment to each new environment. A monolithic application will be built, tested and pushed through these environments quite happlily. It turns out that once you have invested in automating the path to production for a monolith, then deploying more applications doesn’t seem so scary any more. Remember, one of the aims of CD is to make deployment boring, so whether its one or three applications, as long as its still boring it doesn’t matter [12]. Another area where we see teams using extensive infrastructure automation is when managing microservices in production. In contrast to our assertion above that as long as deployment is boring there isn’t that much difference between monoliths and microservices, the operational landscape for each can be strikingly different. Module deployment often differsFigure 6: Module deployment often differs Make it easy to do the right thing One side effect we have found of increased automation as a consequence of continuous delivery and deployment is the creation of useful tools to help developers and operations folk. Tooling for creating artefacts, managing codebases, standing up simple services or for adding standard monitoring and logging are pretty common now. The best example on the web is probably Netflix’s set of open source tools, but there are others including Dropwizard which we have used extensively. Design for failure A consequence of using services as components, is that applications need to be designed so that they can tolerate the failure of services. Any service call could fail due to unavailability of the supplier, the client has to respond to this as gracefully as possible. This is a disadvantage compared to a monolithic design as it introduces additional complexity to handle it. The consequence is that microservice teams constantly reflect on how service failures affect the user experience. Netflix’s Simian Army induces failures of services and even datacenters during the working day to test both the application’s resilience and monitoring. This kind of automated testing in production would be enough to give most operation groups the kind of shivers usually preceding a week off work. This isn’t to say that monolithic architectural styles aren’t capable of sophisticated monitoring setups - it’s just less common in our experience. Since services can fail at any time, it’s important to be able to detect the failures quickly and, if possible, automatically restore service. Microservice applications put a lot of emphasis on real-time monitoring of the application, checking both architectural elements (how many requests per second is the database getting) and business relevant metrics (such as how many orders per minute are received). Semantic monitoring can provide an early warning system of something going wrong that triggers development teams to follow up and investigate. This is particularly important to a microservices architecture because the microservice preference towards choreography and event collaboration leads to emergent behavior. While many pundits praise the value of serendipitous emergence, the truth is that emergent behavior can sometimes be a bad thing. Monitoring is vital to spot bad emergent behavior quickly so it can be fixed. Monoliths can be built to be as transparent as a microservice - in fact, they should be. The difference is that you absolutely need to know when services running in different processes are disconnected. With libraries within the same process this kind of transparency is less likely to be useful. Microservice teams would expect to see sophisticated monitoring and logging setups for each individual service such as dashboards showing up/down status and a variety of operational and business relevant metrics. Details on circuit breaker status, current throughput and latency are other examples we often encounter in the wild. The circuit breaker and production ready code Circuit Breaker appears in Release It!alongside other patterns such as Bulkhead and Timeout. Implemented together, these patterns are crucially important when building communicating applications. This Netflix blog entry does a great job of explaining their application of them. Evolutionary Design Microservice practitioners, usually have come from an evolutionary design background and see service decomposition as a further tool to enable application developers to control changes in their application without slowing down change. Change control doesn’t necessarily mean change reduction - with the right attitudes and tools you can make frequent, fast, and well-controlled changes to software. Whenever you try to break a software system into components, you’re faced with the decision of how to divide up the pieces - what are the principles on which we decide to slice up our application? The key property of a component is the notion of independent replacement and upgradeability [13] - which implies we look for points where we can imagine rewriting a component without affecting its collaborators. Indeed many microservice groups take this further by explicitly expecting many services to be scrapped rather than evolved in the longer term. The Guardian website is a good example of an application that was designed and built as a monolith, but has been evolving in a microservice direction. The monolith still is the core of the website, but they prefer to add new features by building microservices that use the monolith’s API. This approach is particularly handy for features that are inherently temporary, such as specialized pages to handle a sporting event. Such a part of the website can quickly be put together using rapid development languages, and removed once the event is over. We’ve seen similar approaches at a financial institution where new services are added for a market opportunity and discarded after a few months or even weeks. This emphasis on replaceability is a special case of a more general principle of modular design, which is to drive modularity through the pattern of change [14]. You want to keep things that change at the same time in the same module. Parts of a system that change rarely should be in different services to those that are currently undergoing lots of churn. If you find yourself repeatedly changing two services together, that’s a sign that they should be merged. Putting components into services adds an opportunity for more granular release planning. With a monolith any changes require a full build and deployment of the entire application. With microservices, however, you only need to redeploy the service(s) you modified. This can simplify and speed up the release process. The downside is that you have to worry about changes to one service breaking its consumers. The traditional integration approach is to try to deal with this problem using versioning, but the preference in the microservice world is to only use versioning as a last resort. We can avoid a lot of versioning by designing services to be as tolerant as possible to changes in their suppliers. Synchronous calls considered harmful Any time you have a number of synchronous calls between services you will encounter the multiplicative effect of downtime. Simply, this is when the downtime of your system becomes the product of the downtimes of the individual components. You face a choice, making your calls asynchronous or managing the downtime. At www.guardian.co.uk they have implemented a simple rule on the new platform - one synchronous call per user request while at Netflix, their platform API redesign has built asynchronicity into the API fabric. Are Microservices the Future?Our main aim in writing this article is to explain the major ideas and principles of microservices. By taking the time to do this we clearly think that the microservices architectural style is an important idea - one worth serious consideration for enterprise applications. We have recently built several systems using the style and know of others who have used and favor this approach. Those we know about who are in some way pioneering the architectural style include Amazon, Netflix, The Guardian, the UK Government Digital Service, realestate.com.au, Forward and comparethemarket.com. The conference circuit in 2013 was full of examples of companies that are moving to something that would class as microservices - including Travis CI. In addition there are plenty of organizations that have long been doing what we would class as microservices, but without ever using the name. (Often this is labelled as SOA - although, as we’ve said, SOA comes in many contradictory forms. [15]) Despite these positive experiences, however, we aren’t arguing that we are certain that microservices are the future direction for software architectures. While our experiences so far are positive compared to monolithic applications, we’re conscious of the fact that not enough time has passed for us to make a full judgement. Often the true consequences of your architectural decisions are only evident several years after you made them. We have seen projects where a good team, with a strong desire for modularity, has built a monolithic architecture that has decayed over the years. Many people believe that such decay is less likely with microservices, since the service boundaries are explicit and hard to patch around. Yet until we see enough systems with enough age, we can’t truly assess how microservice architectures mature. There are certainly reasons why one might expect microservices to mature poorly. In any effort at componentization, success depends on how well the software fits into components. It’s hard to figure out exactly where the component boundaries should lie. Evolutionary design recognizes the difficulties of getting boundaries right and thus the importance of it being easy to refactor them. But when your components are services with remote communications, then refactoring is much harder than with in-process libraries. Moving code is difficult across service boundaries, any interface changes need to be coordinated between participants, layers of backwards compatibility need to be added, and testing is made more complicated. Another issue is If the components do not compose cleanly, then all you are doing is shifting complexity from inside a component to the connections between components. Not just does this just move complexity around, it moves it to a place that’s less explicit and harder to control. It’s easy to think things are better when you are looking at the inside of a small, simple component, while missing messy connections between services. Finally, there is the factor of team skill. New techniques tend to be adopted by more skillful teams. But a technique that is more effective for a more skillful team isn’t necessarily going to work for less skillful teams. We’ve seen plenty of cases of less skillful teams building messy monolithic architectures, but it takes time to see what happens when this kind of mess occurs with microservices. A poor team will always create a poor system - it’s very hard to tell if microservices reduce the mess in this case or make it worse. One reasonable argument we’ve heard is that you shouldn’t start with a microservices architecture. Instead begin with a monolith, keep it modular, and split it into microservices once the monolith becomes a problem. (Although this advice isn’t ideal, since a good in-process interface is usually not a good service interface.) So we write this with cautious optimism. So far, we’ve seen enough about the microservice style to feel that it can be a worthwhile road to tread. We can’t say for sure where we’ll end up, but one of the challenges of software development is that you can only make decisions based on the imperfect information that you currently have to hand. Footnotes1: The term “microservice” was discussed at a workshop of software architects near Venice in May, 2011 to describe what the participants saw as a common architectural style that many of them had been recently exploring. In May 2012, the same group decided on “microservices” as the most appropriate name. James presented some of these ideas as a case study in March 2012 at 33rd Degree in Krakow in Microservices - Java, the Unix Way as did Fred George about the same time. Adrian Cockcroft at Netflix, describing this approach as “fine grained SOA” was pioneering the style at web scale as were many of the others mentioned in this article - Joe Walnes, Dan North, Evan Botcher and Graham Tackley. 2: The term monolith has been in use by the Unix community for some time. It appears in The Art of Unix Programming to describe systems that get too big. 3: Many object-oriented designers, including ourselves, use the term service object in the Domain-Driven Design sense for an object that carries out a significant process that isn’t tied to an entity. This is a different concept to how we’re using “service” in this article. Sadly the term service has both meanings and we have to live with the polyseme. 4: We consider an application to be a social construction that binds together a code base, group of functionality, and body of funding. 5: The original paper can be found on Melvyn Conway’s website here 6: At extremes of scale, organisations often move to binary protocols - protobufs for example. Systems using these still exhibit the characteristic of smart endpoints, dumb pipes - and trade off transparency for scale. Most web properties and certainly the vast majority of enterprises don’t need to make this tradeoff - transparency can be a big win. 7: We can’t resist mentioning Jim Webber’s statement that ESB stands for “Egregious Spaghetti Box”. 8: Netflix makes the link explicit - until recently referring to their architectural style as fine-grained SOA. 9: “YAGNI” or “You Aren’t Going To Need It” is an XP principle and exhortation to not add features until you know you need them. 10: It’s a little disengenuous of us to claim that monoliths are single language - in order to build systems on todays web, you probably need to know JavaScript and XHTML, CSS, your server side language of choice, SQL and an ORM dialect. Hardly single language, but you know what we mean. 11: Adrian Cockcroft specifically mentions “developer self-service” and “Developers run what they wrote”(sic) in this excellent presentation delivered at Flowcon in November, 2013. 12: We are being a little disengenuous here. Obviously deploying more services, in more complex topologies is more difficult than deploying a single monolith. Fortunately, patterns reduce this complexity - investment in tooling is still a must though. 13: In fact, Dan North refers to this style as Replaceable Component Architecture rather than microservices. Since this seems to talk to a subset of the characteristics we prefer the latter. 14: Kent Beck highlights this as one his design principles in Implementation Patterns. 15: And SOA is hardly the root of this history. I remember people saying “we’ve been doing this for years” when the SOA term appeared at the beginning of the century. One argument was that this style sees its roots as the way COBOL programs communicated via data files in the earliest days of enterprise computing. In another direction, one could argue that microservices are the same thing as the Erlang programming model, but applied to an enterprise application context.","tags":[{"name":"微服务","slug":"微服务","permalink":"http://yoursite.com/tags/微服务/"}]}]