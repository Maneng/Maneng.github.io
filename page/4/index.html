<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://yoursite.com">
  <title>Marnner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Just do it">
<meta property="og:type" content="website">
<meta property="og:title" content="Marnner">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Marnner">
<meta property="og:description" content="Just do it">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Marnner">
<meta name="twitter:description" content="Just do it">
  
    <link rel="alternative" href="/atom.xml" title="Marnner" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" type="text/css" href="/./main.ea2298.css">
  <style type="text/css">
  
    #container.show {
      background: linear-gradient(200deg,#a0cfe4,#e8c37e);
    }
  </style>
  

  

</head>

<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      
<div class="overlay" style="background: #4d4d4d"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="/img/avatar.jpg" class="js-avatar">
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">marnner</a></h1>
		</hgroup>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/tags/随笔/">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
    		
    			
    			<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有文章</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'friends')" href="javascript:void(0)">友链</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">关于我</a>
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/Maneng" title="github"><i class="icon-github"></i></a>
		        
					<a class="qq" target="_blank" href="/643449856" title="qq"><i class="icon-qq"></i></a>
		        
					<a class="weixin" target="_blank" href="/silencevva" title="weixin"><i class="icon-weixin"></i></a>
		        
					<a class="mail" target="_blank" href="mailto:marnner@qq.com" title="mail"><i class="icon-mail"></i></a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #4d4d4d"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="/img/avatar.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author">marnner</h1>
			</hgroup>
			
			
			
				
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Maneng" title="github"><i class="icon-github"></i></a>
			        
						<a class="qq" target="_blank" href="/643449856" title="qq"><i class="icon-qq"></i></a>
			        
						<a class="weixin" target="_blank" href="/silencevva" title="weixin"><i class="icon-weixin"></i></a>
			        
						<a class="mail" target="_blank" href="mailto:marnner@qq.com" title="mail"><i class="icon-mail"></i></a>
			        
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 50%">
				
				
					<li style="width: 50%"><a href="/">主页</a></li>
		        
					<li style="width: 50%"><a href="/tags/随笔/">随笔</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1" class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            
  
    <article id="post-Spring BeanCreationException" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/13/Spring BeanCreationException/">Spring BeanCreationException</a>
    </h1>
  

        
        <a href="/2017/06/13/Spring BeanCreationException/" class="archive-article-date">
  	<time datetime="2017-06-13T06:35:17.661Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-06-13</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Spring-BeanCreationException"><a href="#Spring-BeanCreationException" class="headerlink" title="Spring BeanCreationException"></a>Spring BeanCreationException</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a><strong>1.概述</strong></h2><p>在这片文章中，我们会讨论关于Spring的异常：</p>
<blockquote>
<p>Spring org.springframework.beans.factory.BeanCreationException </p>
</blockquote>
<p>当<strong>BeanFactory</strong>创建定义的<strong>bean</strong>的时候，本文中将会讨论这种常见的异常，<br>以及它们解决方案。</p>
<h2 id="2-Cause-org-springframework-beans-factory-NoSuchBeanDefinitionException"><a href="#2-Cause-org-springframework-beans-factory-NoSuchBeanDefinitionException" class="headerlink" title="2.Cause: org.springframework.beans.factory.NoSuchBeanDefinitionException"></a><strong>2.Cause: org.springframework.beans.factory.NoSuchBeanDefinitionException</strong></h2><p><strong>BeanCreationException</strong>最常见的原因是Spring试图注入上下文中不存在的bean。</p>
<p>例如，BeanA尝试注入BeanB：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanA</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> BeanB dependency;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果在上下文中找不到BeanB，则会抛出以下异常（创建Bean时出错）：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Error creating bean <span class="keyword">with</span> name <span class="string">'beanA'</span>: Injection <span class="keyword">of</span> autowired dependencies failed; </div><div class="line"><span class="keyword">nested</span> exception <span class="keyword">is</span> org.springframework.beans.factory.BeanCreationException: </div><div class="line">Could <span class="keyword">not</span> autowire field: <span class="keyword">private</span> org.baeldung.web.BeanB org.baeldung.web.BeanA.dependency; </div><div class="line"><span class="keyword">nested</span> exception <span class="keyword">is</span> org.springframework.beans.factory.NoSuchBeanDefinitionException: </div><div class="line">No qualifying bean <span class="keyword">of</span> <span class="keyword">type</span> [org.baeldung.web.BeanB] found <span class="keyword">for</span> dependency: </div><div class="line">expected at least <span class="number">1</span> bean which qualifies <span class="keyword">as</span> autowire candidate <span class="keyword">for</span> this dependency. </div><div class="line">Dependency annotations: <span class="comment">&#123;@org.springframework.beans.factory.annotation.Autowired(required=true)&#125;</span></div></pre></td></tr></table></figure>
<p>要诊断这种类型的问题 - 首先，确保bean被声明：</p>
<ul>
<li>在使用<code>&lt;bean /&gt;</code>元素的XML配置文件中</li>
<li>或通过<strong>@Bean</strong>注解在Java @Configuration类中</li>
<li>或者注解为：<strong>@Component</strong>，<strong>@Repository</strong>，<strong>@Service</strong>，<strong>@Controller</strong>和类路径扫描对于该包是active的</li>
</ul>
<p>还要检查配置文件或类真正正确的由Spring获取到并加载到主上下文中。</p>
<h2 id="3-Cause-org-springframework-beans-factory-NoUniqueBeanDefinitionException"><a href="#3-Cause-org-springframework-beans-factory-NoUniqueBeanDefinitionException" class="headerlink" title="3.Cause:org.springframework.beans.factory.NoUniqueBeanDefinitionException"></a><strong>3.Cause:org.springframework.beans.factory.NoUniqueBeanDefinitionException</strong></h2><p>bean创建异常的另一个类似原因是Spring试图通过类型（即其接口）注入一个bean，并在上下文中找到两个或更多个bean来实现该接口。 例如，BeanB1和BeanB2都实现了相同的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanB1</span> <span class="keyword">implements</span> <span class="title">IBeanB</span> </span>&#123; ... &#125;</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanB2</span> <span class="keyword">implements</span> <span class="title">IBeanB</span> </span>&#123; ... &#125;</div><div class="line"> </div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanA</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> IBeanB dependency;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这将导致Spring bean工厂抛出以下异常：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Error creating bean <span class="keyword">with</span> name <span class="string">'beanA'</span>: Injection <span class="keyword">of</span> autowired dependencies failed; </div><div class="line"><span class="keyword">nested</span> exception <span class="keyword">is</span> org.springframework.beans.factory.BeanCreationException: </div><div class="line">Could <span class="keyword">not</span> autowire field: <span class="keyword">private</span> org.baeldung.web.IBeanB org.baeldung.web.BeanA.b; </div><div class="line"><span class="keyword">nested</span> exception <span class="keyword">is</span> org.springframework.beans.factory.NoUniqueBeanDefinitionException: </div><div class="line">No qualifying bean <span class="keyword">of</span> <span class="keyword">type</span> [org.baeldung.web.IBeanB] <span class="keyword">is</span> defined: </div><div class="line">expected single <span class="keyword">matching</span> bean but found <span class="number">2</span>: beanB1,beanB2</div></pre></td></tr></table></figure>
<h2 id="4-Cause-org-springframework-beans-BeanInstantiationException"><a href="#4-Cause-org-springframework-beans-BeanInstantiationException" class="headerlink" title="4. Cause: org.springframework.beans.BeanInstantiationException"></a><strong>4. Cause: org.springframework.beans.BeanInstantiationException</strong></h2><h3 id="4-1-自定义异常"><a href="#4-1-自定义异常" class="headerlink" title="4.1 自定义异常"></a>4.1 自定义异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanA</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanA</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如预期的那样，这将导致Spring很快的失败，并且抛出异常：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Error creating bean <span class="keyword">with</span> name <span class="string">'beanA'</span> defined <span class="keyword">in</span> file [...BeanA.class]: </div><div class="line">Instantiation <span class="keyword">of</span> bean failed; <span class="keyword">nested</span> exception <span class="keyword">is</span> org.springframework.beans.BeanInstantiationException: </div><div class="line">Could <span class="keyword">not</span> instantiate bean <span class="keyword">class</span> [org.baeldung.web.BeanA]: </div><div class="line"><span class="function"><span class="keyword">Constructor</span> <span class="title">threw</span> <span class="title">exception</span>;</span> </div><div class="line"><span class="keyword">nested</span> exception <span class="keyword">is</span> java.lang.NullPointerException</div></pre></td></tr></table></figure>
<h3 id="4-2-java-lang-InstantiationException"><a href="#4-2-java-lang-InstantiationException" class="headerlink" title="4.2 java.lang.InstantiationException"></a>4.2 java.lang.InstantiationException</h3><p><strong>BeanInstantiationException</strong>的另一个可能的发生是将抽象类定义为XML中的bean;这必须在XML中，因为在Java <strong>@Configuration</strong>文件中没有办法这样做，而类路径扫描将忽略抽象类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanA</span> <span class="keyword">implements</span> <span class="title">IBeanA</span> </span>&#123; ... &#125;</div></pre></td></tr></table></figure>
<p>bean的XML定义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanA"</span> <span class="attr">class</span>=<span class="string">"org.baeldung.web.BeanA"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>此设置将导致类似异常：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">org.springframework.beans.factory.BeanCreationException: </div><div class="line">Error creating bean <span class="keyword">with</span> name <span class="string">'beanA'</span> defined <span class="keyword">in</span> <span class="keyword">class</span> path resource [beansInXml.xml]: </div><div class="line">Instantiation <span class="keyword">of</span> bean failed; </div><div class="line"><span class="keyword">nested</span> exception <span class="keyword">is</span> org.springframework.beans.BeanInstantiationException: </div><div class="line">Could <span class="keyword">not</span> instantiate bean <span class="keyword">class</span> [org.baeldung.web.BeanA]: </div><div class="line"><span class="keyword">Is</span> it an <span class="keyword">abstract</span> <span class="keyword">class</span>?; </div><div class="line"><span class="keyword">nested</span> exception <span class="keyword">is</span> java.lang.InstantiationException</div></pre></td></tr></table></figure>
<h3 id="4-3-java-lang-NoSuchMethodException"><a href="#4-3-java-lang-NoSuchMethodException" class="headerlink" title="4.3. java.lang.NoSuchMethodException"></a>4.3. java.lang.NoSuchMethodException</h3><p>如果一个bean没有默认构造函数，并且Spring尝试通过查找该构造函数实例化它，这将导致运行时异常;例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanA</span> <span class="keyword">implements</span> <span class="title">IBeanA</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanA</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        System.out.println(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当这个bean被类路径扫描机制获取时，将会导致：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Error creating bean <span class="keyword">with</span> name <span class="string">'beanA'</span> defined <span class="keyword">in</span> file [...BeanA.class]: Instantiation <span class="keyword">of</span> bean failed; </div><div class="line"><span class="keyword">nested</span> exception <span class="keyword">is</span> org.springframework.beans.BeanInstantiationException: </div><div class="line">Could <span class="keyword">not</span> instantiate bean <span class="keyword">class</span> [org.baeldung.web.BeanA]: </div><div class="line">No <span class="keyword">default</span> <span class="function"><span class="keyword">constructor</span> <span class="title">found</span>;</span> </div><div class="line"><span class="keyword">nested</span> exception <span class="keyword">is</span> java.lang.NoSuchMethodException: org.baeldung.web.BeanA.&lt;init&gt;()</div></pre></td></tr></table></figure>
<p>当类中的Spring依赖关系不具有相同的版本时，可能会出现类似异常但是更难诊断的异常是由于API更改，此类版本不兼容可能会导致<strong>NoSuchMethodException</strong>异常。解决这个问题的方法是确保所有的Spring库在项目中都有完全相同的版本。</p>
<h2 id="6-org-springframework-beans-NotWritablePropertyException"><a href="#6-org-springframework-beans-NotWritablePropertyException" class="headerlink" title="6.org.springframework.beans.NotWritablePropertyException"></a><strong>6.org.springframework.beans.NotWritablePropertyException</strong></h2><p>另一个可能性是定义一个bean - BeanA - 引用另一个Bean - BeanB–在BeanA中没有相应的setter方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanA</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> IBeanB dependency;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanB</span> <span class="keyword">implements</span> <span class="title">IBeanB</span> </span>&#123; ... &#125;</div></pre></td></tr></table></figure>
<p>Spring XML配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanA"</span> <span class="attr">class</span>=<span class="string">"org.baeldung.web.BeanA"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beanB"</span> <span class="attr">ref</span>=<span class="string">"beanB"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>再次，这只能发生在XML配置中，因为在使用Java <strong>@Configuration</strong>时，编译器会使此问题无法再现。</p>
<p>当然，为了解决这个问题，需要为IBeanB添加setter：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanA</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> IBeanB dependency;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDependency</span><span class="params">(<span class="keyword">final</span> IBeanB dependency)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.dependency = dependency;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="6-org-springframework-beans-CannotLoadBeanClassException"><a href="#6-org-springframework-beans-CannotLoadBeanClassException" class="headerlink" title="6.org.springframework.beans.CannotLoadBeanClassException"></a><strong>6.org.springframework.beans.CannotLoadBeanClassException</strong></h2><p>当Spring无法加载定义的bean的类时，抛出此异常 - 如果Spring XML配置包含一个根本没有相应类的bean，则可能会发生此异常。例如，如果类BeanZ不存在，以下定义将导致异常：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"beanZ"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.baeldung.web.BeanZ"</span> /&gt;</div></pre></td></tr></table></figure>
<p>根本原因是<strong>ClassNotFoundException</strong>这种异常：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">nested</span> exception <span class="keyword">is</span> org.springframework.beans.factory.BeanCreationException: </div><div class="line">...</div><div class="line"><span class="keyword">nested</span> exception <span class="keyword">is</span> org.springframework.beans.factory.CannotLoadBeanClassException: </div><div class="line">Cannot find <span class="keyword">class</span> [org.baeldung.web.BeanZ] <span class="keyword">for</span> bean <span class="keyword">with</span> name <span class="string">'beanZ'</span></div><div class="line">defined <span class="keyword">in</span> <span class="keyword">class</span> path resource [beansInXml.xml]; </div><div class="line"><span class="keyword">nested</span> exception <span class="keyword">is</span> java.lang.ClassNotFoundException: org.baeldung.web.BeanZ</div></pre></td></tr></table></figure>
<h2 id="7-org-springframework-beans-Children-of-BeanCreationException"><a href="#7-org-springframework-beans-Children-of-BeanCreationException" class="headerlink" title="7.org.springframework.beans.Children of BeanCreationException"></a><strong>7.org.springframework.beans.Children of BeanCreationException</strong></h2><h3 id="7-1-The-org-springframework-beans-factory-BeanCurrentlyInCreationException"><a href="#7-1-The-org-springframework-beans-factory-BeanCurrentlyInCreationException" class="headerlink" title="7.1. The org.springframework.beans.factory.BeanCurrentlyInCreationException"></a>7.1. The org.springframework.beans.factory.BeanCurrentlyInCreationException</h3><p><strong>BeanCreationException</strong>的子类之一是<strong>BeanCurrentlyInCreationException</strong>;这通常在使用构造函数注入时出现 - 例如，在循环依赖性的情况下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanA</span> <span class="keyword">implements</span> <span class="title">IBeanA</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> IBeanB beanB;</div><div class="line"> </div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanA</span><span class="params">(<span class="keyword">final</span> IBeanB beanB)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.beanB = beanB;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanB</span> <span class="keyword">implements</span> <span class="title">IBeanB</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> IBeanA beanA;</div><div class="line"> </div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanB</span><span class="params">(<span class="keyword">final</span> IBeanA beanA)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.beanA = beanA;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Spring将无法解决这种情况，最终的结果将是：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">org.springframework.beans.factory.BeanCurrentlyInCreationException: </div><div class="line"><span class="keyword">Error</span> creating bean <span class="keyword">with</span> name <span class="comment">'beanA': </span></div><div class="line">Requested bean <span class="keyword">is</span> currently <span class="keyword">in</span> creation: <span class="keyword">Is</span> there an unresolvable circular reference?</div></pre></td></tr></table></figure>
<p>完整的异常是非常冗长的：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">org.springframework.beans.factory.UnsatisfiedDependencyException: </div><div class="line">Error creating bean <span class="keyword">with</span> name <span class="string">'beanA'</span> defined <span class="keyword">in</span> file [...BeanA.class]: </div><div class="line">Unsatisfied dependency expressed through <span class="function"><span class="keyword">constructor</span> <span class="title">argument</span> <span class="title">with</span> <span class="title">index</span> 0 </span></div><div class="line"><span class="title">of</span> <span class="title">type</span> [<span class="title">org</span>.<span class="title">baeldung</span>.<span class="title">web</span>.<span class="title">IBeanB</span>]: : </div><div class="line">Error creating bean <span class="keyword">with</span> name <span class="string">'beanB'</span> defined <span class="keyword">in</span> file [...BeanB.class]: </div><div class="line">Unsatisfied dependency expressed through <span class="function"><span class="keyword">constructor</span> <span class="title">argument</span> <span class="title">with</span> <span class="title">index</span> 0 </span></div><div class="line"><span class="title">of</span> <span class="title">type</span> [<span class="title">org</span>.<span class="title">baeldung</span>.<span class="title">web</span>.<span class="title">IBeanA</span>]: : </div><div class="line">Error creating bean <span class="keyword">with</span> name <span class="string">'beanA'</span>: Requested bean <span class="keyword">is</span> currently <span class="keyword">in</span> creation: </div><div class="line"><span class="keyword">Is</span> there an unresolvable circular <span class="keyword">reference</span>?; </div><div class="line"><span class="keyword">nested</span> exception <span class="keyword">is</span> org.springframework.beans.factory.BeanCurrentlyInCreationException: </div><div class="line">Error creating bean <span class="keyword">with</span> name <span class="string">'beanA'</span>: </div><div class="line">Requested bean <span class="keyword">is</span> currently <span class="keyword">in</span> creation: </div><div class="line"><span class="keyword">Is</span> there an unresolvable circular <span class="keyword">reference</span>?; </div><div class="line"><span class="keyword">nested</span> exception <span class="keyword">is</span> org.springframework.beans.factory.UnsatisfiedDependencyException: </div><div class="line">Error creating bean <span class="keyword">with</span> name <span class="string">'beanB'</span> defined <span class="keyword">in</span> file [...BeanB.class]: </div><div class="line">Unsatisfied dependency expressed through <span class="function"><span class="keyword">constructor</span> <span class="title">argument</span> <span class="title">with</span> <span class="title">index</span> 0 </span></div><div class="line"><span class="title">of</span> <span class="title">type</span> [<span class="title">org</span>.<span class="title">baeldung</span>.<span class="title">web</span>.<span class="title">IBeanA</span>]: : </div><div class="line">Error creating bean <span class="keyword">with</span> name <span class="string">'beanA'</span>: </div><div class="line">Requested bean <span class="keyword">is</span> currently <span class="keyword">in</span> creation: </div><div class="line"><span class="keyword">Is</span> there an unresolvable circular <span class="keyword">reference</span>?; </div><div class="line"><span class="keyword">nested</span> exception <span class="keyword">is</span> org.springframework.beans.factory.BeanCurrentlyInCreationException: </div><div class="line">Error creating bean <span class="keyword">with</span> name <span class="string">'beanA'</span>: </div><div class="line">Requested bean <span class="keyword">is</span> currently <span class="keyword">in</span> creation: <span class="keyword">Is</span> there an unresolvable circular <span class="keyword">reference</span>?</div></pre></td></tr></table></figure>
<h3 id="7-2-The-org-springframework-beans-factory-BeanIsAbstractException"><a href="#7-2-The-org-springframework-beans-factory-BeanIsAbstractException" class="headerlink" title="7.2. The org.springframework.beans.factory.BeanIsAbstractException"></a>7.2. The org.springframework.beans.factory.BeanIsAbstractException</h3><p>当Bean Factory尝试检索和实例化被声明为抽象的bean时，可能会发生此实例化异常。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanA</span> <span class="keyword">implements</span> <span class="title">IBeanA</span> </span>&#123;</div><div class="line">   ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在XML配置中声明为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"beanA"</span> <span class="keyword">abstract</span>=<span class="string">"true"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.baeldung.web.BeanA"</span> /&gt;</div></pre></td></tr></table></figure>
<p>现在，如果我们尝试通过名称从Spring上下文中检索BeanA，例如实例化另一个bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    BeanFactory beanFactory;</div><div class="line"> </div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> BeanB <span class="title">beanB</span><span class="params">()</span> </span>&#123;</div><div class="line">        beanFactory.getBean(<span class="string">"beanA"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanB();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这将导致以下异常：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">org.springframework.beans.factory.BeanCreationException: </div><div class="line">Error creating bean <span class="keyword">with</span> name <span class="string">'beanB'</span> defined <span class="keyword">in</span> <span class="keyword">class</span> path resource </div><div class="line">[org/baeldung/spring/config/WebConfig.class]: Instantiation <span class="keyword">of</span> bean failed; </div><div class="line"><span class="keyword">nested</span> exception <span class="keyword">is</span> org.springframework.beans.factory.BeanDefinitionStoreException: </div><div class="line">Factory <span class="function"><span class="keyword">method</span> </span></div><div class="line">[<span class="title">public</span> <span class="title">org</span>.<span class="title">baeldung</span>.<span class="title">web</span>.<span class="title">BeanB</span> <span class="title">org</span>.<span class="title">baeldung</span>.<span class="title">spring</span>.<span class="title">config</span>.<span class="title">WebConfig</span>.<span class="title">beanB</span><span class="params">()</span>] <span class="title">threw</span> <span class="title">exception</span>; </div><div class="line"><span class="keyword">nested</span> exception <span class="keyword">is</span> org.springframework.beans.factory.BeanIsAbstractException: </div><div class="line">Error creating bean <span class="keyword">with</span> name <span class="string">'beanA'</span>: Bean definition <span class="keyword">is</span> <span class="keyword">abstract</span></div></pre></td></tr></table></figure>
<h2 id="8-总结-…"><a href="#8-总结-…" class="headerlink" title="8.总结 …"></a><strong>8.总结 …</strong></h2><p>在本文末尾，我们应该有一个清晰的地图来浏览可能导致Spring中的BeanCreationException异常的原因和问题，以及如何解决所有这些问题。</p>
<p>在<a href="https://github.com/eugenp/tutorials/tree/master/spring-all" target="_blank" rel="external">Github</a>项目中可以找到一些这些例外示例的实现<br>这是一个基于Eclipse的项目，所以应该很容易导入和运行。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color2">spring</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/06/13/Spring BeanCreationException/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-初探RxJS" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/26/初探RxJS/">初探RxJS</a>
    </h1>
  

        
        <a href="/2017/05/26/初探RxJS/" class="archive-article-date">
  	<time datetime="2017-05-26T08:31:47.113Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-05-26</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是RxJs"><a href="#什么是RxJs" class="headerlink" title="什么是RxJs"></a>什么是RxJs</h2><p>RxJS是一个JavaScript库，将“反应式编程”的概念带入网络。 反应式编程只是构建软件应用程序的另一种方法。<br>本质上，您的软件是为了对发生的变化进行“反应”（例如点击事件，获取的数据等），而不是典型的编写我们明确编写代码（也称为“命令式”编程）的软件来处理这些更改。<br>对于熟悉的人，您可以将RxJS视为异步数据操作的lodash。 如果你仍然感到困惑，别担心，这通常没有什么意义。让我们用类比来更好地解释一下：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RxJS <span class="keyword">is</span> <span class="keyword">to</span> Javascript <span class="keyword">as</span> Henry Ford<span class="comment">'s assembly line was to cars.</span></div></pre></td></tr></table></figure>
<p>RxJS是为了像亨利·福特的装配线一样用于汽车。</p>
<p>我知道这听起来很棒，但是听到我的声音。 早在二十世纪初，产品完全由手工制造。所以任何产生的产品 - 让我们以座椅为例 - 是由一个人建造的。要做椅子，这个人会把木头切成适当的尺寸。然后，他们将这些块拼合在一起，将粗糙的边缘砂磨。然后他们会画它，完成它，最后卖掉它。然后他们将重复从步骤1的过程。</p>
<p>这可能听起来不是那么糟糕，但是考虑一下：定制颜色的椅子会花多少钱？你会认为这不会太多，对吧？实际上是相反的 - 不仅你会为自己的颜色付钱，而且你必须付钱给那个人整天坐下来，为你创造一个全新的椅子。所以你在宜家买的20美元的椅子可能会花费200美元以上。</p>
<p>为什么？因为这是不被分解成模块化和异步进程的系统的成本。</p>
<p>当亨利·福特（Henry Ford）批量生产第一辆燃烧车的时候，他有一个辉煌的想法：如果你将装配过程分解成由单人负责的模块化件？这样，大会的每一部分都是可以互换的，也消除了一个人负责创造整个汽车的巨大的低效率。事实上，一个人在一个12小时内搭建了一辆满车，他的装配线减少了两个半小时。</p>
<p>这也打开了通常成本高昂的定制和配置级别。例如，如果客户想要汽车的不同颜色的内部，那么他们可以简单地将完成的灯箱重定向到不同的工作人员。</p>
<p>装配线提供了两个主要优点：工人能够异步工作（导致完成所需的总工作时间大大减少），现在重新配置/定制最终产品将是非常便宜的。</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">In</span> this sense, RxJS (<span class="keyword">and</span> reactive programming <span class="keyword">in</span> general) can be thought <span class="keyword">of</span> <span class="keyword">as</span> writing <span class="keyword">assembly</span> lines <span class="keyword">in</span> your software applications. It allows you <span class="keyword">to</span> <span class="keyword">write</span> software that <span class="keyword">is</span> reusable, configurable, <span class="keyword">and</span> asynchronous.</div></pre></td></tr></table></figure>
<p>在这个意义上，RxJS（一般说响应式编程）可以被认为是在您的软件应用程序中编写装配线。它允许您编写可重复使用，可配置和异步的软件。</p>
<p>我认为这里的关键词是异步的。大多数库/框架已经允许您编写可重用且可配置的代码，但可以从异步操作中轻松调用？例如，如果我们正在等待聊天消息从网络套接字回来，新聊天消息如何更新正在运行的应用程序的状态？如果你已经建立了一个有意义的大型实时应用程序，那么你知道写这种逻辑可能是多么痛苦。</p>
<p>虽然websockets和其他实时事件是RxJS真正闪耀的地方，但RxJS还提供了更强大的功能来执行甚至标准的AJAX请求。与promises（解决AJAX请求的正常方法）不同，RxJS的Observable序列是可以取消的。它们也可以轻松链接，操纵和配置。</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">The possibilities are endless. You can <span class="built_in">create</span> assembly <span class="keyword">lines</span> (i.e. RxJS Observables) that can be chained together, <span class="built_in">split</span> apart, configured slightly different, <span class="keyword">or</span> just used <span class="keyword">without</span> <span class="keyword">any</span> modification <span class="keyword">at</span> all. It<span class="string">'s really up to you.</span></div></pre></td></tr></table></figure>
<p>可能性是无止境的。您可以创建可以链接在一起，拆分，配置稍微不同或刚刚使用而不进行任何修改的装配线（即RxJS Observables）。这真的取决于你</p>
<p>就这样说，现在我们来探讨一些真正的RxJS和Observables的例子！</p>
<p>重要的是覆盖RxJS包含的基本术语及其相应的功能，然后再继续实例。在上面的视频中，我们介绍了marble diagrams的可观察序列的总体思路，以及以下主题与之相互作用。</p>
<h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p> 您通常不会直接与Observer对象进行交互，因为您可能会与主题进行交互（我们将在下面介绍），但重要的是要知道它的作用。</p>
<p> 观察者允许您将新数据“推”到可观察的序列中。您可以将其视为修改可观察序列的“只写”方式（要回到我们类似的装配线，观察者只能将新车添加到装配线上）。</p>
<h3 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h3><p> 一个可观察的是我们可以用来听，又名订阅，也就是发现一个观察者发出的新的变化。将其视为“只读”装配线（只能观察新车从装配线中脱落）。</p>
<h3 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h3><p> 主题只是一个观察者和可观察者。您可以推新值并订阅。将其视为“读写”装配线（您可以将车辆添加到装配线上，观察从装配线下车的车辆）。</p>
<h3 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h3><p> RxJS中的运算符的目的与其他编程语言/库中的大多数运算符相同：它们允许您对代码执行操作。</p>
<p> 在RxJS中，您可以将运算符视为在发送到Observable之前操纵来自主题（或观察者）的数据的一种方法。这相当于指示装配线以某种方式修改汽车（即涂漆黑色，闪耀等），然后将其返回到下一个装配线。</p>
<p> 在RxJS中有一些不同类型的主题，但是在构建真实世界应用程序时弹出的最常见的主题是BehaviorSubject。</p>
<p> 假设我们想要存储用户的名字，但是我们也希望他们能够更改它。我们想要存储一个初始名称，有能力更新它，并且还可以在任何给定的时间访问当前的名称设置。</p>
<p> 这正是BehaviorSubject允许你做的事情。让我们看看这个例子的用例实际上是如何工作的：</p>
<p> 使用初始值实例化一个新的BehaviorSubject</p>
<p> 在这个例子中，初始值将是一个字符串（Eric）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> currentNameSubject = <span class="keyword">new</span> BehaviorSubject(<span class="string">'Eric'</span>);</div></pre></td></tr></table></figure>
<p>要获取当前值，请调用getValue方法：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">currentNameSubject.getValue();</div><div class="line"><span class="regexp">//</span> =&gt; <span class="string">'Eric'</span></div></pre></td></tr></table></figure>
<p>要更改现有BehaviorSubject的值，请使用新值调用下一个方法：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">currentNameSubject.<span class="keyword">next</span>(<span class="string">'Obama'</span>);</div></pre></td></tr></table></figure>
<p>如果我们再次调用getValue：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">currentNameSubject.getValue();</div><div class="line"><span class="regexp">//</span> =&gt; <span class="string">'Obama'</span></div></pre></td></tr></table></figure>
<h4 id="订阅值的变动"><a href="#订阅值的变动" class="headerlink" title="订阅值的变动"></a>订阅值的变动</h4><p>使用RxJS的全部要点是跨应用程序异步更新和共享数据。这是通过订阅Observable而不是同步调用getValue完成的：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">let currentNameSubject = <span class="keyword">new</span> BehaviorSubject(<span class="string">'Eric'</span>);</div><div class="line"></div><div class="line">currentNameSubject.subscribe(<span class="function"><span class="params">(val)</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(val);</div><div class="line">&#125;)</div><div class="line"><span class="regexp">//</span> =&gt; <span class="string">'Eric'</span></div><div class="line"></div><div class="line">currentNameSubject.next(<span class="string">'Obama'</span>);</div><div class="line"><span class="regexp">//</span> =&gt; <span class="string">'Obama'</span></div><div class="line"></div><div class="line">currentNameSubject.next(<span class="string">'Jacob'</span>);</div><div class="line"><span class="regexp">//</span> =&gt; <span class="string">'Jacob'</span></div></pre></td></tr></table></figure>
<p>在RxJS世界中，被认为是最佳实践，仅将Subjects暴露给您的应用程序的部分，将新数据添加到Observable序列中。这只是允许对您的应用程序，私人和公共类成员等的某些部分进行写入访问的相同想法。</p>
<p>要从主题创建一个Observable，您可以在任何主题上简单地调用asObservable：</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> currentUserSubject = <span class="keyword">new</span> <span class="type">BehaviorSubject</span>&lt;<span class="built_in">string</span>&gt;(<span class="symbol">'Eric'</span>);</div><div class="line"><span class="keyword">let</span> currentUser = currentUserSubject.asObservable<span class="literal">()</span>;</div></pre></td></tr></table></figure>
<p>我们现在有一个名为currentUser的新变量，它是currentUserSubject的可观察序列的可观察值。要看看它是如何工作的，可以订阅currentUser observable，然后将一些数据添加到currentUserSubject：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let currentUserSubject = <span class="keyword">new</span> BehaviorSubject&lt;string&gt;(<span class="string">'Eric'</span>);</div><div class="line">let currentUser = currentUserSubject.asObservable();</div><div class="line"></div><div class="line">currentUserSubject.subscribe(<span class="function"><span class="params">(val)</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(val)</div><div class="line">&#125;)</div><div class="line"><span class="regexp">//</span> =&gt; <span class="string">'Eric'</span></div><div class="line"></div><div class="line">currentUserSubject.next(<span class="string">'hello'</span>);</div><div class="line"><span class="regexp">//</span> =&gt; <span class="string">'hello'</span></div></pre></td></tr></table></figure>
<p>请注意，如果您尝试调用currentUser.next（），它将抛出一个错误，因为Observables只能观察序列 - 从而为您提供只读访问currentUserSubject</p>
<h3 id="Making-our-first-HTTP-request"><a href="#Making-our-first-HTTP-request" class="headerlink" title="Making our first HTTP request"></a>Making our first HTTP request</h3><p>向API发出请求，使用observable来映射和返回数据</p>
<p>就像Angular 1.x一样，建议Http调用包含在服务中，而不是直接在组件中使用。这可以为您的应用程序结构提供更大的灵活性，因为您可以在整个应用程序中重用您的呼叫，以及实现更高级功能（如缓存）的能力。 要使用Http服务，我们需要（你猜到它）import＆并注入它：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</div><div class="line"><span class="keyword">import</span> &#123; Http, Response &#125; <span class="keyword">from</span> <span class="string">'@angular/http'</span>;</div><div class="line"><span class="keyword">import</span> <span class="string">'rxjs/add/operator/map'</span>;</div><div class="line"></div><div class="line"><span class="meta">@Injectable</span>()</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> UserService &#123;</div><div class="line">  <span class="keyword">constructor</span> (<span class="params"></span></div><div class="line">    <span class="keyword">private</span> http: Http</div><div class="line">  ) &#123;&#125;</div><div class="line"></div><div class="line">  getUser() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.http.get(<span class="string">`https://conduit.productionready.io/api/profiles/eric`</span>)</div><div class="line">    .map(<span class="function">(<span class="params">res:Response</span>) =&gt;</span> res.json());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们需要从rxjs导入map才能使用地图运算符。 $ http从Angular 1.x和Http在Angular 2之间有一些区别。Http返回一个Observable与Response对象，而$ http返回Promises。 Promises和Observables之间的主要区别在于Observables可能会多次发布数据，这就是为什么它们可以被订阅和取消订阅。 $ http和Http之间的另一个主要区别是Http实际上没有向服务器发出请求，直到有一个订阅observable。</p>
<p>虽然可观察是在angular2处理数据的推荐方法，您可以通过导入rxjs / add / operator / toPromise然后调用您的observable的Promise（）将它们转换为promises。起初我发现自己想要使用像Angular 1的好日子这样的承诺，但是我最终发现Observables实际上是相当不错的，与你写承诺代码的方式没有太大的不同。</p>
<p>getUser方法从服务器上关闭对我的配置文件信息的GET请求。当数据回来时，我们使用map操作符来获取响应数据，将其转换为JSON，然后将其重新输入到等待数据解析的任何订阅者。</p>
<p>在home组件中，允许订阅该Observable并将返回给组件中的profile变量的数据分配：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; <span class="type">Component</span> &#125; <span class="keyword">from</span> '@angular/core';</div><div class="line"></div><div class="line"><span class="keyword">import</span> &#123; <span class="type">UserService</span> &#125; <span class="keyword">from</span> './<span class="literal">shared</span>/index';</div><div class="line"></div><div class="line">@<span class="type">Component</span>(&#123;</div><div class="line">  selector: 'home-page',</div><div class="line">  <span class="keyword">template</span>: `</div><div class="line">  &lt;<span class="keyword">div</span>&gt;</div><div class="line">    &lt;button (click)=<span class="string">"loadUser()"</span>&gt;<span class="type">Load</span> profile&lt;/button&gt;</div><div class="line">    &#123;&#123; profile | json &#125;&#125;</div><div class="line">  &lt;/<span class="keyword">div</span>&gt;</div><div class="line">  `</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> class <span class="type">HomeComponent</span> &#123;</div><div class="line">  constructor(private userService: <span class="type">UserService</span>) &#123;&#125;</div><div class="line">  profile = &#123;&#125;;</div><div class="line"></div><div class="line">  loadUser() &#123;</div><div class="line">    this.userService.getUser().subscribe(data =&gt; this.profile = data);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">Rxjs</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/05/26/初探RxJS/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-陌生单词笔记本" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/23/陌生单词笔记本/">陌生单词笔记本</a>
    </h1>
  

        
        <a href="/2017/05/23/陌生单词笔记本/" class="archive-article-date">
  	<time datetime="2017-05-23T03:09:38.984Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-05-23</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> Robust  强大的<br> definitive 确定的<br> security landscape（风景，风景，山水） 安全形势<br> two-factor authentication 双因素认证<br> solid 坚实<br> alternative  可以供选择的<br> debate 争论<br> intelligently   智能的<br> properly  正确的<br> tactics  策略、<br> fluent 连贯<br> endpoint 端点<br> enforce 实施 强制 执行<br> encapsulate 封装<br> interchangeable 可交换的<br> Strategy 策略<br> vary 变化<br> DelegatingFilterProxy 委托过滤代理<br> hierarchies 阶层; 层次; 层次结构<br> outlines  概述<br> application 应用程式 应用、应用程序<br>application framework 应用程式框架、应用框架 应用程序框架architecture 架构、系统架构 体系结构<br>argument 参数（传给函式的值）。<br>array 阵列 数组<br>arrow operator arrow（箭头）运算子 箭头操作符<br>assembly 装配件<br>assembly language 组合语言 汇编语言<br>assert(ion) 断言<br>assign 指派、指定、设值、赋值 赋值<br>assignment 指派、指定 赋值、分配<br>assignment operator 指派（赋值）运算子 = 赋值操作符<br>associated 相应的、相关的 相关的、关联、相应的<br>associative container 关联式容器（对应 sequential container）关联式容器<br>atomic 不可分割的 原子的<br>attribute 属性 属性、特性<br>audio 音讯 音频<br>A.I. 人工智慧 人工智能</p>
<p>background 背景 背景（用於图形着色）後台（用於行程）<br>backward compatible 回溯相容 向下兼容<br>bandwidth 频宽 带宽<br>base class 基础类别 基类<br>base type 基础型别 (等同於<br>base class) batch 批次（意思是整批作业） 批处理<br>benefit 利益 收益<br>best viable function 最佳可行函式 最佳可行函式<br>binary search 二分搜寻法 二分查找<br>binary tree 二元树 二叉树<br>binary function 二元函式 双叁函数<br>binary operator 二元运算子 二元操作符<br>binding 系结 绑定<br>bit 位元 位<br>bit field 位元栏 位域<br>bitmap 位元图 位图<br>bitwise 以 bit 为单元逐一<br>bitwise copy 以 bit 为单元进行复制；位元逐一复制 位拷贝<br>block 区块,区段 块、区块、语句块<br>boolean 布林值（真假值，true 或 false）布尔值<br>border 边框、框线 边框<br>brace(curly brace) 大括弧、大括号 花括弧、花括号<br>bracket(square brakcet) 中括弧、中括号 方括弧、方括号<br>breakpoint 中断点 断点<br>build 建造、构筑、建置（MS 用语）<br>build－in 内建 内置<br>bus 汇流排 总线<br>business 商务,业务 业务<br>buttons 按钮 按钮<br>byte 位元组（由 8 bits 组成） 字节</p>
<p>cache 快取 高速缓存<br>call 呼叫、叫用 调用<br>callback 回呼 回调<br>call operator call（函式呼叫）运算子调用操作符<br>candidate function 候选函式 候选函数<br>chain 串链（例 chain of function calls） 链<br>character 字元 字符<br>check box 核取方块 (i.e. check button) 复选框<br>checked exception 可控式异常<br>check button 方钮 (i.e. check box) 复选按钮<br>child class 子类别（或称为derived class, subtype） 子类<br>class 类别 类<br>class body 类别本体 类体<br>class declaration 类别宣告、类别宣告式 类声明<br>class definition 类别定义、类别定义式 类定义<br>class derivation list 类别衍化列 类继承列表<br>class head 类别表头 类头<br>class hierarchy 类别继承体系, 类别阶层 类层次体系<br>class library 类别程式库、类别库 类库<br>class template 类别模板、类别范本 类模板<br>class template partial specializations 类别模板偏特化 类模板部分特化<br>class template specializations 类别模板特化 类模板特化<br>cleanup 清理、善後 清理、清除<br>client 客端、客户端、客户 客户<br>client－server 主从架构 客户/服务器<br>clipboard 剪贴簿 剪贴板<br>clone 复制 克隆<br>collection 群集 集合<br>combo box 复合方块、复合框 组合框<br>command line 命令列 命令行(系统文字模式下的整行执行命令)<br>communication 通讯 通讯<br>compatible 相容 兼容<br>compile time 编译期 编译期、编译时<br>compiler 编译器 编译器<br>component 组件 组件<br>composition 复合、合成、组合 组合<br>computer 电脑、计算机 计算机、电脑<br>concept 概念 概念<br>concrete 具象的 实在的<br>concurrent 并行 并发<br>configuration 组态 配置<br>connection 连接，连线（网络,资料库） 连接<br>constraint 约束（条件）<br>construct 构件 构件<br>container 容器 容器(存放资料的某种结构如 list, vector…）<br>containment 内含 包容<br>context 背景关系、周遭环境、上下脉络 环境、上下文<br>control 控制元件、控件 控件<br>console 主控台 控制台<br>const常数（constant 的缩写，C++ 关键字）<br>constant 常数（相对於 variable） 常量<br>constructor（ctor） 建构式 构造函数（与class 同名的一种 member functions）<br>copy (v) 复制、拷贝 拷贝<br>copy (n) 复件, 副本<br>cover 涵盖 覆盖<br>create 创建、建立、产生、生成 创建<br>creation 产生、生成 创建<br>cursor 游标 光标<br>custom 订制、自定 定制</p>
<p>data 资料 数据<br>database 资料库 数据库<br>database schema 数据库结构纲目<br>data member 资料成员、成员变数 数据成员、成员变量<br>data structure 资料结构 数据结构<br>datagram 资料元 数据报文<br>dead lock 死结 死锁<br>debug 除错 调试<br>debugger 除错器 调试器<br>declaration 宣告、宣告式 声明<br>deduction 推导（例：template argument deduction） 推导、推断<br>default 预设 缺省、默认<br>defer 延缓 推迟<br>define 定义 预定义<br>definition 定义、定义区、定义式 定义<br>delegate 委派、委托、代理<br>delegation （同上）<br>demarshal 反编列 散集<br>dereference 提领（取出指标所指物体的内容） 解叁考<br>dereference operator dereference（提领）运算子 * 解叁考操作符<br>derived class 衍生类别 派生类<br>design by contract 契约式设计<br>design pattern 设计范式、设计样式 设计模式<br>destroy 摧毁、销毁<br>destructor 解构式 析构函数<br>device 装置、设备 设备<br>dialog 对话窗、对话盒 对话框<br>directive 指令（例：using directive） (编译)指示符<br>directory 目录 目录<br>disk 碟 盘<br>dispatch 分派 分派<br>distributed computing 分布式计算 (分布式电算) 分布式计算 分散式计算 (分散式电算)<br>document 文件 文档<br>dot operator dot（句点）运算子 . (圆)点操作符<br>driver 驱动程式 驱动（程序）<br>dynamic binding 动态系结 动态绑定</p>
<p>efficiency 效率 效率<br>efficient 高效 高效<br>end user 终端用户<br>entity 物体 实体、物体<br>encapsulation 封装 封装<br>enclosing class外围类别（与巢状类别 nested class 有关）外围类<br>enum (enumeration) 列举（一种 C++ 资料型别） 枚举<br>enumerators 列举元（enum 型别中的成员） 枚举成员、枚举器<br>equal 相等 相等<br>equality 相等性 相等性<br>equality operator equality（等号）运算子 == 等号操作符<br>equivalence 等价性、等同性、对等性 等价性<br>equivalent 等价、等同、对等 等价<br>escape code 转义码 转义码<br>evaluate 评估、求值、核定 评估<br>event 事件 事件<br>event driven 事件驱动的 事件驱动的<br>exception 异常情况 异常<br>exception declaration 异常宣告（ref. C++ Primer 3/e, 11.3）异常声明<br>exception handling 异常处理、异常处理机制 异常处理、异常处理机制<br>exception specification 异常规格（ref. C++ Primer 3/e, 11.4）异常规范<br>exit 退离（指离开函式时的那一个执行点） 退出<br>explicit 明白的、明显的、显式 显式<br>export 汇出 引出、导出</p>
<p>facility 设施、设备 设施、设备<br>feature 特性<br>field 栏位,资料栏（Java） 字段, 值域（Java）<br>file 档案 文件<br>firmware 韧体 固件<br>flag 旗标 标记<br>flash memory 快闪记忆体 闪存<br>flexibility 弹性 灵活性<br>flush 清理、扫清 刷新<br>font 字型 字体<br>form 表单（programming 用语） 窗体<br>formal parameter形式叁数 形式叁数<br>forward declaration 前置宣告 前置声明<br>forwarding 转呼叫,转发 转发<br>forwarding function 转呼叫函式,转发函式 转发函数<br>fractal 碎形 分形<br>framework 框架 框架<br>full specialization 全特化（ref. partial specialization）<br>function 函式、函数 函数<br>function call operator 同<br>call operator function object 函式物件（ref. C++ Primer 3/e, 12.3） 函数对象<br>function overloaded resolution 函式多载决议程序 函数重载解决（方案）<br>functionality 功能、机能 功能<br>function template 函式模板、函式范本 函数模板<br>functor 仿函式 仿函式、函子</p>
<p>game 游戏 游戏<br>generate 生成<br>generic 泛型、一般化的 一般化的、通用的、泛化<br>generic algorithm 泛型演算法 通用算法<br>getter (相对於 setter) 取值函式<br>global 全域的（对应於 local） 全局的<br>global object 全域物件 全局对象<br>global scope resolution operator 全域生存空间（范围决议）运算子 :: 全局范围解析操作符<br>group 群组<br>group box 群组方块 分组框<br>guard clause 卫述句 (Refactoring, p250) 卫语句<br>GUI 图形介面 图形界面</p>
<p>hand shaking 握手协商<br>handle 识别码、识别号、号码牌、权柄 句柄<br>handler 处理常式 处理函数<br>hard－coded 编死的 硬编码的<br>hard－copy 硬拷图 屏幕截图<br>hard disk硬碟 硬盘<br>hardware 硬体 硬件<br>hash table 杂凑表 哈希表、散列表<br>header file 表头档、标头档 头文件<br>heap 堆积 堆<br>hierarchy 阶层体系 层次结构（体系）<br>hook 挂钩 钩子<br>hyperlink 超链结 超链接</p>
<p>icon 图示、图标 图标<br>IDE 整合开发环境 集成开发环境<br>identifier 识别字、识别符号 标识符<br>if and only if 若且唯若 当且仅当<br>Illinois 伊利诺 伊利诺斯<br>image 影像 图象<br>immediate base 直接的（紧临的）上层 base class。 直接上层基类<br>immediate derived 直接的（紧临的）下层 derived class。 直接下层派生类<br>immutability 不变性<br>immutable 不可变（的）<br>implement 实作、实现 实现<br>implementation 实作品、实作体、实作码、实件 实现<br>implicit 隐喻的、暗自的、隐式 隐式<br>import 汇入 导入<br>increment operator 累加运算子 ++ 增加操作符<br>infinite loop 无穷回圈 无限循环<br>infinite recursive 无穷递回 无限递归<br>information 资讯 信息<br>infrastructure 公共基础建设<br>inheritance 继承、继承机制 继承、继承机制<br>inline 行内 内联<br>inline expansion 行内展开 内联展开<br>initialization 初始化（动作） 初始化<br>initialization list 初值列 初始值列表<br>initialize 初始化 初始化<br>inner class 内隐类别 内嵌类<br>instance 实体 实例（根据某种表述而实际产生的「东西」）<br>instantiated 具现化、实体化（常应用於 template） 实例化<br>instantiation 具现体、具现化实体（常应用於 template） 实例<br>integer (integral) 整数（的） 整型（的）<br>integrate 整合 集成<br>interacts 交谈、互动 交互<br>interface 介面 接口<br>interpreter 直译器 解释器<br>invariants 恒常性,约束条件 约束条件<br>invoke 唤起 调用<br>iterate迭代（回圈一个轮回一个轮回地进行） 迭代<br>iterative 反覆的，迭代的<br>iterator 迭代器（一种泛型指标） 迭代器<br>iteration 迭代（回圈每次轮回称为一个 iteration） 迭代<br>item 项目、条款 项、条款、项目<br>laser 雷射 激光<br>level 阶 层 (级) 例 high level 高阶 高层<br>library 程式库、函式库 库、函数库<br>lifetime 生命期、寿命 生命期、寿命<br>link 联结、连结 连接,链接<br>linker 联结器、连结器 连接器<br>literal constant 字面常数（例 3.14 或 “hi” 这等常数值） 字面常数<br>list 串列（linked－list） 列表、表、链表<br>list box 列表方块、列表框 列表框</p>
<p>load 载入 装载<br>loader 载入器 装载器、载入器<br>local 区域的（对应於 global） 局部的<br>local object 区域物件 局部对象<br>lock 机锁<br>loop 回圈 循环<br>lvalue 左值 左值</p>
<p>macro 巨集 宏<br>magic number 魔术数字 魔法数<br>maintain 维护 维护<br>manipulator 操纵器（iostream 预先定义的一种东西） 操纵器<br>marshal 编列 列集叁考<br>demarshal mechanism 机制 机制<br>member 成员 成员<br>member access operator 成员取用运算子（有 dot 和 arrow 两种） 成员存取操作符<br>member function 成员函式 成员函数<br>member initialization list 成员初值列 成员初始值列表<br>memberwise 以 member 为单元┅、members 逐一┅ 以成员为单位<br>memberwise copy 以 members 为单元逐一复制<br>memory 记忆体 内存<br>menu 表单、选单 菜单<br>message 讯息 消息<br>message based 以讯息为基础的 基於消息的<br>message loop 讯息回圈 消息环<br>method 方法、行为、函式 方法<br>meta－ 超－ 元－<br>meta－programming 超编程 元编程<br>micro 微 微<br>middleware 中介层 中间件<br>modeling 模塑<br>modeling language 塑模语言，建模语言<br>modem 数据机 调制解调器<br>module 模组 模块<br>modifier 饰词 修饰符<br>most derived class 最末层衍生类别 最底层的派生类<br>mouse 滑鼠 鼠标<br>mutable可变的 可变的<br>multi－tasking 多工 多任务</p>
<p>namespace 命名空间 名字空间、命名空间<br>native 原生的 本地的、固有的<br>nested class 巢状类别 嵌套类<br>network 网路 网络<br>network card 网路卡 网卡</p>
<p>object 物件 对象<br>object based 以物件为基础的 基於对象的<br>object file 目的档 目标文件<br>object model 物件模型 对象模型<br>object oriented 物件导向的 面向对象的<br>online 线上 在线<br>opaque 不透明的<br>operand 运算元 操作数<br>operating system (OS) 作业系统 操作系统<br>operation 操作、操作行为 操作<br>operator 运算子 操作符、运算符<br>option 选项，可选方案 选项<br>ordinary 常规的 常规的<br>overflow 上限溢位（相对於 underflow） 溢出（underflow:下溢）<br>overhead 额外负担、额外开销 额外开销<br>overload 多载化、多载化、重载 重载<br>overloaded function 多载化函式 重载的函数<br>overloaded operator 多载化运算子 被重载的操作符<br>overloaded set 多载集合 重载集合<br>override 改写、覆写 重载、改写、重新定义（在 derived class 中重新定义虚拟函式)</p>
<p>package 套件 包<br>pair 对组<br>palette 调色盘、组件盘、工具箱<br>pane 窗格 窗格<br>parallel 平行 并行<br>parameter 叁数（函式叁数列上的变数） 叁数、形式叁数、形叁<br>parameter list 叁数列 叁数列表<br>parent class 父类别（或称 base class） 父类<br>parentheses 小括弧、小括号 圆括弧、圆括号<br>parse 解析 解析<br>part 零件 部件<br>partial specialization 偏特化（ref. C++ Primer 3/e, 16.10）局部特化<br>pass by address 传址（函式引数的传递方式）（非正式用语）传地址<br>pass by reference 传址（函式引数的一种传递方式） 传地址, 按引用传递<br>pass by value 传值（函式引数的一种传递方式） 按值传递<br>pattern 范式、样式 模式<br>performance 效率、性能兼而有之 性能<br>persistence 永续性 持久性<br>pixel 图素、像素 像素<br>platform 平台 平台<br>pointer 指标 指针址位器（和址叁器 reference 形成对映，满好）<br>poll 轮询 轮询<br>polymorphism 多型 多态<br>pop up 冒起式、弹出式 弹出式<br>port 埠 端口<br>postfix 後置式、後序式 後置式<br>precedence 优先序（通常用於运算子的优先执行次序）<br>prefix 前置式、前序式 前置式<br>preprocessor 前处理器 预处理器<br>prime 质数 素数<br>primitive type 基本型别 (不同於 base class,基础类别)<br>print 列印 打印<br>printer 印表机 打印机<br>priority 优先权 (通常用於执行绪获得 CPU 时间的优先次序）<br>procedure 程序 过程<br>procedural 程序性的、程序式的 过程式的、过程化的<br>process 行程 进程<br>profile 评测 评测<br>profiler 效能（效率）评测器 效能（性能）评测器<br>programmer 程式员 程序员<br>programming 编程、程式设计、程式化 编程<br>progress bar 进度指示器 进度指示器<br>project 专案 项目、工程<br>property 属性<br>protocol 协定 协议<br>pseudo code 假码、虚拟码、伪码 伪码</p>
<p>qualified 经过资格修饰（例如加上 scope 运算子） 限定<br>qualifier 资格修饰词、饰词 限定修饰词<br>quality 品质 质量<br>queue 伫列 队列</p>
<p>radian 径度 弧度<br>radio button 圆钮 单选按钮<br>raise 引发（常用来表示发出一个 exception） 引起、引发<br>random number 随机数、乱数 随机数<br>range 范围、区间（用於 STL 时） 范围、区间<br>rank 等级、分等（ref. C++Primer 3/e 9,15章） 等级<br>raw 生鲜的、未经处理的 未经处理的<br>record 记录 记录<br>recordset 记录集 记录集<br>recursive 递回 递归<br>re－direction 重导向 重定向<br>refactoring 重构、重整 重构<br>refer 取用 叁考<br>refer to 指向、指涉、指代<br>reference 引用、叁考 址叁器,<br>see pointer register 暂存器 寄存器<br>reflection 反射 反射、映像<br>relational database 关联式资料库 关系数据库<br>represent 表述，表现 表述，表现<br>resolve 决议（为算式中的符号名称寻找 解析对应之宣告式的过程）<br>resolution 决议程序、决议过程 解析过程<br>resolution 解析度 分辨率<br>restriction 局限<br>return 传回、回返 返回<br>return type 回返型别 返回类型<br>return value 回返值 返回值<br>robust 强固、稳健 健壮<br>robustness 强固性、稳健性 健壮性<br>routine 常式 例程<br>runtime 执行期 运行期、运行时<br>common language runtime (CLR) 译为「通用语言执行层」<br>rvalue 右值 右值</p>
<p>save 保存<br>savepoint 保存点<br>SAX (Simple API for XML)scalable 可伸缩的、可扩展的<br>schedule 调度<br>scheduler 调度程序<br>schema 模式、纲目结构<br>scroll bar 滚动条<br>scope 作用域、生存空间<br>scope operator 生存空间操作符<br>scope resolution operator 生存空间解析操作符<br>screen 屏幕<br>SDK (Software Development Kit) 软件开发包<br>sealed class 密封类<br>search 查找<br>semantics 语义<br>semaphore 信号量<br>sequential container序列式容器<br>server 服务器、服务端<br>serial 串行<br>serialization/serialize 序列化<br>server cursor 服务端游标、服务器游标<br>session 会话<br>setter 设值函数<br>shared lock 共享锁<br>sibling 同级<br>side effect 副作用<br>signature 签名<br>single-threaded 单线程<br>slider 滑块<br>slot 槽<br>smart pointer 智能指针<br>SMTP (Simple Mail Transfer Protocol) 简单邮件传输协议<br>snapshot 截屏图<br>snapshot 快照<br>specialization 特化<br>specification 规范、规格<br>splitter 切分窗口<br>SOAP (simple object access protocol) 简单对象访问协议<br>software 软件<br>source code 源码、源代码<br>SQL (Structured Query Language) 结构化查询语言<br>stack 栈、堆栈<br>stack unwinding 叠辗转开解(此词用于exception主题)<br>standard library 标准库<br>standard template library 标准模板库<br>stateless 无状态的<br>statement 语句、声明<br>static cursor 静态游标<br>static SQL statements 静态SQL语句<br>stored procedure 存储过程<br>status bar 状态条<br>stream 流<br>string 字符串<br>stub 存根<br>subobject 子对象<br>subquery 子查询<br>subroutine 子例程<br>subscript operator 下标操作符<br>subset 子集<br>subtype 子类型<br>support 支持<br>suspend 挂起<br>symbol 记号<br>syntax 语法<br>system databases 系统数据库<br>system tables 系统表</p>
<p>tag标签 标记 索引标签,页签<br>target 标的（例 target pointer：标的指标） 目标<br>task switch 工作切换 任务切换<br>template 模板、范本 模板<br>template argument deduction 模板引数推导 模板叁数推导<br>template explicit specialization 模板显式特化（版本） 模板显式特化<br>template parameter 模板叁数 模板叁数<br>temporary object 暂时物件 临时对象<br>text文字 文本<br>text file 程式本文档（放置程式原始码的档案） 文本文件<br>thread 执行绪 线程<br>thread safe 多绪安全 多线程安全<br>throw 丢掷（常指发出一个 exception） 丢掷、引发<br>token 语汇单元 符号、标记<br>transaction 交易 事务<br>transaction log 事务日志<br>transaction rollback 事务回滚<br>transactional replication 事务复制<br>translation unit 翻译单元<br>transparent(ly) 透通的(地)<br>traverse 巡访（来回走动） 遍历<br>trigger 触发 触发<br>type 型别 类型<br>table 表<br>table lock 表锁<br>table-level constraint 表级约束<br>tape backup 磁带备份<br>task switch 工作切换<br>TCP (Transport Control Protocol) 传输控制协议<br>temporary table 临时表<br>thin client 瘦客户端<br>third-party 第三方<br>trace 跟踪<br>traverse 遍历<br>two-phase commit 两阶段提交<br>tupletwo-phase lookup 两阶段查找</p>
<p>UML unified modeling language 统一建模语言<br>unary function 一元函式 单叁函数<br>unary operator 一元运算子 一元操作符<br>underflow 下限溢位（相对於 overflow） 下溢<br>unchecked exception 不可控异常<br>unqualified 未经资格修饰（而直接取用）<br>user 使用者、用户 用户<br>user interface 使用者界面、用户界面、人机界面<br>UDDI(Universary Description, Discovery and Integration)统一描述、查询与集成<br>unboxing 拆箱、拆箱转换<br>Union query 联合查询<br>UNIQUE constraints UNIQUE约束<br>unique index 唯一索引<br>unmanaged code 非受控代码、非托管代码<br>unmarshal 散集<br>unqualified 未经限定的、未经修饰的<br>URI (Uniform Resource identifier) 统一资源标识符<br>URL (Uniform Resource Locator) 统一资源定位器</p>
<p>variable 变数（相对於常数 const） 变量<br>vector 向量（一种容器，有点类似 array） 向量、矢量<br>viable 可实行的、可行的 可行的<br>viable function 可行函式 可行函数<br>video 视讯 视频<br>view (1) 视图<br>(document/view) 文档/视图<br>virtual function 虚拟函式 虚函数<br>virtual machine 虚拟机器 虚拟机<br>virtual memory虚拟记忆体 虚内存, 虚存<br>volatile 易挥发的、易变的<br>vowel 母音 元音字母</p>
<p>window 视窗 窗口<br>window function 视窗函式 窗口函数<br>window procedure 视窗函式 窗口过程<br>word 字 单词<br>word processor 文书处理器 字处理器<br>wrapper 外覆、外包 包装<br>Web Services web 服务<br>WHERE clause WHERE子句<br>wildcard characters 通配符字符<br>wildcard search 通配符搜索<br>Windows authentication Windows 身份验证<br>wizard 向导<br>write enable 写启用<br>write-ahead log 预写日志<br>write-only 只写<br>WSDL (Web Service Description Language)Web Service 描述语言</p>
<p>XML (eXtensible Markup Language) 可扩展标记语言<br>XSD (XML Schema Definition)  XML 模式定义语言<br>XSL (eXtensible Stylesheet Language) 可扩展样式表语言<br>XSLT (eXtensible Stylesheet Language Transformation)可扩展样式表语言转换<br>xxx based 基于xxx的<br>xxx oriented 面向xxxXML (eXtensible Markup Language) 可扩展标记语言</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">english learn</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/05/23/陌生单词笔记本/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-设计模式" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/20/设计模式/">设计模式</a>
    </h1>
  

        
        <a href="/2017/05/20/设计模式/" class="archive-article-date">
  	<time datetime="2017-05-20T03:42:48.025Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-05-20</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="设计模式总结"><a href="#设计模式总结" class="headerlink" title="设计模式总结"></a>设计模式总结</h1><h2 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h2><p>设计模式是从许多优秀的软件系统中总觉出成功的可复用的设计方案。</p>
<p>每一个设计模式描述一个在我们周围不断重复发生的问题，以及该为题的解决方案的核心，这样，你就可以一次一次的使用该方案而不必做重复的劳动。 by – Alexander  建筑大师</p>
<p>尽管Alwxander 所指的是城市和建筑的设计模式，但他的思想也同样适用于面向对象设计模式，只是在面向对象的解决方案里，我们用对象和接口代替了墙壁和门窗。</p>
<p>记录一个设计模式需有四个基本的要素：</p>
<ol>
<li>名称</li>
<li>问题</li>
<li>方案</li>
<li>效果</li>
</ol>
<p>例如: 中介者模式：</p>
<ol>
<li>名称 中介者</li>
<li>问题 用一个中介者来封装一系列的对象交互，中介者使各种对象不需要显示的相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互。</li>
<li>方案 中介者（Mediator） 接口，具体中介者（Concerte Mediator），同事（Colleague），具体同事（Concrete Colleagure）</li>
<li>效果 减少了子类的生成，将各个同事解耦，简化了对象的协议，控制集中化。</li>
</ol>
<p> 软件领域的设计模式起源于建筑学，一个好的设计系统往往是易维护，易扩展，易复用的。</p>
<h3 id="什么是框架"><a href="#什么是框架" class="headerlink" title="什么是框架"></a>什么是框架</h3><p> 框架不是模式，框架是针对某个领域，提供用于开发应用系统的类的集合，程序设计者可以使用框架提供的类设计一个应用程序，而且在设计应用程序时可以针对特定的问题使用某个模式。</p>
<h3 id="面向对象的几个基本的原则"><a href="#面向对象的几个基本的原则" class="headerlink" title="面向对象的几个基本的原则"></a>面向对象的几个基本的原则</h3><ol>
<li>抽象类和接口</li>
<li>面向抽象<br>所谓面向抽象编程，是指当设计一个类时，不让该类面向具体的类，而是面向抽象类或者接口，即所设计类中的重要数据是抽象类或接口声明的变量，而不是具体类声明的变量。<br>3.开闭原则<br>让设计对扩展开放，对修改关闭。<br>4.多用组合少用继承原则<br>5.高内聚-低耦合原则</li>
</ol>
<p>在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。这个术语是由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学的。</p>
<p> 设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案。</p>
<p> <strong>面向对象设计模式通常以类或对象来描述其中的关系和相互作用，但不涉及用来完成应用程序的特定类或对象。设计模式能使不稳定依赖于相对稳定、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力。</strong></p>
<p>并非所有的软件模式都是设计模式，设计模式特指软件“设计”层次上的问题。还有其它非设计模式的模式，如架构模式。同时，算法不能算是一种设计模式，因为算法主要是用来解决计算上的问题，而非设计上的问题。</p>
<p>肯特·贝克和沃德·坎宁安在1987年，利用克里斯托佛·亚历山大在建筑设计领域里的思想开发了设计模式并把此思想应用在Smalltalk中的图形用户接口（GUI）的生成中。一年后埃里希·伽玛在他的苏黎世大学博士毕业论文中开始尝试把这种思想改写为适用于软件开发。与此同时James Coplien 在1989年至1991年也在利用相同的思想致力于C++的开发，而后于1991年发表了他的著作Advanced C++ Programming Styles and Idioms。同年Erich Gamma 得到了博士学位，然后去了美国，在那与Richard Helm, Ralph Johnson ,John Vlissides 合作出版了《设计模式：可复用面向对象软件的基础》（Design Patterns - Elements of Reusable Object-Oriented Software） 一书，在此书中共收录了23个设计模式。</p>
<p>这四位作者在软件开发领域里以“四人帮”（英语，Gang of Four，简称GoF）而闻名，并且他们在此书中的协作导致了软件设计模式的突破。有时，GoF也会用于代指《设计模式》这本书。</p>
<p><strong>《设计模式》一书原先把设计模式分为创建型模式、结构型模式、行为型模式，把它们通过授权、聚合、诊断的概念来描述。若想更进一步了解关于面向对象设计的背景，参考接口模式、内聚。若想更进一步了解关于面向对象编程的背景，参考继承，接口，多态。</strong></p>
<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><h2 id="活字印刷-面向对象"><a href="#活字印刷-面向对象" class="headerlink" title="活字印刷 面向对象"></a>活字印刷 面向对象</h2><p>话说三国时期，曹操带领百万大军攻打东吴，大军在长江赤壁驻扎，军船连成一片，眼看就要灭掉东吴，统一天下，曹操大悦，于是大宴众文武，在酒席间，曹操诗兴大发，不觉吟道：喝酒唱歌，人生真爽。众文武齐呼：“丞相好诗！于是一臣子速命印刷工匠刻板印刷，以便流传天下。”</p>
<p>样张出来给曹操一看，曹操感觉不妥，说到：“喝与唱，此话过俗，应该为‘对酒当歌’较好！”，于是此臣就命工匠重新来过。工匠眼看连夜刻板之工，彻底白费，心中叫苦不迭。只得照办。”</p>
<p>样张再次出来请曹操过目，曹操细细一品，感觉还是不好，说：“人生真爽太过直接，应改问语才够意境，因此应改为‘对酒当歌，人生几何？’当臣子转告工匠之时，工匠晕倒！”</p>
<p>为何三国时期的工匠有如此的问题？</p>
<p>当时活字印刷还未发明，所以要改字的时候必须要整个刻板重刻。如果有活字印刷，则只需更改四个字就可，其余工作都未白做，岂不妙哉。</p>
<ul>
<li>要改，只需要更改之字，此为可维护。</li>
<li>这写字并非用完这次就无用，完全可以在后来的印刷中重复使用，此乃可复用。</li>
<li>此诗若要加字，只需另刻字加入即可，这是可扩展。</li>
<li>字的排列其实可能是竖排也可能是横排，此时只需要将活字移动就可以做到满足排列需求，此是灵活性好</li>
</ul>
<p>面对对象的分析设计编程思想，通过封装，继承多态把程序的耦合度降低，传统印刷术的问题就在于所有的字都刻在同一版面上造成耦合度太高所致，开始用设计模式使得程序更加灵活，易于修改，易于复用。</p>
<h2 id="简单工厂模式-1"><a href="#简单工厂模式-1" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>例：计算器，到底要实例化谁，将来会不会增加实例化的对象，把很容易变化的地方用一个单独的类来做这个创造实例的过程，这个就是工厂。<br>简单的运算工厂类</p>
<pre><code>public class OperationFactory
{
    public static operation createOperate(string operate)
    {
    Operation oper = null;
    switch (operate)
    {
        case &quot;+&quot;:
            oper = new OperationAdd();
            break;
        case &quot;-&quot;:
            oper = new OperationSub();
            break;
        case &quot;*&quot;:
            oper = new OperationMul();
            break;
        case &quot;/&quot;:
            oper = new OperationDiv();
            break;
    }
    return oper;
    }
}
</code></pre><p>客户端代码</p>
<pre><code>Operation oper;
oper = OperationFactory.createOperate(&quot;+&quot;);
oper.NumberA = 1;
oper.NumberB = 2;
double result = oper.GetResult();
</code></pre><p>这样，以后需要增加各种复杂运算，比如平方根，立方根，自然对数等等，只要增加相对应的运算子类就可以了。</p>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="一个商场收银软件，营业员根据客户所购买的商品的单价和数量，向客户收费"><a href="#一个商场收银软件，营业员根据客户所购买的商品的单价和数量，向客户收费" class="headerlink" title="一个商场收银软件，营业员根据客户所购买的商品的单价和数量，向客户收费"></a>一个商场收银软件，营业员根据客户所购买的商品的单价和数量，向客户收费</h3><p>用两个文本框来输入单价和数量，一个确定按钮来算出每种商品的费用，用个列表框来记录商品的清单，一个标签来记录总计，一个重置按钮来重新开始。</p>
<pre><code>double total = 0.0d;
private void btn0k_Click(object sender, EventArgs e)
{
    double totalPrices = Convert.ToDouble(txtPrice.Text) * Convert.ToDouble(txtNum.Text);
    total = total + totalPrices;
    IbxList.Items.Add(&quot;单价：&quot; +txtPrice.Text + &quot;数量：&quot; ＋ txtNum.Text + &quot;合计：&quot;+ totalPrices.ToString());
    IblResult.Text = total.ToString();
}
</code></pre><h3 id="比如遇到节假日-增加打折"><a href="#比如遇到节假日-增加打折" class="headerlink" title="比如遇到节假日 增加打折"></a>比如遇到节假日 增加打折</h3><pre><code>double total = 0.0d;

private void Form_Load(object sender, EventArgs e)
{
    cbxType.Items.AddRange(new object[] {&quot;正常收费&quot;,&quot;打八折&quot;,&quot;打五折&quot;});
    cbxType.SlectedIndex = 0;
}

private void btn0k_Click(object sender, EventArgs e)
{
double totalPrices = 0.0d;
switch(cbxType.Selectedindex)
{
    case 0:
             totalPrices = Convert.ToDouble(txtPrice.Text) * Convert.ToDouble(txtNum.Text);
    case 1:
             totalPrices = Convert.ToDouble(txtPrice.Text) * Convert.ToDouble(txtNum.Text)*0.8;
    case 2:
             totalPrices = Convert.ToDouble(txtPrice.Text) * Convert.ToDouble(txtNum.Text)*0.5;
}
   total = total + totalPrices;
    IbxList.Items.Add(&quot;单价：&quot; +txtPrice.Text + &quot;数量：&quot; ＋ txtNum.Text + &quot;合计：&quot;+ totalPrices.ToString());
    IblResult.Text = total.ToString();
}
</code></pre><h2 id="简单工厂实现"><a href="#简单工厂实现" class="headerlink" title="简单工厂实现"></a>简单工厂实现</h2><p>面对对象的编程，并不是类越多越好，类的划分是为了封装，但是分装的基础是抽象，具有相同属性和功能的对象的抽象集合才是类。打一折和打九折只是形式的不同，抽象分析出来，所有的打折算法都是一样的，所以打折算法应该是一个类。</p>
<pre><code>//现金收费抽象类
abstract class CashSuper
{
    public abstract double acceptCash(double money);
}

//正常收费子类
class CashNormal: CashSuper
{
    public override double acceptCash(double money)
    {
        return money;
    }
}

//打折收费子类
class CashRebate: CashSuper
{
    private double moneyRebate = 1d;
    public Cash Rebebate(string moneyRebate)
    {
        this.moneyRebate = double.Parse(moneyRebate);
    }
    publci override double acceptCash(double money)
    {
        return money * moneyRebate;
    }
}

//返利收费子类
class cashReturn: CashSuper
{
    private double moneyCondition = 0.0d;
    private double moneyreturn = 0.0d;
    public CashReturn(string moneyCondition, string moneyReturn)
    {
        this.moneyCondition = double.Parse(moneyCondtion);
        this.moneyReturn = double.Parse(moneyReturn);
    }

    public override double acceptCash(double money)
    {
        double result = money;
        if(money &gt;= moneyCondition)
        {
            result = money - Math.Floor(money / moneyCondition) * moneyReturn;
        }
            return result;
    }

}

//现金收费工厂类
class CashFactory
{
    public static CashSuper createCashAccept(string type)
    {
        CashSuper cs = null;
        switch (type)
        {
            case:&quot;正常收费&quot;:
                cs = new CashNormal();
                break;
            case:&quot;满300返100&quot;:
                CashReturn cr1 = new CashReturn(&quot;300&quot;,&quot;100&quot;);
                cs = cr1;
                break;
            case:&quot;打8折&quot;:
                CashRebate cr2 = new CashRebate(&quot;0,8&quot;);
                cs = cr2;
                break;
        }
        return cs;
    }
}

//客户端程序主要部分
double total = 0.0d;
private void btn0k_clik(object sneder, EventArgs e)
{
    cashSuper csuper = CashFactory.createCashAccept(cbxType.SelectedItem.ToString());
    double totalPrices = 0d;
    totalPrices = csuper.acceptCash(Convert.ToDouble(txtPrice.txt)*Convert.ToDouble(txtNum.Text));
    total = total + totalPrices;
    IbxList.Items.Add(&quot;单价：&quot; +txtPrice.Text + &quot;数量：&quot; ＋ txtNum.Text + &quot;合计：&quot;+ totalPrices.ToString());
     IblResult.Text = total.ToString();

}
</code></pre><p>简单工厂模式虽然能解决这个问题，但是这个模式知识解决对象的创建问题，而且由于工厂本身包括了所有的收费方式，商场是可能经常性地更改打折额度和返利额度，每次维护或扩展收费方式都要改动这个工厂，以致代码需重新编译部署，这真的是很糟糕的处理方式，所以用它不是做好的办法，。面对算法的时常变动应该有更好的办法。</p>
<h2 id="策略模式-1"><a href="#策略模式-1" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。</p>
<pre><code>//CashContext类    
class CashContext
{
    private CashSuper cs;
    public CashContext(CashSuper csuper)
    {
        this.cs = csuper;
    }

    public double GetResult(double money)
    {
        return cs.accptCash(money);
    }

}

//客户端主要代码
double total = 0.0d;
private void btn0k_Click(object sender, EventArgs e)
{
    CashContext cc = null;
    switch (cbxType.selectedItem.ToString())
    {
        case: &quot;正常收费&quot;:
            cc = new CashContext(new CashNormal());
            break;
        case: &quot;满300返100&quot;:
            cc = new CashContext(new CashReturn (&quot;300&quot;,&quot;100&quot;));
            break;
        case: &quot;打8折&quot;:
            cc = new CashContext(new CashRebate(&quot;0.8&quot;));
            break;
    }
    double totalPrices = 0d;
    totalPrices = cc.GetResult(convert.ToDouble(txtPrice.Text)*convert.ToDouble(txtNum.Text));
    total = total + totalPrices;
    IbxList.Items.Add(&quot;单价：&quot; +txtPrice.Text + &quot;数量：&quot; ＋ txtNum.Text + &quot;合计：&quot;+ totalPrices.ToString());
     IblResult.Text = total.ToString();

}
</code></pre><p>虽然策略模式写出来了，但是不应该让客户端去判断用哪一个算法。</p>
<h2 id="策略与简单工厂结合"><a href="#策略与简单工厂结合" class="headerlink" title="策略与简单工厂结合"></a>策略与简单工厂结合</h2><pre><code>class CashContext
{
    CashSuper cs  = null;

    public CashContext(String type)
    {
        switch(type)
        {
            case &quot;正常收费&quot;:
                CashNormal cs0 = new CashNormal();
                cs = cs0;
                break;
            case &quot;满300返100&quot;:
                CashReturn cr1 = new CashReturn(&quot;300&quot;,&quot;100&quot;);
                cs = cr1;
                break;
            case &quot;打8折&quot;：
                CashReturn cr2 = new CashRebate(&quot;0.8&quot;);
                cs = cr2;
                break;
        }
        public double GetResult(double money)
        {
            return cs.acceptCash(money);
        }
    }
}

//客户端代码
double total = 0.0d;
private void btn0k_Click(object sender, EvnetArgs e)
{
    CashContext csuper = new CashContext(cbxType.slectedItem.ToString());
    double totalPrices = 0d;
    totalPrices = csuper.GetResult(Convert.ToDouble(txtPrice.Text)*Convert.ToDouble(txtNum.Text));
    total = total + totalPrices;
    IbxList.Items.Add(&quot;单价：&quot; +txtPrice.Text + &quot;数量：&quot; ＋ txtNum.Text + &quot;合计：&quot;+ totalPrices.ToString());
     IblResult.Text = total.ToString();    
}

//简单工厂模式的用法
CashSuper csuper = CashFactory.CreateCashAccept(cbxType.SelectedItem.ToString());
=csuper.GetResult;

//策略模式与简单工厂结合的用法
CashContext csuper = new (CashContext(cbxType.SelectedItem.ToString()));
=csuper.GetResult;
</code></pre><p>简单工厂模式让客户端认识两个类， CashSuper和CashFactory,而策略模式与简单工厂结合的用法，客户端只需要认识一个类CashContext就可以了。耦合更加降低。</p>
<h2 id="策略模式解析"><a href="#策略模式解析" class="headerlink" title="策略模式解析"></a>策略模式解析</h2><p>策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相通的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少各种算法类和使用算法类之间的耦合。<br>策略模式就是用来封装算法的，但是实践中，我们发现可以用它来分装几乎任何类型的规则，只要在分析过程中听到需要在不同的时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性。</p>
<h1 id="面向对象六大原则"><a href="#面向对象六大原则" class="headerlink" title="面向对象六大原则"></a>面向对象六大原则</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在工作初期，我们可能会经常会有这样的感觉，自己的代码接口设计混乱、代码耦合较为严重、一个类的代码过多等等，自己回头看的时候都觉得汗颜。再看那些知名的开源库，它们大多有着整洁的代码、清晰简单的接口、职责单一的类，这个时候我们通常会捶胸顿足而感叹：什么时候老夫才能写出这样的代码！</p>
<h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><p><a href="http://blog.cnbang.net/tech/2320/" target="_blank" rel="external">AFNetworking2.0源码解析</a></p>
<p><a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">AFNetworking源码</a></p>
<h2 id="单一原则-Single-Responsibility-Principle"><a href="#单一原则-Single-Responsibility-Principle" class="headerlink" title="单一原则(Single Responsibility Principle)"></a>单一原则(Single Responsibility Principle)</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>SRP:就一个类而言，应该仅有一个引起它变化的原因。<br>单一职责的划分界限并不是如马路上的行车道那么清晰，很多时候都是需要靠个人经验来界定。当然最大的问题就是对职责的定义，什么是类的职责，以及怎么划分类的职责。<strong>如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏</strong>。</p>
<p><strong>当然，软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离，就是抽象的能力。其实要去判断是否应该分离出类来，也不难，那就是如果你能想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责</strong>。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code>/**
* An HTTP stack abstraction.
*/
public interface HttpStack {
 /**
 * 执行Http请求,并且返回一个HttpResponse
 */ 
public HttpResponse performRequest(Request&lt;?&gt; request,         Map&lt;String, String&gt; additionalHeaders)
    throws IOException, AuthFailureError;
}
</code></pre><p>HttpStack中这个函数的职责就是执行网络请求并且返回一个Response。它的职责很单一，这样在需要修改执行网络请求的相关代码时我们只需要修改实现HttpStack接口的类，而不会影响其它的类的代码。如果某个类的职责包含有执行网络请求、解析网络请求、进行gzip压缩、封装请求参数等等，那么在你修改某处代码时你就必须谨慎，以免修改的代码影响了其它的功能。但是当职责单一的时候，你修改的代码能够基本上不影响其它的功能。这就在一定程度上保证了代码的可维护性。<strong>注意，单一职责原则并不是说一个类只有一个函数，而是说这个类中的函数所做的工作必须要是高度相关的，也就是高内聚</strong>。</p>
<h2 id="里氏替换原则-Liskov-Substitution-Principle"><a href="#里氏替换原则-Liskov-Substitution-Principle" class="headerlink" title="里氏替换原则(Liskov Substitution Principle)"></a>里氏替换原则(Liskov Substitution Principle)</h2><h3 id="简述-1"><a href="#简述-1" class="headerlink" title="简述"></a>简述</h3><p>肯定有不少人跟我刚看到这项原则的时候一样，对这个原则的名字充满疑惑。其实原因就是这项原则最早是在1988年，由麻省理工学院的一位姓里的女士（Barbara Liskov）提出来的。</p>
<p>定义1：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。</p>
<p>定义2：所有引用基类的地方必须能透明地使用其子类的对象。</p>
<p>问题由来：有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。</p>
<p>解决方案：当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。</p>
<p>继承包含这样一层含义：<strong>父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义</strong>。</p>
<p><strong>继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障</strong>。</p>
<p>里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义：</p>
<ul>
<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li>
<li>子类中可以增加自己特有的方法。</li>
<li>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</li>
<li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li>
</ul>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>还是以HttpStack为例，Volley定义了HttpStack来表示执行网络请求这个抽象概念。在执行网络请求时，我们只需要定义一个HttpStack对象，然后调用performRequest即可。至于HttpStack的具体实现由更高层的调用者给出。示例如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">  public static RequestQueue newRequestQueue(Context context, HttpStack stack) &#123;</div><div class="line">      File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);</div><div class="line">      String userAgent = &quot;volley/0&quot;;</div><div class="line">		// 代码省略</div><div class="line">// 1、构造HttpStack对象</div><div class="line">      if (stack == null) &#123;</div><div class="line">          if (Build.VERSION.SDK_INT &gt;= 9) &#123;</div><div class="line">              stack = new HurlStack();</div><div class="line">          &#125; else &#123;</div><div class="line">              // Prior to Gingerbread, HttpUrlConnection was unreliable.</div><div class="line">              // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html</div><div class="line">              stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">// 2、将HttpStack对象传递给Network对象</div><div class="line">      Network network = new BasicNetwork(stack);</div><div class="line">// 3、将network对象传递给网络请求队列</div><div class="line">      RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network);</div><div class="line">      queue.start();</div><div class="line">      return queue;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p> BasicNetwork的代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * A network performing Volley requests over an &#123;@link HttpStack&#125;.</div><div class="line"> */</div><div class="line">public class BasicNetwork implements Network &#123;</div><div class="line">	// HttpStack抽象对象</div><div class="line">    protected final HttpStack mHttpStack;</div><div class="line">    protected final ByteArrayPool mPool;</div><div class="line">    public BasicNetwork(HttpStack httpStack) &#123;</div><div class="line">        this(httpStack, new ByteArrayPool(DEFAULT_POOL_SIZE));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    public BasicNetwork(HttpStack httpStack, ByteArrayPool pool) &#123;</div><div class="line">        mHttpStack = httpStack;</div><div class="line">        mPool = pool;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码中，BasicNetwork构造函数依赖的是HttpStack抽象接口，任何实现了HttpStack接口的类型都可以作为参数传递给BasicNetwork用以执行网络请求。这就是所谓的里氏替换原则，任何父类出现的地方子类都可以出现，这不就保证了可扩展性吗？</p>
<h3 id="减少LSP妨碍"><a href="#减少LSP妨碍" class="headerlink" title="减少LSP妨碍"></a>减少LSP妨碍</h3><h4 id="契约（Contracts）"><a href="#契约（Contracts）" class="headerlink" title="契约（Contracts）"></a>契约（Contracts）</h4><p>处理 LSP 过分妨碍的一个策略是使用契约，契约清单有 2 种形式：执行说明书（executable specifications）和错误处理，在执行说明书里，一个详细类库的契约也包括一组自动化测试，而错误处理是在代码里直接处理的，例如在前置条件，后置条件，常量检查等，可以从 Bertrand Miller 的大作《契约设计》中查看这个技术。虽然自动化测试和契约设计不在本篇文字的范围内，但当我们用的时候我还是推荐如下内容：</p>
<p>检查使用测试驱动开发（Test-Driven Development）来指导你代码的设计<br>设计可重用类库的时候可随意使用契约设计技术<br>对于你自己要维护和实现的代码，使用契约设计趋向于添加很多不必要的代码，如果你要控制输入，添加测试是非常有必要的，如果你是类库作者，使用契约设计，你要注意不正确的使用方法以及让你的用户使之作为一个测试工具。<br>契约（Contracts）</p>
<p>处理 LSP 过分妨碍的一个策略是使用契约，契约清单有 2 种形式：执行说明书（executable specifications）和错误处理，在执行说明书里，一个详细类库的契约也包括一组自动化测试，而错误处理是在代码里直接处理的，例如在前置条件，后置条件，常量检查等，可以从 Bertrand Miller 的大作《契约设计》中查看这个技术。虽然自动化测试和契约设计不在本篇文字的范围内，但当我们用的时候我还是推荐如下内容：</p>
<p>检查使用测试驱动开发（Test-Driven Development）来指导你代码的设计<br>设计可重用类库的时候可随意使用契约设计技术<br>对于你自己要维护和实现的代码，使用契约设计趋向于添加很多不必要的代码，如果你要控制输入，添加测试是非常有必要的，如果你是类库作者，使用契约设计，你要注意不正确的使用方法以及让你的用户使之作为一个测试工具。</p>
<h4 id="避免继承"><a href="#避免继承" class="headerlink" title="避免继承"></a>避免继承</h4><p>避免 LSP 妨碍的另外一个测试是：如果可能的话，尽量不用继承，在Gamma的大作《Design Patterns – Elements of Reusable Object-Orineted Software》中，我们可以看到如下建议：</p>
<p>Favor object composition over class inheritance</p>
<p>尽量使用对象组合而不是类继承<br>有些书里讨论了组合比继承好的唯一作用是静态类型，基于类的语言（例如，在运行时可以改变行为），与 JavaScript 相关的一个问题是耦合，当使用继承的时候，继承子类型和他们的基类型耦合在一起了，就是说基类型的改变会影响到继承子类型。组合倾向于对象更小化，更容易向静态和动态语言语言维护。</p>
<p>与行为有关，而不是继承<br>到现在，我们讨论了和继承上下文在内的里氏替换原则，指示出 JavaScript 的面向对象实。不过，里氏替换原则（LSP）的本质不是真的和继承有关，而是行为兼容性。JavaScript 是一个动态语言，一个对象的契约行为不是对象的类型决定的，而是对象期望的功能决定的。里氏替换原则的初始构想是作为继承的一个原则指南，等价于对象设计中的隐式接口。</p>
<h1 id="依赖倒置原则-Dependence-Inversion-Principle"><a href="#依赖倒置原则-Dependence-Inversion-Principle" class="headerlink" title="依赖倒置原则(Dependence Inversion Principle)"></a>依赖倒置原则(Dependence Inversion Principle)</h1><h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h2><p>电脑在以前维修的话是根本不可能的事，可是现在却特别容易，比如说内存坏了，买个内存条，硬盘坏了，买个硬盘换上。为啥这么方便？从修电脑里面就有面相对象的几大设计原则，比如单一职责原则，内存坏了，不应该成为更换CPU的理由，它们各自的职责是明确的。再比如开放－封闭原则，内存不够只要插槽足够就可以添加。还有依赖倒转原则，<strong>原话解释是抽象不应该依赖细节，细节应该依赖于抽象，说白了，就是要针对接口编程，不要对实现编程</strong>，无论主板，CPU，内存，硬盘都是针对接口设计的，如果是针对实现来设计，内存就要对应的某个品牌的主板，那就会出现换内存需要把主板也换了的尴尬。</p>
<p>为什么叫反转呢？</p>
<p>面对过程开发时，为了使得常用代码可以复用，一般都会把这些常用代码写成许许多多函数的程序库，这样我们做新项目时，去调用这些底层的函数就可以了。比如我们做的项目大多要访问数据库，所以我们就把访问数据库的代码写成了函数，每次做新项目时就去调用，这就叫做高层模块依赖底层模块。</p>
<p>但是要做新项目是 业务逻辑的高层模块都是一样的，客户却希望使用不同的数据库或存储信息方式，这时出现麻烦了。我们希望能再次利用这些高层模块，但高层模块都是与底层的访问数据库绑定在一起的，没办法复用这些高层模块，这就非常糟糕了。就像刚才说的，PC里如果CPU，内存，硬盘都是需要依赖具体的主板，主板一坏，所有的部件都没法用了，显然不合理，而如果不管高层模块还是底层模块，它们都依赖于抽象，具体一点就是接口或者抽象类，只要接口是稳定的，那么任何一个的更改都不用担心其它受影响，这就使得无论高层模块还是底层模块都可以很容易被复用，这才是最好的办法。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。</p>
<p>依赖倒置原则的核心思想是面向接口编程，我们依旧用一个例子来说明面向接口编程比相对于面向实现编程好在什么地方。场景是这样的，母亲给孩子讲故事，只要给她一本书，她就可以照着书给孩子讲故事了。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class Book&#123;  </div><div class="line">    public String getContent()&#123;  </div><div class="line">        return &quot;很久很久以前有一个阿拉伯的故事……&quot;;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">class Mother&#123;  </div><div class="line">    public void narrate(Book book)&#123;  </div><div class="line">        System.out.println(&quot;妈妈开始讲故事&quot;);  </div><div class="line">        System.out.println(book.getContent());  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">public class Client&#123;  </div><div class="line">    public static void main(String[] args)&#123;  </div><div class="line">        Mother mother = new Mother();  </div><div class="line">        mother.narrate(new Book());  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行良好，假如有一天，需求变成这样：不是给书而是给一份报纸，让这位母亲讲一下报纸上的故事，报纸的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Newspaper&#123;  </div><div class="line">    public String getContent()&#123;  </div><div class="line">        return &quot;林书豪38+7领导尼克斯击败湖人……&quot;;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这位母亲却办不到，因为她居然不会读报纸上的故事，这太荒唐了，只是将书换成报纸，居然必须要修改Mother才能读。假如以后需求换成杂志呢？换成网页呢？还要不断地修改Mother，这显然不是好的设计。原因就是Mother与Book之间的耦合性太高了，必须降低他们之间的耦合度才行。<br>我们引入一个抽象的接口IReader。读物，只要是带字的都属于读物：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">interface IReader&#123;  </div><div class="line">    public String getContent();  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">```	</div><div class="line"> </div><div class="line">Mother类与接口IReader发生依赖关系，而Book和Newspaper都属于读物的范畴，他们各自都去实现IReader接口，这样就符合依赖倒置原则了，代码修改为：</div></pre></td></tr></table></figure>
<p>class Newspaper implements IReader {<br>    public String getContent(){<br>        return “林书豪17+9助尼克斯击败老鹰……”;<br>    }<br>}<br>class Book implements IReader{<br>    public String getContent(){<br>        return “很久很久以前有一个阿拉伯的故事……”;<br>    }<br>}  </p>
<p>class Mother{<br>    public void narrate(IReader reader){<br>        System.out.println(“妈妈开始讲故事”);<br>        System.out.println(reader.getContent());<br>    }<br>}  </p>
<p>public class Client{<br>    public static void main(String[] args){<br>        Mother mother = new Mother();<br>        mother.narrate(new Book());<br>        mother.narrate(new Newspaper());<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这样修改后，无论以后怎样扩展Client类，都不需要再修改Mother类了。这只是一个简单的例子，实际情况中，代表高层模块的Mother类将负责完成主要的业务逻辑，一旦需要对它进行修改，引入错误的风险极大。所以遵循依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。</div><div class="line"> </div><div class="line">采用依赖倒置原则给多人并行开发带来了极大的便利，比如上例中，原本Mother类与Book类直接耦合时，Mother类必须等Book类编码完成后才可以进行编码，因为Mother类依赖于Book类。修改后的程序则可以同时开工，互不影响，因为Mother与Book类一点关系也没有。参与协作开发的人越多、项目越庞大，采用依赖导致原则的意义就越重大。现在很流行的TDD开发模式就是依赖倒置原则最成功的应用。</div><div class="line"></div><div class="line">传递依赖关系有三种方式，以上的例子中使用的方法是接口传递，另外还有两种传递方式：构造方法传递和setter方法传递，相信用过Spring框架的，对依赖的传递方式一定不会陌生。</div><div class="line">在实际编程中，我们一般需要做到如下3点：</div><div class="line"></div><div class="line">* 低层模块尽量都要有抽象类或接口，或者两者都有。</div><div class="line">* 变量的声明类型尽量是抽象类或接口。</div><div class="line">* 使用继承时遵循里氏替换原则。</div><div class="line">依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。</div><div class="line"></div><div class="line"># 接口隔离原则(Interface Segregation Principle)</div><div class="line"></div><div class="line">## 简介</div><div class="line">接口隔离原则（英语：interface-segregation principles， 缩写：ISP）指明没有客户(client)应该被迫依赖于它不使用方法。接口隔离原则(ISP)拆分非常庞大臃肿的接口成为更小的和更具体的接口，这样客户将会只需要知道他们感兴趣的方法。这种缩小的接口也被称为角色接口（role interfaces）。接口隔离原则(ISP)的目的是系统解开耦合，从而容易重构，更改和重新部署。接口隔离原则是在SOLID (面向对象设计)中五个面向对象设计(OOD)的原则之一，类似于在GRASP (面向对象设计)中的高内聚性。</div><div class="line"></div><div class="line"></div><div class="line">## 实例</div><div class="line">定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</div><div class="line">问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。</div><div class="line">解决方案：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。</div><div class="line">举例来说明接口隔离原则：</div><div class="line"></div><div class="line">![enter description here][1]</div><div class="line"></div><div class="line"></div><div class="line">这个图的意思是：类A依赖接口I中的方法1、方法2、方法3，类B是对类A依赖的实现。类C依赖接口I中的方法1、方法4、方法5，类D是对类C依赖的实现。对于类B和类D来说，虽然他们都存在着用不到的方法（也就是图中红色字体标记的方法），但由于实现了接口I，所以也必须要实现这些用不到的方法。对类图不熟悉的可以参照程序代码来理解，代码如下：</div></pre></td></tr></table></figure></p>
<p>interface I {<br>    public void method1();<br>    public void method2();<br>    public void method3();<br>    public void method4();<br>    public void method5();<br>}  </p>
<p>class A{<br>    public void depend1(I i){<br>        i.method1();<br>    }<br>    public void depend2(I i){<br>        i.method2();<br>    }<br>    public void depend3(I i){<br>        i.method3();<br>    }<br>}  </p>
<p>class B implements I{<br>    public void method1() {<br>        System.out.println(“类B实现接口I的方法1”);<br>    }<br>    public void method2() {<br>        System.out.println(“类B实现接口I的方法2”);<br>    }<br>    public void method3() {<br>        System.out.println(“类B实现接口I的方法3”);<br>    }<br>    //对于类B来说，method4和method5不是必需的，但是由于接口A中有这两个方法，<br>    //所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。<br>    public void method4() {}<br>    public void method5() {}<br>}  </p>
<p>class C{<br>    public void depend1(I i){<br>        i.method1();<br>    }<br>    public void depend2(I i){<br>        i.method4();<br>    }<br>    public void depend3(I i){<br>        i.method5();<br>    }<br>}  </p>
<p>class D implements I{<br>    public void method1() {<br>        System.out.println(“类D实现接口I的方法1”);<br>    }<br>    //对于类D来说，method2和method3不是必需的，但是由于接口A中有这两个方法，<br>    //所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。<br>    public void method2() {}<br>    public void method3() {}  </p>
<pre><code>public void method4() {  
    System.out.println(&quot;类D实现接口I的方法4&quot;);  
}  
public void method5() {  
    System.out.println(&quot;类D实现接口I的方法5&quot;);  
}  
</code></pre><p>}  </p>
<p>public class Client{<br>    public static void main(String[] args){<br>        A a = new A();<br>        a.depend1(new B());<br>        a.depend2(new B());<br>        a.depend3(new B());  </p>
<pre><code>    C c = new C();  
    c.depend1(new D());  
    c.depend2(new D());  
    c.depend3(new D());  
}  
</code></pre><p>}  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">可以看到，如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。如果将这个设计修改为符合接口隔离原则，就必须对接口I进行拆分。在这里我们将原有的接口I拆分为三个接口，拆分后的设计如图2所示：</div><div class="line">![</div><div class="line">][2]</div></pre></td></tr></table></figure>
<p>interface I1 {<br>    public void method1();<br>}  </p>
<p>interface I2 {<br>    public void method2();<br>    public void method3();<br>}  </p>
<p>interface I3 {<br>    public void method4();<br>    public void method5();<br>}  </p>
<p>class A{<br>    public void depend1(I1 i){<br>        i.method1();<br>    }<br>    public void depend2(I2 i){<br>        i.method2();<br>    }<br>    public void depend3(I2 i){<br>        i.method3();<br>    }<br>}  </p>
<p>class B implements I1, I2{<br>    public void method1() {<br>        System.out.println(“类B实现接口I1的方法1”);<br>    }<br>    public void method2() {<br>        System.out.println(“类B实现接口I2的方法2”);<br>    }<br>    public void method3() {<br>        System.out.println(“类B实现接口I2的方法3”);<br>    }<br>}  </p>
<p>class C{<br>    public void depend1(I1 i){<br>        i.method1();<br>    }<br>    public void depend2(I3 i){<br>        i.method4();<br>    }<br>    public void depend3(I3 i){<br>        i.method5();<br>    }<br>}  </p>
<p>class D implements I1, I3{<br>    public void method1() {<br>        System.out.println(“类D实现接口I1的方法1”);<br>    }<br>    public void method4() {<br>        System.out.println(“类D实现接口I3的方法4”);<br>    }<br>    public void method5() {<br>        System.out.println(“类D实现接口I3的方法5”);<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">  接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。本文例子中，将一个庞大的接口变更为3个专用的接口所采用的就是接口隔离原则。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</div><div class="line">  </div><div class="line">  说到这里，很多人会觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构。</div><div class="line">  采用接口隔离原则对接口进行约束时，要注意以下几点：</div><div class="line">  </div><div class="line">* 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</div><div class="line">* 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</div><div class="line">* 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</div><div class="line">运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。</div><div class="line"></div><div class="line"></div><div class="line">  # 迪米特原则( Law of Demeter)</div><div class="line"></div><div class="line">## 简介</div><div class="line">得墨忒耳定律（Law of Demeter，缩写LoD）亦稱為“最少知识原则（Principle of Least Knowledge）”，是一种软件开发的设计指導原則，特别是面向对象的程序设计。得墨忒耳定律是松耦合的一种具體案例。該原則是美國東北大學在1987年末在發明的，可以簡單地以下面任一種方式總結:</div><div class="line"></div><div class="line">每个单元对于其他的单元只能拥有有限的知识：只是与当前单元紧密联系的单元；</div><div class="line">每个单元只能和它的朋友交谈：不能和陌生单元交谈；</div><div class="line">只和自己直接的朋友交谈。</div><div class="line">这个原理的名称来源于希腊神话中的农业女神，孤独的得墨忒耳。</div><div class="line"></div><div class="line">很多面向对象程序设计语言用&quot;.&quot;表示对象的域的解析算符，因此得墨忒耳定律可以简单地陈述为“只使用一个.算符”。因此，a.b.Method()违反了此定律，而a.Method()不违反此定律。一个简单例子是，人可以命令一条狗行走（walk），但是不应该直接指挥狗的腿行走，应该由狗去指挥控制它的腿如何行走。</div><div class="line"></div><div class="line">## 实例</div><div class="line">**定义**：一个对象应该对其他对象保持最少的了解。</div><div class="line">问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</div><div class="line"></div><div class="line">**解决方案**：尽量降低类与类之间的耦合。</div><div class="line"></div><div class="line">自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。</div><div class="line"></div><div class="line">迪米特法则又叫最少知道原则，最早是在1987年由美国Northeastern University的Ian Holland提出。通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。迪米特法则还有一个更简单的定义：只与直接的朋友通信。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。</div><div class="line"></div><div class="line">举一个例子：有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工ID。先来看一下违反迪米特法则的设计。</div></pre></td></tr></table></figure></p>
<p>//总公司员工<br>class Employee{<br>    private String id;<br>    public void setId(String id){<br>        this.id = id;<br>    }<br>    public String getId(){<br>        return id;<br>    }<br>}  </p>
<p>//分公司员工<br>class SubEmployee{<br>    private String id;<br>    public void setId(String id){<br>        this.id = id;<br>    }<br>    public String getId(){<br>        return id;<br>    }<br>}  </p>
<p>class SubCompanyManager{<br>    public List<subemployee> getAllEmployee(){<br>        List<subemployee> list = new ArrayList<subemployee>();<br>        for(int i=0; i&lt;100; i++){<br>            SubEmployee emp = new SubEmployee();<br>            //为分公司人员按顺序分配一个ID<br>            emp.setId(“分公司”+i);<br>            list.add(emp);<br>        }<br>        return list;<br>    }<br>}  </subemployee></subemployee></subemployee></p>
<p>class CompanyManager{  </p>
<pre><code>public List&lt;Employee&gt; getAllEmployee(){  
    List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;();  
    for(int i=0; i&lt;30; i++){  
        Employee emp = new Employee();  
        //为总公司人员按顺序分配一个ID  
        emp.setId(&quot;总公司&quot;+i);  
        list.add(emp);  
    }  
    return list;  
}  

public void printAllEmployee(SubCompanyManager sub){  
    List&lt;SubEmployee&gt; list1 = sub.getAllEmployee();  
    for(SubEmployee e:list1){  
        System.out.println(e.getId());  
    }  

    List&lt;Employee&gt; list2 = this.getAllEmployee();  
    for(Employee e:list2){  
        System.out.println(e.getId());  
    }  
}  
</code></pre><p>}  </p>
<p>public class Client{<br>    public static void main(String[] args){<br>        CompanyManager e = new CompanyManager();<br>        e.printAllEmployee(new SubCompanyManager());<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">现在这个设计的主要问题出在CompanyManager中，根据迪米特法则，只与直接的朋友发生通信，而SubEmployee类并不是CompanyManager类的直接朋友（以局部变量出现的耦合不属于直接朋友），从逻辑上讲总公司只与他的分公司耦合就行了，与分公司的员工并没有任何联系，这样设计显然是增加了不必要的耦合。按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合。修改后的代码如下:</div></pre></td></tr></table></figure></p>
<p>class SubCompanyManager{<br>    public List<subemployee> getAllEmployee(){<br>        List<subemployee> list = new ArrayList<subemployee>();<br>        for(int i=0; i<100; i++){="" subemployee="" emp="new" subemployee();="" 为分公司人员按顺序分配一个id="" emp.setid("分公司"+i);="" list.add(emp);="" }="" return="" list;="" public="" void="" printemployee(){="" list<subemployee=""> list = this.getAllEmployee();<br>        for(SubEmployee e:list){<br>            System.out.println(e.getId());<br>        }<br>    }<br>}  </100;></subemployee></subemployee></subemployee></p>
<p>class CompanyManager{<br>    public List<employee> getAllEmployee(){<br>        List<employee> list = new ArrayList<employee>();<br>        for(int i=0; i&lt;30; i++){<br>            Employee emp = new Employee();<br>            //为总公司人员按顺序分配一个ID<br>            emp.setId(“总公司”+i);<br>            list.add(emp);<br>        }<br>        return list;<br>    }  </employee></employee></employee></p>
<pre><code>public void printAllEmployee(SubCompanyManager sub){  
    sub.printEmployee();  
    List&lt;Employee&gt; list2 = this.getAllEmployee();  
    for(Employee e:list2){  
        System.out.println(e.getId());  
    }  
}  
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">修改后，为分公司增加了打印人员ID的方法，总公司直接调用来打印，从而避免了与分公司的员工发生耦合。</div><div class="line"></div><div class="line">迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系，例如本例中，总公司就是通过分公司这个“中介”来与分公司的员工发生联系的。过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。</div><div class="line"></div><div class="line"># 开闭原则(Open-Close Principle)</div><div class="line">## 简介</div><div class="line">Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification.</div><div class="line">软件实体（类，模块，方法等等）应当对扩展开放，对修改关闭，即软件实体应当在不修改的前提下扩展。</div><div class="line"></div><div class="line">问题由来:在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。</div><div class="line"></div><div class="line">解决方案: 开闭原则是面向对象设计中最基础的设计原则，它指导我们如何建立稳定灵活的系统。开闭原则可能是设计模式六项原则中定义最模糊的一个了，它只告诉我们对扩展开放，对修改关闭，可是到底如何才能做到对扩展开放，对修改关闭，并没有明确的告诉我们。以前，如果有人告诉我“你进行设计的时候一定要遵守开闭原则”，我会觉的他什么都没说，但貌似又什么都说了。因为开闭原则真的太虚了。</div><div class="line"></div><div class="line">  在仔细思考以及仔细阅读很多设计模式的文章后，终于对开闭原则有了一点认识。其实，我们遵循设计模式其它5大原则，以及使用23种设计模式的目的就是遵循开闭原则。也就是说，只要我们对其它5项原则遵守的好了，设计出的软件自然是符合开闭原则的，这个开闭原则更像是前面五项原则遵守程度的“平均得分”，前面5项原则遵守的好，平均分自然就高，说明软件设计开闭原则遵守的好；如果前面5项原则遵守的不好，则说明开闭原则遵守的不好。</div><div class="line">  </div><div class="line">  开闭原则无非就是想表达这样一层意思：用抽象构建框架，用实现扩展细节。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。</div><div class="line"></div><div class="line"></div><div class="line">**其它的5项原则，恰恰是告诉我们用抽象构建框架，用实现扩展细节的注意事项而已：单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭**。</div><div class="line"></div><div class="line">最后说明一下如何去遵守这六个原则。对这六个原则的遵守并不是是和否的问题，而是多和少的问题，也就是说，我们一般不会说有没有遵守，而是说遵守程度的多少。任何事都是过犹不及，设计模式的六个设计原则也是一样，制定这六个原则的目的并不是要我们刻板的遵守他们，而需要根据实际情况灵活运用。对他们的遵守程度只要在一个合理的范围内，就算是良好的设计。我们用一幅图来说明一下。</div><div class="line"></div><div class="line">![</div><div class="line">][3]</div><div class="line"></div><div class="line">图中的每一条维度各代表一项原则，我们依据对这项原则的遵守程度在维度上画一个点，则如果对这项原则遵守的合理的话，这个点应该落在红色的同心圆内部；如果遵守的差，点将会在小圆内部；如果过度遵守，点将会落在大圆外部。一个良好的设计体现在图中，应该是六个顶点都在同心圆中的六边形。</div><div class="line"></div><div class="line">## 实例</div><div class="line">在软件开发过程中，永远不变的就是变化。开闭原则是使我们的软件系统拥抱变化的核心原则之一。对扩展可放，对修改关闭给出了高层次的概括，即在需要对软件进行升级、变化时应该通过扩展的形式来实现，而非修改原有代码。当然这只是一种比较理想的状态，是通过扩展还是通过修改旧代码需要根据代码自身来定。</div><div class="line"></div><div class="line">在Volley中，开闭原则体现得比较好的是Request类族的设计。我们知道，在开发C/S应用时，服务器返回的数据格式多种多样，有字符串类型、xml、json等。而解析服务器返回的Response的原始数据类型则是通过Request类来实现的，这样就使得Request类对于服务器返回的数据格式有良好的扩展性，即Request的可变性太大。</div><div class="line"></div><div class="line">例如我们返回的数据格式是Json，那么我们使用JsonObjectRequest请求来获取数据，它会将结果转成JsonObject对象，我们看看JsonObjectRequest的核心实现。</div></pre></td></tr></table></figure></p>
<p>/**</p>
<ul>
<li>A request for retrieving a {@link JSONObject} response body at a given URL, allowing for an</li>
<li>optional {@link JSONObject} to be passed in as part of the request body.<br>*/<br>public class JsonObjectRequest extends JsonRequest<jsonobject> {<br>// 代码省略<br> @Override<br> protected Response<jsonobject> parseNetworkResponse(NetworkResponse response) {<pre><code>try {
    String jsonString =
        new String(response.data, HttpHeaderParser.parseCharset(response.headers));
    return Response.success(new JSONObject(jsonString),
            HttpHeaderParser.parseCacheHeaders(response));
} catch (UnsupportedEncodingException e) {
    return Response.error(new ParseError(e));
} catch (JSONException je) {
    return Response.error(new ParseError(je));
}
</code></pre> }<br>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">JsonObjectRequest通过实现Request抽象类的parseNetworkResponse解析服务器返回的结果，这里将结果转换为JSONObject，并且封装到Response类中。</div><div class="line"></div><div class="line">例如Volley添加对图片请求的支持，即ImageLoader( 已内置 )。这个时候我的请求返回的数据是Bitmap图片。因此我需要在该类型的Request得到的结果是Request，但支持一种数据格式不能通过修改源码的形式，这样可能会为旧代码引入错误。但是你又需要支持新的数据格式，此时我们的开闭原则就很重要了，对扩展开放，对修改关闭。我们看看Volley是如何做的。</div></pre></td></tr></table></figure>
</jsonobject></jsonobject></li>
</ul>
<p>/**</p>
<ul>
<li>A canned request for getting an image at a given URL and calling</li>
<li>back with a decoded Bitmap.<br>*/<br>public class ImageRequest extends Request<bitmap> {<br> // 代码省略<br> // 将结果解析成Bitmap，并且封装套Response对象中<br> @Override<br> protected Response<bitmap> parseNetworkResponse(NetworkResponse response) {<pre><code>// Serialize all decode on a global lock to reduce concurrent heap usage.
synchronized (sDecodeLock) {
    try {
        return doParse(response);
    } catch (OutOfMemoryError e) {
        VolleyLog.e(&quot;Caught OOM for %d byte image, url=%s&quot;, response.data.length, getUrl());
        return Response.error(new ParseError(e));
    }
}
</code></pre> }<br> /**<ul>
<li>The real guts of parseNetworkResponse. Broken out for readability.<br>*/<br>private Response<bitmap> doParse(NetworkResponse response) {<br> byte[] data = response.data;<br> BitmapFactory.Options decodeOptions = new BitmapFactory.Options();<br> Bitmap bitmap = null;<br> // 解析Bitmap的相关代码,在此省略<br> if (bitmap == null) {<pre><code>return Response.error(new ParseError(response));
</code></pre> } else {<pre><code>return Response.success(bitmap, HttpHeaderParser.parseCacheHeaders(response));
</code></pre> }<br>}<br>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">需要添加某种数据格式的Request时，只需要继承自Request类，并且实现相应的方法即可。这样通过扩展的形式来应对软件的变化或者说用户需求的多样性，即避免了破坏原有系统，又保证了软件系统的可扩展性。</div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  # 装饰原则(Decorator pattern)</div><div class="line">## 简介</div><div class="line">Decorator装饰模式是一种结构型模式，它主要是解决：“过度地使用了继承来扩展对象的功能”，由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性；并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀（多继承）。继承为类型引入的静态特质的意思是说以继承的方式使某一类型要获得功能是在编译时。所谓静态，是指在编译时；动态，是指在运行时。</div><div class="line"></div><div class="line">修饰模式，是面向对象编程领域中，一种动态地往一个类中添加新的行为的设计模式。就功能而言，修饰模式相比生成子类更为灵活，这样可以给某个对象而不是整个类添加一些功能。</div><div class="line"></div><div class="line">GoF《设计模式》中说道：动态的给一个对象添加一些额外的职责。就增加功能而言，Decorator模式比生成子类更为灵活。</div><div class="line">下面来看看Decorator模式的结构：</div><div class="line"></div><div class="line">![enter description here][4]</div><div class="line"></div><div class="line">看这个结构好像不是很明白，下面我根据代码讲解一下这个结构。我想了一个场景：我们现在用的手机功能很多，我就用Decorator模式实现一下对某个手机的GSP和蓝牙功能扩展。</div><div class="line">首先，我们需要一个手机的接口或者是抽象类，我这里就用抽象类来实现，代码如下：</div></pre></td></tr></table></figure>
</bitmap></li>
</ul>
</bitmap></bitmap></li>
</ul>
<p>public abstract class AbstractCellPhone<br>    {<br>        public abstract string CallNumber();<br>        public abstract string SendMessage();<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">AbstractCellPhone也就是结构图中的Component，然后，我再来实现Nokia和Moto的手机类，这类要继承AbstractCellPhone，也就是图中ConcreteComponent类要继承Component，实现代码如下：</div></pre></td></tr></table></figure></p>
<p>public class NokiaPhone : AbstractCellPhone<br>    {<br>        public override string CallNumber()<br>        {<br>            return “NokiaPhone call sombody”;<br>        }</p>
<pre><code>    public override string SendMessage()
    {
        return &quot;NokiaPhone send a message to somebody&quot;;
    }
}

public class MotoPhone : AbstractCellPhone
{
    public override string CallNumber()
    {
        return &quot;MotoPhone call sombody&quot;;
    }

    public override string SendMessage()
    {
        return &quot;MotoPhone send a message to somebody&quot;;
    }
</code></pre><p> }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">接下来我需要一个Decorator接口或者抽象类，实现代码如下：</div></pre></td></tr></table></figure></p>
<p>public abstract class Decorator:AbstractCellPhone<br>    {<br>        AbstractCellPhone _phone;</p>
<pre><code>public Decorator(AbstractCellPhone phone)
{
    _phone = phone;
}

public override string CallNumber()
{
    return _phone.CallNumber();
}

public override string SendMessage()
{
    return _phone.SendMessage();
}
</code></pre><p>  }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">正如结构图中，这个Decorator即继承了AbstractCellPhone，又包含了一个私有的AbstractCellPhone的对象。这样做的意义是：Decorator类又使用了另外一个Component类。我们可以使用一个或多个Decorator对象来“装饰”一个Component对象，且装饰后的对象仍然是一个Component对象。在下来，我要实现GSP和蓝牙的功能扩展，它们要继承自Decorator，代码如下：</div></pre></td></tr></table></figure></p>
<p>public class DecoratorGPS : Decorator<br>    {<br>        public DecoratorGPS(AbstractCellPhone phone)<br>            : base(phone)<br>        { }</p>
<pre><code>    public override string CallNumber()
    {
        return base.CallNumber() + &quot; with GPS&quot;;
    }

    public override string SendMessage()
    {
        return base.SendMessage() + &quot; with GPS&quot;;
    }
}

public class DecoratorBlueTooth : Decorator
{
    public DecoratorBlueTooth(AbstractCellPhone phone)
        : base(phone)
    { }

    public override string CallNumber()
    {
        return base.CallNumber() + &quot; with BlueTooth&quot;;
    }

    public override string SendMessage()
    {
        return base.SendMessage() + &quot; with BlueTooth&quot;;
    }
</code></pre><p> }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">最后，用客户端程序验证一下：</div></pre></td></tr></table></figure></p>
<p>static void Main(string[] args)<br>        {<br>             AbstractCellPhone phone = new NokiaPhone();<br>            Console.WriteLine(phone.CallNumber());<br>            Console.WriteLine(phone.SendMessage());<br>            DecoratorGPS gps = new DecoratorGPS(phone);     //add GSP<br>            Console.WriteLine(gps.CallNumber());<br>            Console.WriteLine(gps.SendMessage());<br>            DecoratorBlueTooth bluetooth = new DecoratorBlueTooth(gps); //add GSP and bluetooth<br>            Console.WriteLine(bluetooth.CallNumber());<br>            Console.WriteLine(bluetooth.SendMessage());<br>            Console.Read();<br>     }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">执行结果：</div><div class="line">NokiaPhone call sombody</div><div class="line">NokiaPhone send a message to somebody</div><div class="line">NokiaPhone call sombody with GPS</div><div class="line">NokiaPhone send a message to somebody with GPS</div><div class="line">NokiaPhone call sombody with GPS with BlueTooth</div><div class="line">NokiaPhone send a message to somebody with GPS with BlueTooth</div><div class="line"> </div><div class="line">从执行的结果不难看出扩展功能已被添加。最后再说说Decorator装饰模式的几点要点：</div><div class="line"></div><div class="line">1. 通过采用组合、而非继承的手法，Decorator模式实现了在运行时动态的扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了单独使用继承带来的“灵活性差”和“多子类衍生问题”。</div><div class="line">2. Component类在Decorator模式中充当抽象接口的角色，不应该去实现具体的行为。而且Decorator类对于Component类应该透明——换言之Component类无需知道Decorator类，Decorator类是从外部来扩展Component类的功能。</div><div class="line">3. Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。但在实现上又表现为has-a Component的组合关系，即Decorator类又使用了另外一个Component类。我们可以使用一个或多个Decorator对象来“装饰”一个Component对象，且装饰后的对象仍然是一个Component对象。（在这里我想谈一下我的理解：当我们实例化一个Component对象后，要给这个对象扩展功能，这时我们把这个Component对象当作参数传给Decorator的子类的构造函数——也就是扩展方法的功能类。对于引用类型传参时，实际上只是传递对象的地址，这样，在功能扩展是，操作的应该是同一个对象）</div><div class="line">4. Decorator模式并非解决“多子类衍生的多继承”问题，Decorator模式应用的要点在于解决“主体类在多个方向上的扩展功能”——是为“装饰”的含义。Decorator是在运行时对功能进行组合。</div><div class="line"></div><div class="line">## 实例</div><div class="line"></div><div class="line">### Category</div><div class="line">Objective-C 中的 Category 就是对装饰模式的一种具体实现。它的主要作用是在不改变原有类的前提下，动态地给这个类添加一些方法。在 Objective-C 中的具体体现为：实例（类）方法、属性和协议。是的，在 Objective-C 中可以用 Category 来实现协议。本文将结合 runtime（我下载的是当前的最新版本 objc4-646.tar.gz) 的源码来探究它实现的原理。</div><div class="line">### 使用场景</div><div class="line">根据苹果官方文档对 Category 的描述，它的使用场景主要有三个：</div><div class="line"></div><div class="line"> * 给现有的类添加方法.</div><div class="line"> * 将一个类的实现拆分成多个独立的源文件.</div><div class="line"> * 声明私有的方法.</div><div class="line"> </div><div class="line"> 其中，第 1 个是最典型的使用场景，应用最广泛。</div><div class="line"></div><div class="line">注：Category 有一个非常容易误用的场景，那就是用 Category 来覆写父类或主类的方法。虽然目前 Objective-C 是允许这么做的，但是这种使用场景是非常不推荐的。使用 Category 来覆写方法有很多缺点，比如不能覆写 Category 中的方法、无法调用主类中的原始实现等，且很容易造成无法预估的行为。</div><div class="line"></div><div class="line">我们知道，无论我们有没有主动引入 Category 的头文件，Category 中的方法都会被添加进主类中。我们可以通过 - performSelector: 等方式对 Category 中的相应方法进行调用，之所以需要在调用的地方引入 Category 的头文件，只是为了“照顾”编译器同学的感受。</div><div class="line"></div><div class="line">下面，我们将结合 runtime 的源码探究下 Category 的实现原理。打开 runtime 源码工程，在文件 objc-runtime-new.mm 中找到以下函数：</div></pre></td></tr></table></figure></p>
<p>void _read_images(header_info **hList, uint32_t hCount)<br>{<br>    …<br>        _free_internal(resolvedFutureClasses);<br>    }</p>
<pre><code>// Discover categories. 
for (EACH_HEADER) {
    category_t **catlist =
        _getObjc2CategoryList(hi, &amp;count);
    for (i = 0; i &lt; count; i++) {
        category_t *cat = catlist[i];
        Class cls = remapClass(cat-&gt;cls);

        if (!cls) {
            // Category&apos;s target class is missing (probably weak-linked).
            // Disavow any knowledge of this category.
            catlist[i] = nil;
            if (PrintConnecting) {
                _objc_inform(&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;
                             &quot;missing weak-linked target class&quot;,
                             cat-&gt;name, cat);
            }
            continue;
        }

          ***    
        // Process this category. 
        // First, register the category with its target class. 
        // Then, rebuild the class&apos;s method lists (etc) if 
        // the class is realized. 
        BOOL classExists = NO;
        if (cat-&gt;instanceMethods ||  cat-&gt;protocols
            ||  cat-&gt;instanceProperties)
        {
            addUnattachedCategoryForClass(cat, cls, hi);
            if (cls-&gt;isRealized()) {
                remethodizeClass(cls);
                classExists = YES;
            }
            if (PrintConnecting) {
                _objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;,
                             cls-&gt;nameForLogging(), cat-&gt;name,
                             classExists ? &quot;on existing class&quot; : &quot;&quot;);
            }
        }

        if (cat-&gt;classMethods  ||  cat-&gt;protocols
            /* ||  cat-&gt;classProperties */)
        {
            addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);
            if (cls-&gt;ISA()-&gt;isRealized()) {
                remethodizeClass(cls-&gt;ISA());
            }
            if (PrintConnecting) {
                _objc_inform(&quot;CLASS: found category +%s(%s)&quot;,
                             cls-&gt;nameForLogging(), cat-&gt;name);
            }
        }
    }
}

// Category discovery MUST BE LAST to avoid potential races 
// when other threads call the new category code before 
// this thread finishes its fixups.

// +load handled by prepare_load_methods()

...
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">从第 27-58 行的关键代码，我们可以知道在这个函数中对 Category 做了如下处理：</div><div class="line"></div><div class="line">* 将 Category 和它的主类（或元类）注册到哈希表中；</div><div class="line">* 如果主类（或元类）已实现，那么重建它的方法列表。</div><div class="line">在这里分了两种情况进行处理：Category 中的实例方法和属性被整合到主类中；而类方法则被整合到元类中（关于对象、类和元类的更多细节，可以参考博文[Objective-C 对象模型](http://blog.leichunfeng.com/blog/2015/04/25/objective-c-object-model/)。另外，对协议的处理比较特殊，Category 中的协议被同时整合到了主类和元类中。</div><div class="line"></div><div class="line">我们注意到，不管是哪种情况，最终都是通过调用 static void remethodizeClass(Class cls) 函数来重新整理类的数据的。</div></pre></td></tr></table></figure></p>
<p>static void remethodizeClass(Class cls)<br>{<br>    …<br>                         cls-&gt;nameForLogging(), isMeta ? “(meta)” : “”);<br>        }</p>
<pre><code>    // Update methods, properties, protocols

    attachCategoryMethods(cls, cats, YES);

    newproperties = buildPropertyList(nil, cats, isMeta);
    if (newproperties) {
        newproperties-&gt;next = cls-&gt;data()-&gt;properties;
        cls-&gt;data()-&gt;properties = newproperties;
    }

    newprotos = buildProtocolList(cats, nil, cls-&gt;data()-&gt;protocols);
    if (cls-&gt;data()-&gt;protocols  &amp;&amp;  cls-&gt;data()-&gt;protocols != newprotos) {
        _free_internal(cls-&gt;data()-&gt;protocols);
    }
    cls-&gt;data()-&gt;protocols = newprotos;

    _free_internal(cats);
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这个函数的主要作用是将 Category 中的方法、属性和协议整合到类（主类或元类）中，更新类的数据字段 ```data()``` 中 ```method_lists```（或 ```method_list```）、```properties``` 和 `protocols` 的值。进一步，我们通过 `attachCategoryMethods` 函数的源码可以找到真正处理 Category 方法的 `attachMethodLists` 函数：</div></pre></td></tr></table></figure></p>
<p>static void<br>attachMethodLists(Class cls, method_list_t **addedLists, int addedCount,<br>                  bool baseMethods, bool methodsFromBundle,<br>                  bool flushCaches)<br>{<br>    …<br>        newLists[newCount++] = mlist;<br>    }</p>
<pre><code>// Copy old methods to the method list array
for (i = 0; i &lt; oldCount; i++) {
    newLists[newCount++] = oldLists[i];
}
if (oldLists  &amp;&amp;  oldLists != oldBuf) free(oldLists);

// nil-terminate
newLists[newCount] = nil;

if (newCount &gt; 1) {
    assert(newLists != newBuf);
    cls-&gt;data()-&gt;method_lists = newLists;
    cls-&gt;setInfo(RW_METHOD_ARRAY);
} else {
    assert(newLists == newBuf);
    cls-&gt;data()-&gt;method_list = newLists[0];
    assert(!(cls-&gt;data()-&gt;flags &amp; RW_METHOD_ARRAY));
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这个函数的代码量看上去比较多，但是我们并不难理解它的目的。它的主要作用就是将类中的旧有方法和 Category 中新添加的方法整合成一个新的方法列表，并赋值给 method_lists 或 method_list 。通过探究这个处理过程，我们也印证了一个结论，那就是主类中的方法和 Category 中的方法在 runtime 看来并没有区别，它们是被同等对待的，都保存在主类的方法列表中。</div><div class="line"></div><div class="line">不过，类的方法列表字段有一点特殊，它的结构是联合体，method_lists 和 method_list 共用同一块内存地址。当 newCount 的个数大于 1 时，使用 method_lists 来保存 newLists ，并将方法列表的标志位置为 RW_METHOD_ARRAY ，此时类的方法列表字段是 method_list_t 类型的指针数组；否则，使用 method_list 来保存 newLists ，并将方法列表的标志位置空，此时类的方法列表字段是 method_list_t 类型的指针。</div></pre></td></tr></table></figure></p>
<p>// class’s method list is an array of method lists</p>
<p>#define RW_METHOD_ARRAY       (1&lt;&lt;20)</p>
<p>union {<br>    method_list_t <em>*method_lists;  // RW_METHOD_ARRAY == 1<br>    method_list_t </em>method_list;    // RW_METHOD_ARRAY == 0<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">我们注意到 runtime 对 Category 中方法的处理过程并没有对 +load 方法进行什么特殊地处理。因此，严格意义上讲 Category 中的 +load 方法跟普通方法一样也会对主类中的 +load 方法造成覆盖，只不过 runtime 在自动调用主类和 Category 中的 +load 方法时是直接使用各自方法的指针进行调用的。所以才会使我们觉得主类和 Category 中的 +load 方法好像互不影响一样。因此，当我们手动给主类发送 +load 消息时，调用的一直会是分类中的 +load 方法，you should give it a try yourself 。</div><div class="line"></div><div class="line"></div><div class="line">  # 代理模式(Proxy pattern)</div><div class="line">## 简介</div><div class="line">代理模式（英语：Proxy Pattern）是程序设计中的一种设计模式。</div><div class="line"></div><div class="line">所谓的代理者是指一个类可以作为其它东西的接口。代理者可以作任何东西的接口：网络连接、内存中的大对象、文件或其它昂贵或无法复制的资源。</div><div class="line"></div><div class="line">著名的代理模式例子为引用计数（英语：reference counting）指针对象。</div><div class="line"></div><div class="line">当一个复杂对象的多份副本须存在时，代理模式可以结合享元模式以减少内存用量。典型作法是创建一个复杂对象及多个代理者，每个代理者会引用到原本的复杂对象。而作用在代理者的运算会转送到原本对象。一旦所有的代理者都不存在时，复杂对象会被移除。</div><div class="line"></div><div class="line">***</div><div class="line"></div><div class="line">在某些情况下，一个客户不想或者不能直接引用一个对象，此时可以通过一个称之为“代理”的第三者来实现 间接引用。代理对象可以在客户端和目标对象之间起到 中介的作用，并且可以通过代理对象去掉客户不能看到 的内容和服务或者添加客户需要的额外服务。</div><div class="line"></div><div class="line">通过引入一个新的对象（如小图片和远程代理 对象）来实现对真实对象的操作或者将新的对 象作为真实对象的一个替身，这种实现机制即 为代理模式，通过引入代理对象来间接访问一 个对象，这就是代理模式的模式动机。</div><div class="line"></div><div class="line">## 讲解</div></pre></td></tr></table></figure></p>
<p>#include <iostream></iostream></p>
<p>#include “RealSubject.h”</p>
<p>#include “Proxy.h”</p>
<p>using namespace std;</p>
<p>int main(int argc, char *argv[])<br>{<br>    Proxy proxy;<br>    proxy.request();</p>
<pre><code>return 0;
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>///////////////////////////////////////////////////////////<br>//  Proxy.h<br>//  Implementation of the Class Proxy<br>//  Created on:      07-十月-2014 16:57:54<br>//  Original author: colin<br>///////////////////////////////////////////////////////////</p>
<p>#if !defined(EA_56011290_0413_40c6_9132<em>63EE89B023FD__INCLUDED</em>)</p>
<p>#define EA_56011290_0413_40c6_9132<em>63EE89B023FD__INCLUDED</em></p>
<p>#include “RealSubject.h”</p>
<p>#include “Subject.h”</p>
<p>class Proxy : public Subject<br>{</p>
<p>public:<br>    Proxy();<br>    virtual ~Proxy();</p>
<pre><code>void request();
</code></pre><p>private:<br>    void afterRequest();<br>    void preRequest();<br>    RealSubject *m_pRealSubject;</p>
<p>};</p>
<p>#endif // !defined(EA_56011290_0413_40c6_9132<em>63EE89B023FD__INCLUDED</em>)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>///////////////////////////////////////////////////////////<br>//  Proxy.cpp<br>//  Implementation of the Class Proxy<br>//  Created on:      07-十月-2014 16:57:54<br>//  Original author: colin<br>///////////////////////////////////////////////////////////</p>
<p>#include “Proxy.h”</p>
<p>#include <iostream><br>using namespace std;</iostream></p>
<p>Proxy::Proxy(){<br>    //有人觉得 RealSubject对象的创建应该是在main中实现；我认为RealSubject应该<br>    //对用户是透明的，用户所面对的接口都是通过代理的；这样才是真正的代理；<br>    m_pRealSubject = new RealSubject();<br>}</p>
<p>Proxy::~Proxy(){<br>    delete m_pRealSubject;<br>}</p>
<p>void Proxy::afterRequest(){<br>    cout &lt;&lt; “Proxy::afterRequest” &lt;&lt; endl;<br>}</p>
<p>void Proxy::preRequest(){<br>    cout &lt;&lt; “Proxy::preRequest” &lt;&lt; endl;<br>}</p>
<p>void Proxy::request(){<br>    preRequest();<br>    m_pRealSubject-&gt;request();<br>    afterRequest();<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 优点</div><div class="line"></div><div class="line">* 代理模式能够协调调用者和被调用者，在一定程度上降低了系 统的耦合度。</div><div class="line">* 远程代理使得客户端可以访问在远程机器上的对象，远程机器 可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。</div><div class="line">* 虚拟代理通过使用一个小对象来代表一个大对象，可以减少系 统资源的消耗，对系统进行优化并提高运行速度。</div><div class="line">* 保护代理可以控制对真实对象的使用权限。</div><div class="line"></div><div class="line">### 缺点</div><div class="line"></div><div class="line">* 由于在客户端和真实主题之间增加了代理对象，因此 有些类型的代理模式可能会造成请求的处理速度变慢。</div><div class="line">* 实现代理模式需要额外的工作，有些代理模式的实现 非常复杂。</div><div class="line"></div><div class="line">### 适用环境</div><div class="line">根据代理模式的使用目的，常见的代理模式有以下几种类型：</div><div class="line"></div><div class="line">* 远程(Remote)代理：为一个位于不同的地址空间的对象提供一个本地 的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在 另一台主机中，远程代理又叫做大使(Ambassador)。</div><div class="line">* 虚拟(Virtual)代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</div><div class="line">* Copy-on-Write代理：它是虚拟代理的一种，把复制（克隆）操作延迟 到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个 开销较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。</div><div class="line">* 保护(Protect or Access)代理：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</div><div class="line">* 缓冲(Cache)代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</div><div class="line">* 防火墙(Firewall)代理：保护目标不让恶意用户接近。</div><div class="line">* 同步化(Synchronization)代理：使几个用户能够同时使用一个对象而没有冲突。</div><div class="line">* 智能引用(Smart Reference)代理：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来等。</div><div class="line"></div><div class="line">## 实例</div><div class="line">图片懒加载是一个很典型的代理模式的例子。</div></pre></td></tr></table></figure></p>
<p>//抽象日志记录类：抽象主题<br>interface AbstractLog<br>{<br>    public void method();<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>import java.util.*;</p>
<p>//日志记录代理类：代理主题<br>class LoggerProxy implements AbstractLog<br>{<br>    private BusinessClass business;</p>
<pre><code>public LoggerProxy()
{
    business = new BusinessClass();
}

public void method()
{
    Calendar calendar = new GregorianCalendar();
    int year = calendar.get(Calendar.YEAR);
    int month = calendar.get(Calendar.MONTH) + 1;
    int day = calendar.get(Calendar.DAY_OF_MONTH);
    int hour = calendar.get(Calendar.HOUR) + 12;
    int minute = calendar.get(Calendar.MINUTE);
    int second = calendar.get(Calendar.SECOND);
    String dateTime = year + &quot;-&quot; + month + &quot;-&quot; + day + &quot; &quot; + hour + &quot;:&quot; + minute + &quot;:&quot; + second + &quot;！&quot;;
    System.out.println(&quot;方法method()被调用，调用时间为&quot; + dateTime);
    try{
        business.method();
        System.out.println(&quot;方法method()调用成功！&quot;);
    }
    catch(Exception e)
    {
        System.out.println(&quot;方法method()调用失败！&quot;);
    }
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>//业务类：真实主题<br>class BusinessClass implements AbstractLog<br>{<br>    public void method()<br>    {<br>        System.out.println(“真实业务方法！”);<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>//客户端测试类<br>class Client<br>{<br>    public static void main(String args[])<br>    {<br>        AbstractLog al;<br>        al = new LoggerProxy();<br>        al.method();<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">在本实例中，通过代理类LoggerProxy来间接调用真实业务类BusinessClass的方法，可以在调用真实业务方法时增加新功能（如日志记录），此处使用的是代理模式的一种较为简单的形式，类似于保护代理，在实施真实调用时可以执行一些额外的操作。由于代理主题和真实主题实现了相同的接口，因此在客户端可以针对抽象编程，而将具体代理类类名存储至配置文件中，增加和更换代理类和真实类都很方便，无需修改源代码，满足开闭原则。</div><div class="line"></div><div class="line"></div><div class="line"># 工厂方法模式(Factory Method pattern)</div><div class="line">## 简介</div><div class="line"></div><div class="line">“工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</div><div class="line">## 与简单工厂模式的对比</div><div class="line">以计算器为例</div><div class="line">### 简单工厂模式</div><div class="line">    public class OperationFactory</div><div class="line">    &#123;</div><div class="line">    	public static operation createOperate(string operate)</div><div class="line">    	&#123;</div><div class="line">    	Operation oper = null;</div><div class="line">    	switch (operate)</div><div class="line">    	&#123;</div><div class="line">    		case &quot;+&quot;:</div><div class="line">    			oper = new OperationAdd();</div><div class="line">    			break;</div><div class="line">    		case &quot;-&quot;:</div><div class="line">    			oper = new OperationSub();</div><div class="line">    			break;</div><div class="line">    		case &quot;*&quot;:</div><div class="line">    			oper = new OperationMul();</div><div class="line">    			break;</div><div class="line">    		case &quot;/&quot;:</div><div class="line">    			oper = new OperationDiv();</div><div class="line">    			break;</div><div class="line">    	&#125;</div><div class="line">    	return oper;</div><div class="line">    	&#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">客户端代码</div><div class="line"></div><div class="line">    Operation oper;</div><div class="line">    oper = OperationFactory.createOperate(&quot;+&quot;);</div><div class="line">    oper.NumberA = 1;</div><div class="line">    oper.NumberB = 2;</div><div class="line">    double result = oper.GetResult();</div><div class="line">    </div><div class="line">#### 工厂方法模式</div></pre></td></tr></table></figure></p>
<p>interface IFactory<br>{<br>    Operation CreateOperation();<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">然后加减乘除各建一个具体工厂去实现这个接口。</div></pre></td></tr></table></figure></p>
<p>class addFactory: IFactory<br>{<br>    public Operation CreateOperation()<br>    {<br>        return new OperationAdd();<br>    }<br>}</p>
<p>class subFactory: IFactory<br>{<br>    public Operation CreateOperation()<br>    {<br>        return new OperationSub();<br>    }<br>}</p>
<p>class mulFactory: IFactory<br>{<br>    public Operation CreateOperation()<br>    {<br>        return new OperationMul();<br>    }<br>}</p>
<p>class divFactory: IFactory<br>{<br>    public Operation CreateOperation()<br>    {<br>        return new OperationDiv();<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">客户端的实现是这样的。</div></pre></td></tr></table></figure>
<p>IFactory operFactory = new addFactory();<br>operation oper = operationFactory.CreateOperation();<br>oper.NumberA = 1;<br>oper.NumberB = 2;<br>double result = oper.GetResult();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">***简单工厂模式的最大优点在于工厂类中包涵了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体相关产品的依赖。***就像你的计算器，让客户端不用管该用哪个类的实例，只需要把&apos;+&apos;给工厂，工厂自动就给出了相应的实例，客户端只要去做运算就可以了，不同的实例会实现不同的运算。但是问题也就在这里，如你所说，如果要加一个&apos;求M数的N次方&apos;的功能，我们是一定需要给运算工厂类的方法里加&apos;case&apos;的分支条件的，修改原来的类并不是好方法，这就等于说，我们不但对扩展开放了，对修改也开放了，这样违背了开放封闭原则。</div><div class="line"></div><div class="line">工厂方法模式，定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</div><div class="line">其实你仔细观察会发现，工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑判断移到了客户端代码来运行，你想要加功能，本来是修改工厂类的，而现在修改客户端。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"># 原型模式(Prototype pattern)</div><div class="line">## 简介</div><div class="line">原型模式是创建型模式的一种,其特点在于通过「复制」一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的「原型」，这个原型是可定制的。</div><div class="line"></div><div class="line">***原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据。***</div><div class="line"></div><div class="line">***</div><div class="line">Prototype原型模式是一种创建型设计模式，它主要面对的问题是：“某些结构复杂的对象”的创建工作；由于需求的变化，这些对象经常面临着剧烈的变化，但是他们却拥有比较稳定一致的接口。下面我们先来看下关联的的几种设计模式，予以区分，再来说说原型模式。</div><div class="line"></div><div class="line">* Singleton单件模式解决的问题是：实体对象个数问题（这个现在还不太容易混）</div><div class="line">* AbstractFactory抽象工厂模式解决的问题是：“一系列互相依赖的对象”的创建工作</div><div class="line">* Builder生成器模式解决的问题是：“一些复杂对象”的创建工作，子对象变化较频繁，对算法相对稳定</div><div class="line">* FactoryMethor工厂方法模式解决的问题是：某个对象的创建工作。</div><div class="line"></div><div class="line">《设计模式》中说道：使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象。</div><div class="line"></div><div class="line"></div><div class="line">## 例子</div></pre></td></tr></table></figure></p>
<p>/<strong> Prototype Class </strong>/<br> public class Cookie implements Cloneable {</p>
<pre><code>public Object clone() throws CloneNotSupportedException
{
    //In an actual implementation of this pattern you would now attach references to
    //the expensive to produce parts from the copies that are held inside the prototype.
    return (Cookie) super.clone();
}
</code></pre><p> }</p>
<p> /<strong> Concrete Prototypes to clone </strong>/<br> public class CoconutCookie extends Cookie { }</p>
<p> /<strong> Client Class</strong>/<br> public class CookieMachine<br> {</p>
<p>   private Cookie cookie;//cookie必须是可复制的</p>
<pre><code> public CookieMachine(Cookie cookie) { 
     this.cookie = cookie; 
 } 

public Cookie makeCookie()
{
    try
    {
        return (Cookie) cookie.clone();
    } catch (CloneNotSupportedException e)
    {
        e.printStackTrace();
    }
    return null;
} 


 public static void main(String args[]){ 
     Cookie tempCookie =  null; 
     Cookie prot = new CoconutCookie(); 
     CookieMachine cm = new CookieMachine(prot); //设置原型
     for(int i=0; i&lt;100; i++) 
         tempCookie = cm.makeCookie();//通过复制原型返回多个cookie 
 } 
</code></pre><p> }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">现在我们再来看看原型模式的几个要点：</div><div class="line"> </div><div class="line">* Prototype模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些“易变类”拥有“稳定的接口”。</div><div class="line">* Prototype模式对于“如何创建易变类的实体对象”采用“原型克隆”的方法来实现，它使得我们可以非常灵活地动态创建“拥有某些稳定接口”的新对象——所需工作仅仅是注册一个新类的对象（即原型），然后在任何需要的地方不断地Clone。</div><div class="line">* Prototype模式中的Clone方法可以利用Object类的MemberwiseClone（）或者序列化来实现深拷贝。</div><div class="line"></div><div class="line">***</div><div class="line"></div><div class="line">### Javascript中的prototype就是使用了原型模式</div></pre></td></tr></table></figure></p>
<p>function Person(name, age, job) {<br>  this.name = name;<br>  this.age = age;<br>  this.job = job;<br>}</p>
<p>// 通过原型模式来添加所有实例共享的方法<br>// sayName() 方法将会被Person的所有实例共享，而避免了重复创建<br>Person.prototype.sayName = function () {<br>  console.log(this.name);<br>};</p>
<p>var person1 = new Person(‘Weiwei’, 27, ‘Student’);<br>var person2 = new Person(‘Lily’, 25, ‘Doctor’);</p>
<p>console.log(person1.sayName === person2.sayName); // true</p>
<p>person1.sayName(); // Weiwei<br>person2.sayName(); // Lily<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">正如上面的代码所示，通过原型模式定义的方法sayName()为所有的实例所共享。也就是， person1和person2访问的是同一个sayName()函数。同样的，公共属性也可以使用原型模式进行定义。例如：</div></pre></td></tr></table></figure></p>
<p>function Chinese (name) {<br>    this.name = name;<br>}</p>
<p>Chinese.prototype.country = ‘China’; // 公共属性，所有实例共享<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">由于所有的实例对象共享同一个prototype对象，那么从外界看起来，prototype对象就好像是实例对象的原型，而实例对象则好像&quot;继承&quot;了prototype对象一样。它是浅拷贝。</div><div class="line"></div><div class="line">//TODO clone的原理()</div><div class="line"></div><div class="line">JAVA的clone()实现机制涉及到了反射、IO流操作、序列化等。</div><div class="line"></div><div class="line"></div><div class="line"># 模版方法模式(Template method pattern)</div><div class="line">## 简介</div><div class="line">模板方法模式定义了一个算法的步骤，并允许子类别为一个或多个步骤提供其实践方式。让子类别在不改变算法架构的情况下，重新定义算法中的某些步骤。在软件工程中，它是一种软件设计模式，和C++模板没有关连。</div><div class="line"></div><div class="line">## 实例</div><div class="line"> 事实上，模版方法是编程中一个经常用到的模式。先来看一个例子，某日，程序员A拿到一个任务：给定一个整数数组，把数组中的数由小到大排序，然后把排序之后的结果打印出来。经过分析之后，这个任务大体上可分为两部分，排序和打印，打印功能好实现，排序就有点麻烦了。但是A有办法，先把打印功能完成，排序功能另找人做。</div></pre></td></tr></table></figure></p>
<p> abstract class AbstractSort {  </p>
<pre><code>/** 
 * 将数组array由小到大排序 
 * @param array 
 */  
protected abstract void sort(int[] array);  

public void showSortResult(int[] array){  
    this.sort(array);  
    System.out.print(&quot;排序结果：&quot;);  
    for (int i = 0; i &lt; array.length; i++){  
        System.out.printf(&quot;%3s&quot;, array[i]);  
    }  
}  
</code></pre><p>}<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">写完后，A找到刚毕业入职不久的同事B说：有个任务，主要逻辑我已经写好了，你把剩下的逻辑实现一下吧。于是把AbstractSort类给B，让B写实现。B拿过来一看，太简单了，10分钟搞定，代码如下：</div></pre></td></tr></table></figure></p>
<p>class ConcreteSort extends AbstractSort {  </p>
<pre><code>@Override  
protected void sort(int[] array){  
    for(int i=0; i&lt;array.length-1; i++){  
        selectSort(array, i);  
    }  
}  

private void selectSort(int[] array, int index) {  
    int MinValue = 32767; // 最小值变量  
    int indexMin = 0; // 最小值索引变量  
    int Temp; // 暂存变量  
    for (int i = index; i &lt; array.length; i++) {  
        if (array[i] &lt; MinValue){ // 找到最小值  
            MinValue = array[i]; // 储存最小值  
            indexMin = i;   
        }  
    }  
    Temp = array[index]; // 交换两数值  
    array[index] = array[indexMin];  
    array[indexMin] = Temp;  
}  
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">写好后交给A，A拿来一运行：</div></pre></td></tr></table></figure></p>
<p>public class Client {<br>    public static int[] a = { 10, 32, 1, 9, 5, 7, 12, 0, 4, 3 }; // 预设数据数组<br>    public static void main(String[] args){<br>        AbstractSort s = new ConcreteSort();<br>        s.showSortResult(a);<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">排序结果：  0  1  3  4  5  7  9 10 12 32</div><div class="line"></div><div class="line">运行正常。行了，任务完成。没错，这就是模版方法模式。大部分刚步入职场的毕业生应该都有类似B的经历。一个复杂的任务，由公司中的牛人们将主要的逻辑写好，然后把那些看上去比较简单的方法写成抽象的，交给其他的同事去开发。这种分工方式在编程人员水平层次比较明显的公司中经常用到。比如一个项目组，有架构师，高级工程师，初级工程师，则一般由架构师使用大量的接口、抽象类将整个系统的逻辑串起来，实现的编码则根据难度的不同分别交给高级工程师和初级工程师来完成。怎么样，是不是用到过模版方法模式？</div><div class="line"></div><div class="line">### 模版方法的优点及适用场景</div><div class="line">`AbstractClass`是一个抽象类，其实也就是一个抽象模版，定义并实现一个模版的方法。这个模版的方法一般是一个具体的方法,它给出了一个顶级逻辑的骨架，而逻辑组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。</div></pre></td></tr></table></figure></p>
<p>abstract class AbstractClass<br>{<br>    public abstract void PrimitiveOperation1();<br>    public abstract void PrimitiveOperation2();</p>
<pre><code>public void TemplateMethod()
{
    PrimitiveOperation1();
    PrimitiveOperation2();
    console.WriteLine(&quot;&quot;);
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">`ConcreteClass`实现夫类所定义的一个或者多个抽象方法。每一个`AbstractClass`都可以有任意多个`ConcreteClass`与之对应，而每一个`ConcreteClass`都可以给出这些抽象方法(也就是顶级逻辑的组成步骤)的不同实现，从而使得顶级逻辑的实现各不相同。</div></pre></td></tr></table></figure></p>
<p>class ConcreteClassA: AbstractClass<br>{<br>    public override void PrimitiveOperation1()<br>    {<br>        Console.writeLine(“具体类A方法1实现”);<br>    }<br>        public override void PrimitiveOperation2()<br>    {<br>        Console.writeLine(“具体类A方法2实现”);<br>    }<br>}</p>
<p>class ConcreteClassB: AbstractClass<br>{<br>    public override void PrimitiveOperation1()<br>    {<br>        Console.writeLine(“具体类B方法1实现”);<br>    }<br>        public override void PrimitiveOperation2()<br>    {<br>        Console.writeLine(“具体类B方法2实现”);<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">客户端调用</div></pre></td></tr></table></figure>
<p>static void Main(string[] args)<br>{<br>    AbstractClass c;<br>    c = new ConcreteClassA();<br>    c.TemplateMethod();</p>
<pre><code>c = new ConcreteClassB();
c.TemplateMethod();

Console.Read();
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">***模版方法模式是通过把不变的行为搬移到超类，去除子类中的重复代码来体现它的优势。当不变的和可变的行为在方法的子类实现中混合在一起的时候，不变的行为就会在子类中重复出现。我们通过模版方法模式把这些行为版已到单一的地方，这样就帮助子类摆脱重复的不变的行为的纠缠。***</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"># 外观模式(Facade pattern)</div><div class="line">## 简介</div><div class="line">外观模式（Facade pattern），是软件工程中常用的一种软件设计模式，它为子系统中的一组接口提供一个统一的高层接口，使得子系统更容易使用。</div><div class="line"></div><div class="line">## 模式实现</div><div class="line">某软件公司欲开发一个可应用于多个软件的文件加密模块，该模块可以对文件中的数据进行加密并将加密之后的数据存储在一个新文件中，具体的流程包括三个部分，分别是读取源文件、加密、保存加密之后的文件，其中，读取文件和保存文件使用流来实现，加密操作通过求模运算实现。这三个操作相对独立，为了实现代码的独立重用，让设计更符合单一职责原则，这三个操作的业务代码封装在三个不同的类中。</div><div class="line">现使用外观模式设计该文件加密模块。</div><div class="line"></div><div class="line">(1) FileReader：文件读取类，充当子系统类。</div></pre></td></tr></table></figure></p>
<p>//FileReader.cs<br>using System;<br>using System.Text;<br>using System.IO;  </p>
<p>namespace FacadeSample<br>{<br>    class FileReader<br>    {<br>        public string Read(string fileNameSrc)<br>        {<br>       Console.Write(“读取文件，获取明文：”);<br>            FileStream fs = null;<br>            StringBuilder sb = new StringBuilder();<br>       try<br>            {<br>                fs = new FileStream(fileNameSrc, FileMode.Open);<br>                int data;<br>               while((data = fs.ReadByte())!= -1)<br>                {<br>            sb = sb.Append((char)data);<br>               }<br>               fs.Close();<br>               Console.WriteLine(sb.ToString());<br>       }<br>       catch(FileNotFoundException e)<br>            {<br>           Console.WriteLine(“文件不存在！”);<br>       }<br>       catch(IOException e)<br>            {<br>           Console.WriteLine(“文件操作错误！”);<br>       }<br>       return sb.ToString();<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(2) CipherMachine：数据加密类，充当子系统类。</div></pre></td></tr></table></figure></p>
<p>//CipherMachine.cs<br>using System;<br>using System.Text;  </p>
<p>namespace FacadeSample<br>{<br>    class CipherMachine<br>    {<br>       public string Encrypt(string plainText)<br>       {<br>       Console.Write(“数据加密，将明文转换为密文：”);<br>       string es = “”;<br>            char[] chars = plainText.ToCharArray();<br>       foreach(char ch in chars)<br>            {<br>                string c = (ch % 7).ToString();<br>           es += c;<br>       }<br>            Console.WriteLine(es);<br>       return es;<br>    }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">(3) FileWriter：文件保存类，充当子系统类。</div></pre></td></tr></table></figure></p>
<p>//FileWriter.cs<br>using System;<br>using System.IO;<br>using System.Text;  </p>
<p>namespace FacadeSample<br>{<br>    class FileWriter<br>    {<br>        public void Write(string encryptStr,string fileNameDes)<br>        {<br>       Console.WriteLine(“保存密文，写入文件。”);<br>            FileStream fs = null;<br>       try<br>            {<br>               fs = new FileStream(fileNameDes, FileMode.Create);<br>                byte[] str = Encoding.Default.GetBytes(encryptStr);<br>                fs.Write(str,0,str.Length);<br>                fs.Flush();<br>               fs.Close();<br>       }<br>       catch(FileNotFoundException e)<br>            {<br>        Console.WriteLine(“文件不存在！”);<br>       }<br>       catch(IOException e)<br>            {<br>                Console.WriteLine(e.Message);<br>           Console.WriteLine(“文件操作错误！”);<br>       }<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">(4) EncryptFacade：加密外观类，充当外观类。</div></pre></td></tr></table></figure></p>
<p>// EncryptFacade.cs<br>namespace FacadeSample<br>{<br>    class EncryptFacade<br>    {<br>        //维持对其他对象的引用<br>         private FileReader reader;<br>        private CipherMachine cipher;<br>        private FileWriter writer;  </p>
<pre><code>    public EncryptFacade()  
    {  
        reader = new FileReader();  
        cipher = new CipherMachine();  
        writer = new FileWriter();  
    }  

    //调用其他对象的业务方法  
     public void FileEncrypt(string fileNameSrc, string fileNameDes)  
    {  
        string plainStr = reader.Read(fileNameSrc);  
        string encryptStr = cipher.Encrypt(plainStr);  
        writer.Write(encryptStr, fileNameDes);  
    }  
}  
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">(5) Program：客户端测试类</div></pre></td></tr></table></figure></p>
<p>//Program.cs<br>using System;  </p>
<p>namespace FacadeSample<br>{<br>    class Program<br>    {<br>        static void Main(string[] args)<br>        {<br>            EncryptFacade ef = new EncryptFacade();<br>            ef.FileEncrypt(“src.txt”, “des.txt”);<br>            Console.Read();<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">### 结果及分析</div></pre></td></tr></table></figure></p>
<p>读取文件，获取明文：Hello world!<br>数据加密，将明文转换为密文：233364062325<br>保存密文，写入文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">## 抽象外观类</div><div class="line">在标准的外观模式结构图中，如果需要增加、删除或更换与外观类交互的子系统类，必须修改外观类或客户端的源代码，这将违背开闭原则，因此可以通过引入抽象外观类来对系统进行改进，在一定程度上可以解决该问题。在引入抽象外观类之后，客户端可以针对抽象外观类进行编程，对于新的业务需求，不需要修改原有外观类，而对应增加一个新的具体外观类，由新的具体外观类来关联新的子系统对象，同时通过修改配置文件来达到不修改任何源代码并更换外观类的目的。</div><div class="line"></div><div class="line">下面通过一个具体实例来学习如何使用抽象外观类：</div><div class="line"></div><div class="line">如果在应用实例“文件加密模块”中需要更换一个加密类，不再使用原有的基于求模运算的加密类CipherMachine，而改为基于移位运算的新加密类NewCipherMachine，其代码如下：</div></pre></td></tr></table></figure></p>
<p>using System;  </p>
<p>namespace FacadeSample<br>{<br>    class NewCipherMachine<br>    {<br>        public string Encrypt(string plainText)<br>        {<br>            Console.Write(“数据加密，将明文转换为密文：”);<br>            string es = “”;<br>            int key = 10;//设置密钥，移位数为10<br>            char[] chars = plainText.ToCharArray();<br>            foreach(char ch in chars)<br>            {<br>                int temp = Convert.ToInt32(ch);<br>                //小写字母移位<br>                if (ch &gt;= ‘a’ &amp;&amp; ch &lt;= ‘z’) {<br>                    temp += key % 26;<br>                    if (temp &gt; 122) temp -= 26;<br>                    if (temp &lt; 97) temp += 26;<br>                }<br>                //大写字母移位<br>                if (ch &gt;= ‘A’ &amp;&amp; ch &lt;= ‘Z’) {<br>                    temp += key % 26;<br>                    if (temp &gt; 90) temp -= 26;<br>                    if (temp &lt; 65) temp += 26;<br>                }<br>                es += ((char)temp).ToString();<br>            }<br>            Console.WriteLine(es);<br>            return es;<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">如果不增加新的外观类，只能通过修改原有外观类EncryptFacade的源代码来实现加密类的更换，将原有的对CipherMachine类型对象的引用改为对NewCipherMachine类型对象的引用，这违背了开闭原则，因此需要通过增加新的外观类来实现对子系统对象引用的改变。</div><div class="line"></div><div class="line">如果增加一个新的外观类NewEncryptFacade来与FileReader类、FileWriter类以及新增加的NewCipherMachine类进行交互，虽然原有系统类库无须做任何修改，但是因为客户端代码中原来针对EncryptFacade类进行编程，现在需要改为NewEncryptFacade类，因此需要修改客户端源代码。</div><div class="line"></div><div class="line">如何在不修改客户端代码的前提下使用新的外观类呢？解决方法之一是：引入一个抽象外观类，客户端针对抽象外观类编程，而在运行时再确定具体外观类，引入抽象外观类之后的文件加密模块结构图如图5所示：</div><div class="line"></div><div class="line">![enter description here][5]</div><div class="line"></div><div class="line"></div><div class="line">客户类Client针对抽象外观类AbstractEncryptFacade进行编程，AbstractEncryptFacade代码如下：</div></pre></td></tr></table></figure></p>
<p>namespace FacadeSample<br>{<br>    abstract class AbstractEncryptFacade<br>    {<br>        public abstract void FileEncrypt(string fileNameSrc, string fileNameDes);<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">新增具体加密外观类NewEncryptFacade代码如下：</div></pre></td></tr></table></figure></p>
<p>namespace FacadeSample<br>{<br>    class NewEncryptFacade : AbstractEncryptFacade<br>    {<br>        private FileReader reader;<br>        private NewCipherMachine cipher;<br>        private FileWriter writer;  </p>
<pre><code>    public NewEncryptFacade()  
    {  
        reader = new FileReader();  
        cipher = new NewCipherMachine();  
        writer = new FileWriter();  
    }  

    public override void FileEncrypt(string fileNameSrc, string fileNameDes)  
    {  
        string plainStr = reader.Read(fileNameSrc);  
        string encryptStr = cipher.Encrypt(plainStr);  
        writer.Write(encryptStr, fileNameDes);  
    }  
}  
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>配置文件App.config中存储了具体外观类的类名，代码如下：<br>&lt;?xml version=”1.0” encoding=”utf-8” ?&gt;  </p>
<p><configuration><br>  <appsettings><br>    <add key="facade" value="FacadeSample.NewEncryptFacade"><br>  </add></appsettings><br></configuration><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">客户端测试代码修改如下：</div></pre></td></tr></table></figure></p>
<p>using System;<br>using System.Configuration;<br>using System.Reflection;  </p>
<p>namespace FacadeSample<br>{<br>    class Program<br>    {<br>        static void Main(string[] args)<br>        {<br>            AbstractEncryptFacade ef; //针对抽象外观类编程<br>            //读取配置文件<br>            string facadeString = ConfigurationManager.AppSettings[“facade”];<br>            //反射生成对象<br>            ef = (AbstractEncryptFacade)Assembly.Load(“FacadeSample”). CreateInstance (facadeString);<br>            ef.FileEncrypt(“src.txt”, “des.txt”);<br>            Console.Read();<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 模式适用场景</div><div class="line">在以下情况下可以考虑使用外观模式：</div><div class="line"></div><div class="line">1. 当要为访问一系列复杂的子系统提供一个简单入口时可以使用外观模式。</div><div class="line">2. 客户端程序与多个子系统之间存在很大的依赖性。引入外观类可以将子系统与客户端解耦，从而提高子系统的独立性和可移植性。</div><div class="line">3. 在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</div><div class="line"></div><div class="line"></div><div class="line"># 建造者模式(Builder Pattern)</div><div class="line">## 简介</div><div class="line">生成器模式是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。</div><div class="line"></div><div class="line">### 范例</div></pre></td></tr></table></figure></p>
<p> /<em>* “Product” </em>/<br> class Pizza {<br>   private String dough = “”;<br>   private String sauce = “”;<br>   private String topping = “”;</p>
<p>   public void setDough (String dough)     { this.dough = dough; }<br>   public void setSauce (String sauce)     { this.sauce = sauce; }<br>   public void setTopping (String topping) { this.topping = topping; }<br> }</p>
<p> ‘’/<em>* “Abstract Builder” </em>/‘’<br> abstract class PizzaBuilder {<br>   protected Pizza pizza;</p>
<p>   public Pizza getPizza() { return pizza; }<br>   public void createNewPizzaProduct() { pizza = new Pizza(); }</p>
<p>   public abstract void buildDough();<br>   public abstract void buildSauce();<br>   public abstract void buildTopping();<br> }</p>
<p> /<em>* “ConcreteBuilder” </em>/<br> class HawaiianPizzaBuilder extends PizzaBuilder {<br>   public void buildDough()   { pizza.setDough(“cross”); }<br>   public void buildSauce()   { pizza.setSauce(“mild”); }<br>   public void buildTopping() { pizza.setTopping(“ham+pineapple”); }<br> }</p>
<p> /<em>* “ConcreteBuilder” </em>/<br> class SpicyPizzaBuilder extends PizzaBuilder {<br>   public void buildDough()   { pizza.setDough(“pan baked”); }<br>   public void buildSauce()   { pizza.setSauce(“hot”); }<br>   public void buildTopping() { pizza.setTopping(“pepperoni+salami”); }<br> }</p>
<p> ‘’/<em>* “Director” </em>/‘’<br> class Waiter {<br>   private PizzaBuilder pizzaBuilder;</p>
<p>   public void setPizzaBuilder (PizzaBuilder pb) { pizzaBuilder = pb; }<br>   public Pizza getPizza() { return pizzaBuilder.getPizza(); }</p>
<p>   public void constructPizza() {<br>     pizzaBuilder.createNewPizzaProduct();<br>     pizzaBuilder.buildDough();<br>     pizzaBuilder.buildSauce();<br>     pizzaBuilder.buildTopping();<br>   }<br> }</p>
<p> /<em>* A customer ordering a pizza. </em>/<br> class BuilderExample {<br>   public static void main(String[] args) {<br>     Waiter waiter = new Waiter();<br>     PizzaBuilder hawaiian_pizzabuilder = new HawaiianPizzaBuilder();<br>     PizzaBuilder spicy_pizzabuilder = new SpicyPizzaBuilder();</p>
<pre><code>waiter.setPizzaBuilder ( hawaiian_pizzabuilder );
waiter.constructPizza();

Pizza pizza = waiter.getPizza();
</code></pre><p>   }<br> }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">抽象工厂模式与生成器相似，因为它也可以创建复杂对象。主要的区别是生成器模式着重于一步步构造一个复杂对象。而抽象工厂模式着重于多个系列的产品对象（简单的或是复杂的）。生成器在最后的一步返回产品，而对于抽象工厂来说，产品是立即返回的。</div><div class="line"></div><div class="line">## 实例</div><div class="line">。</div><div class="line"></div><div class="line">建造者模式包含如下角色：</div><div class="line"></div><div class="line">* Builder：抽象建造者</div><div class="line">* ConcreteBuilder：具体建造者</div><div class="line">* Director：指挥者</div><div class="line">* Product：产品角色</div><div class="line"></div><div class="line">![</div><div class="line">][6]</div><div class="line"></div><div class="line">### 实序图</div><div class="line">![</div><div class="line">][7]</div><div class="line"></div><div class="line"></div><div class="line">建造者模式主要是用于创建一些复杂的对象，这些对象内部构建间的建造顺序是稳定的，但是对象内部的构建通常面临着复杂的变化。</div><div class="line"></div><div class="line">建造者模式的好处就是使得建造代码与表示代码分离，由于建造者隐藏了改产品是如何组装的，所以若需要改变一个产品的内部表示，只需要再定义一个具体的建造者就可以了。</div><div class="line"></div><div class="line"></div><div class="line"># 观察者模式(Observer Pattern)</div><div class="line">## 简介</div><div class="line">***观察者模式（有时又被称为发布/订阅模式）是软件设计模式的一种。在此种模式中，一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实时事件处理系统。***</div><div class="line"></div><div class="line">![</div><div class="line">][8]</div><div class="line"></div><div class="line">### 抽象目标类别</div><div class="line">此抽象类别提供一个界面让观察者进行添附与解附作业。此类别内有个不公开的观察者串炼，并透过下列函式(方法)进行作业</div><div class="line"></div><div class="line">* 添附(Attach)：新增观察者到串炼内，以追踪目标对象的变化。</div><div class="line">* 解附(Detach)：将已经存在的观察者从串炼中移除。</div><div class="line">* 通知(Notify)：利用观察者所提供的更新函式来通知此目标已经产生变化。</div><div class="line"></div><div class="line">添附函式包涵了一个观察者对象参数。也许是观察者类别的虚拟函式(即更新函式)，或是在非面向对象的设定中所使用的函式指标(更广泛来讲，函式子或是函式对象)。</div><div class="line"></div><div class="line">### 目标类别</div><div class="line">此类别提供了观察者欲追踪的状态。也利用其源类别(例如前述的抽象目标类别)所提供的方法,来通知所有的观察者其状态已经更新。此类别拥有以下函式</div><div class="line"></div><div class="line">* 取得状态(GetState)：回传该目标对象的状态。</div><div class="line"></div><div class="line">### 抽象观察者界面</div><div class="line">抽象观察者类别是一个必须被实做的抽象类别。这个类别定义了所有观察者都拥有的更新用界面，此界面是用来接收目标类别所发出的更新通知。此类别含有以下函式</div><div class="line"></div><div class="line">* 更新(Update)：会被实做的一个抽象(虚拟)函式。</div><div class="line"></div><div class="line">### 观察者类别 </div><div class="line">这个类别含有指向目标类别的参考(reference)，以接收来自目标类别的更新状态。此类别含有以下函式</div><div class="line"></div><div class="line">* 更新(Update)：是前述抽象函式的实做。当这个函式被目标对象呼叫时，观察者对象将会呼叫目标对象的取得状态函式，来其所拥有的更新目标对象资讯。</div><div class="line">每个观察者类别都要实做它自己的更新函式，以应对状态更新的情形。</div><div class="line"></div><div class="line">当目标对象改变时，会通过呼叫它自己的通知函式来将通知送给每一个观察者对象，这个通知函式则会去呼叫已经添附在串炼内的观察者更新函式。通知与更新函式可能会有一些参数，好指明是目前目标对象内的何种改变。这么作将可增进观察者的效率(只更新那些改变部分的状态)。</div><div class="line"></div><div class="line">### 用途</div><div class="line"></div><div class="line">* 当抽象个体有两个互相依赖的层面时。封装这些层面在单独的对象内将可允许程序员单独地去变更与重复使用这些对象，而不会产生两者之间交互的问题。</div><div class="line">* 当其中一个对象的变更会影响其他对象，却又不知道多少对象必须被同时变更时。</div><div class="line">* 当对象应该有能力通知其他对象，又不应该知道其他对象的实做细节时。</div></pre></td></tr></table></figure></p>
<p>=== C++ ===</p>
<p><source lang="cpp"></p>
<p>#include <list></list></p>
<p>#include <vector></vector></p>
<p>#include <algorithm></algorithm></p>
<p>#include <iostream><br>using namespace std;</iostream></p>
<p>// The Abstract Observer<br>class ObserverBoardInterface<br>{<br>public:<br>    virtual void update(float a,float b,float c) = 0;<br>};</p>
<p>// Abstract Interface for Displays<br>class DisplayBoardInterface<br>{<br>public:<br>    virtual void show() = 0;<br>};</p>
<p>// The Abstract Subject<br>class WeatherDataInterface<br>{<br>public:<br>    virtual void registerob(ObserverBoardInterface<em> ob) = 0;<br>    virtual void removeob(ObserverBoardInterface</em> ob) = 0;<br>    virtual void notifyOb() = 0;<br>};</p>
<p>// The Concrete Subject<br>class ParaWeatherData: public WeatherDataInterface<br>{<br>public:<br>    void SensorDataChange(float a,float b,float c)<br>    {<br>        m_humidity = a;<br>        m_temperature = b;<br>        m_pressure = c;<br>        notifyOb();<br>    }</p>
<pre><code>void registerob(ObserverBoardInterface* ob)
{
    m_obs.push_back(ob);
}

void removeob(ObserverBoardInterface* ob)
{
    m_obs.remove(ob);
}
</code></pre><p>protected:<br>    void notifyOb()<br>    {<br>        list<observerboardinterface*>::iterator pos = m_obs.begin();<br>        while (pos != m_obs.end())<br>        {<br>            ((ObserverBoardInterface<em> )(</em>pos))-&gt;update(m_humidity,m_temperature,m_pressure);<br>            (dynamic_cast<displayboardinterface*>(*pos))-&gt;show();<br>            ++pos;<br>        }<br>    }</displayboardinterface*></observerboardinterface*></p>
<p>private:<br>    float        m_humidity;<br>    float        m_temperature;<br>    float        m_pressure;<br>    list<observerboardinterface*> m_obs;<br>};</observerboardinterface*></p>
<p>// A Concrete Observer<br>class CurrentConditionBoard : public ObserverBoardInterface, public DisplayBoardInterface<br>{<br>public:<br>    CurrentConditionBoard(WeatherDataInterface&amp; a):m_data(a)<br>    {<br>        m_data.registerob(this);<br>    }<br>    void show()<br>    {<br>        cout&lt;&lt;”<strong>_</strong>CurrentConditionBoard<strong>_</strong>“&lt;&lt;endl;<br>        cout&lt;&lt;”humidity: “&lt;&lt;m_h&lt;&lt;endl;<br>        cout&lt;&lt;”temperature: “&lt;&lt;m_t&lt;&lt;endl;<br>        cout&lt;&lt;”pressure: “&lt;&lt;m<em>p&lt;&lt;endl;<br>        cout&lt;&lt;”<strong><strong><strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong></strong></strong></em>“&lt;&lt;endl;<br>    }</p>
<pre><code>void update(float h, float t, float p)
{
    m_h = h;
    m_t = t;
    m_p = p;
}
</code></pre><p>private:<br>    float m_h;<br>    float m_t;<br>    float m_p;<br>    WeatherDataInterface&amp; m_data;<br>};</p>
<p>// A Concrete Observer<br>class StatisticBoard : public ObserverBoardInterface, public DisplayBoardInterface<br>{<br>public:<br>    StatisticBoard(WeatherDataInterface&amp; a):m_maxt(-1000),m_mint(1000),m_avet(0),m_count(0),m_data(a)<br>    {<br>        m_data.registerob(this);<br>    }</p>
<pre><code>void show()
{
    cout&lt;&lt;&quot;________StatisticBoard_________&quot;&lt;&lt;endl;
    cout&lt;&lt;&quot;lowest  temperature: &quot;&lt;&lt;m_mint&lt;&lt;endl;
    cout&lt;&lt;&quot;highest temperature: &quot;&lt;&lt;m_maxt&lt;&lt;endl;
    cout&lt;&lt;&quot;average temperature: &quot;&lt;&lt;m_avet&lt;&lt;endl;
    cout&lt;&lt;&quot;_______________________________&quot;&lt;&lt;endl;
}

void update(float h, float t, float p)
{
    ++m_count;
    if (t&gt;m_maxt)
    {
        m_maxt = t;
    }
    if (t&lt;m_mint)
    {
        m_mint = t;
    }
    m_avet = (m_avet * (m_count-1) + t)/m_count;
}
</code></pre><p>private:<br>    float m_maxt;<br>    float  m_mint;<br>    float m_avet;<br>    int m_count;<br>    WeatherDataInterface&amp; m_data;<br>};</p>
<p>int main(int argc, char *argv[])<br>{</p>
<pre><code>ParaWeatherData * wdata = new ParaWeatherData;
CurrentConditionBoard* currentB = new CurrentConditionBoard(*wdata);
StatisticBoard* statisticB = new StatisticBoard(*wdata);

wdata-&gt;SensorDataChange(10.2, 28.2, 1001);
wdata-&gt;SensorDataChange(12, 30.12, 1003);
wdata-&gt;SensorDataChange(10.2, 26, 806);
wdata-&gt;SensorDataChange(10.3, 35.9, 900);

wdata-&gt;removeob(currentB);

wdata-&gt;SensorDataChange(100, 40, 1900);  

delete statisticB;
delete currentB;
delete wdata;

return 0;
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">将一个系统分割成一系列相互作用的类有个很不好的副作用，那就是需要维护相关对象间的一致性。我们不希望为了维持一致性而逝各类紧密耦合，这样会给维护，扩展和重用都带来不便。</div><div class="line"></div><div class="line">什么时候考虑使用观察者模式呢。</div><div class="line"></div><div class="line">***当一个对象的改变需要同事改变其它对象而且它不知道具体有多少对象有待改变时应该考虑使用观察者模式。***</div><div class="line"></div><div class="line">一个抽象模型有两个方面，其中一方面依赖于另一方面，这时用观察者模式可以将这两者防撞在独立的对象中使它们各自独立地改变和服用。</div><div class="line"></div><div class="line">***总的来讲，观察者模式所做的工作其实就是在解除耦合，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响另一个的变化。***</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"># 抽象工厂模式(Abstract factory Pattern)</div><div class="line">## 简介</div><div class="line">抽象工厂模式是一种软件开发设计模式。抽象工厂模式提供了一种方式，可以将一组具有同一主题的单独的工厂封装起来。在正常使用中，客户端程序需要创建抽象工厂的具体实现，然后使用抽象工厂作为接口来创建这一主题的具体对象。客户端程序不需要知道（或关心）它从这些内部的工厂方法中获得对象的具体类型，因为客户端程序仅使用这些对象的通用接口。抽象工厂模式将一组对象的实现细节与他们的一般使用分离开来。</div><div class="line"></div><div class="line">## 简例</div><div class="line">有个项目原来是依赖于access数据库，现在要用sqlserver，怎么更改呢(解耦)？</div><div class="line"></div><div class="line">### 用工厂方法模式的数据访问程序</div><div class="line"></div><div class="line">IUser接口，用于客户端访问，解除与具体数据库访问的耦合。</div></pre></td></tr></table></figure>
<p>interface IUser<br>{<br>    void Insert(User user);</p>
<pre><code>User GetUser(int id);
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Sqlserver类，用于访问SQL Server的User。</div></pre></td></tr></table></figure></p>
<p>class SqlserverUser : IUser<br>{<br>    public void Insert(User user)<br>    {<br>        Console.WriteLine(“在SQL Server中给User表增加一条记录”);<br>    }</p>
<pre><code>public User GetUser(int id)
{
    Console.WriteLine(&quot;在SQL Server中给User表获取一条记录&quot;);
    return null;
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">AccessUser类，用于访问Access的User。</div></pre></td></tr></table></figure></p>
<p>class AccessUser : IUser<br>{<br>    public void Insert(User user)<br>    {<br>        Console.WriteLine(“在access中给User表增加一条记录”);<br>    }</p>
<pre><code>public User GetUser(int id)
{
    Console.WriteLine(&quot;在access中给User表获取一条记录&quot;);
    return null;
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">IFactory接口，定义一个创建访问User表对象的抽象的工厂接口。</div></pre></td></tr></table></figure></p>
<p>interface Ifactory<br>{<br>    IUser CreateUser();<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">sqlServerFactory类，实现IFactory接口，实例化SqlserverUser。</div></pre></td></tr></table></figure></p>
<p>class sqlServerFactory:  IFactory<br>{<br>    public IUser CreateUser()<br>    {<br>        return new SqlserverUser();<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">AccessFactory类，实现IFactory接口，实例化AccessUser.</div></pre></td></tr></table></figure></p>
<p>class AccessFactory:  IFactory<br>{<br>    public IUser CreateUser()<br>    {<br>        return new AccessUser();<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">客户端代码</div></pre></td></tr></table></figure></p>
<p>static void main(string[] args)<br>{<br>    User user = new User();</p>
<pre><code>IFactory factory = new SqlServerFactory();

IUser iu = factory.CreateUser();

iu.Insert(user);
iu.GetUser(1);
Console.Read();
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">但是数据里面不可能只有一个User表，比如说增加部门表，此时怎么办呢。</div><div class="line"></div><div class="line">### 抽象工厂类</div><div class="line"></div><div class="line">IUser接口，用于客户端访问，解除与具体数据库访问的耦合。</div></pre></td></tr></table></figure></p>
<p>interface IDepartment<br>{<br>    void Insert(Department department);<br>    Department GetDepartment(int id);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SqlserverDepartment类，用于访问SQL Server的Department。</div></pre></td></tr></table></figure></p>
<p>class SqlserverDepartment : IDepartment<br>{<br>    public void Insert(Department department)<br>    {<br>        Console.WriteLine(“在SQL Server中给Department表增加一条记录”);<br>    }</p>
<pre><code>public Department GetDepartment(int id)
{
    Console.WriteLine(&quot;在SQL Server中给Department表获取一条记录&quot;);
    return null;
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">AccessDepartment类，用于访问Access的Department。</div></pre></td></tr></table></figure></p>
<p>class AccessDepartment : IDepartment<br>{<br>    public void Insert(Department department)<br>    {<br>        Console.WriteLine(“在Access中给Department表增加一条记录”);<br>    }</p>
<pre><code>public Department GetDepartment(int id)
{
    Console.WriteLine(&quot;在Access中给Department表获取一条记录&quot;);
    return null;
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">***</div></pre></td></tr></table></figure></p>
<p>interface IUser<br>{<br>    void Insert(User user);</p>
<pre><code>User GetUser(int id);
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Sqlserver类，用于访问SQL Server的User。</div></pre></td></tr></table></figure></p>
<p>class SqlserverUser : IUser<br>{<br>    public void Insert(User user)<br>    {<br>        Console.WriteLine(“在SQL Server中给User表增加一条记录”);<br>    }</p>
<pre><code>public User GetUser(int id)
{
    Console.WriteLine(&quot;在SQL Server中给User表获取一条记录&quot;);
    return null;
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">AccessUser类，用于访问Access的User。</div></pre></td></tr></table></figure></p>
<p>class AccessUser : IUser<br>{<br>    public void Insert(User user)<br>    {<br>        Console.WriteLine(“在access中给User表增加一条记录”);<br>    }</p>
<pre><code>public User GetUser(int id)
{
    Console.WriteLine(&quot;在access中给User表获取一条记录&quot;);
    return null;
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">IFactory接口，定义一个创建访问User表对象的抽象的工厂接口。</div></pre></td></tr></table></figure></p>
<p>interface Ifactory<br>{<br>    IUser CreateUser();</p>
<pre><code>IDepartment CreateDepartment();
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">sqlServerFactory类，实现IFactory接口，实例化SqlserverUser。</div></pre></td></tr></table></figure></p>
<p>class sqlServerFactory:  IFactory<br>{<br>    public IUser CreateUser()<br>    {<br>        return new SqlserverUser();<br>    }</p>
<pre><code>public IDepartment CreateDepartment()
{
    return new SqlserverDepartment();
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">AccessFactory类，实现IFactory接口，实例化AccessUser.</div></pre></td></tr></table></figure></p>
<p>class AccessFactory:  IFactory<br>{<br>    public IUser CreateUser()<br>    {<br>        return new AccessUser();<br>    }</p>
<pre><code>public IDepartment CreateDepartment()
{
    return new AccessDepartment();
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">客户端代码</div></pre></td></tr></table></figure></p>
<p>static void main(string[] args)<br>{<br>    User user = new User();</p>
<pre><code>IFactory factory = new SqlServerFactory();

IUser iu = factory.CreateUser();

iu.Insert(user);
iu.GetUser(1);
Console.Read();
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">抽象工厂模式：提供一个创建一系列相关或者相互依赖的对象的接口，而无需指定它们具体的类。</div><div class="line"></div><div class="line">### 用简单工厂来改进抽象工厂</div></pre></td></tr></table></figure></p>
<p>class DataAccess<br>{<br>    private static readonly string db = “Sqlserver”;<br>    //    private static readonly string db = “access”;</p>
<pre><code>public static IUser CreateUser()
{
    IUser result = null;

    switch (db)
    {
        case:&quot;Sqlserver&quot;:
            result = new SqlserverUser();
            break;
        case:&quot;Acesss&quot;:
            result = new AcesssUser();
            break;
    }
    return result;
}

publci static IDepartment CreateDepartment()
{
    IDepartment result = null;
            switch (db)
    {
        case:&quot;Sqlserver&quot;:
            result = new SqlserverDepartment();
            break;
        case:&quot;Acesss&quot;:
            result = new AcesssDepartment();
            break;
    }
    return result;
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">客户端代码</div></pre></td></tr></table></figure></p>
<p>static void Main(string[] args)<br>{<br>    User user = new User();<br>    Department dept = new Department();</p>
<pre><code>IUser iu = DataAccess.createUser();
iu.Insert(user);
iu.GetUser(1);

IDepartment id = DataAccess.createDepartment();
id.Inert(dept);
id.GetDepartment(1);

Console.Read();
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">利用反射或者配置文件都可以减少在所有简单工厂的switch和if，解除分支判断带来的耦合。</div><div class="line"></div><div class="line"></div><div class="line">“工厂”是创建产品（对象）的地方，其目的是将产品的创建与产品的使用分离。抽象工厂模式的目的，是将若干抽象产品的接口与不同主题产品的具体实现分离开。这样就能在增加新的具体工厂的时候，不用修改引用抽象工厂的客户端代码。</div><div class="line"></div><div class="line">使用抽象工厂模式，能够在具体工厂变化的时候，不用修改使用工厂的客户端代码，甚至是在运行时。然而，使用这种模式或者相似的设计模式，可能给编写代码带来不必要的复杂性和额外的工作。正确使用设计模式能够抵消这样的“额外工作”。</div><div class="line"></div><div class="line"></div><div class="line">## 从NSArray看类簇</div><div class="line">Class Clusters（类簇）是抽象工厂模式在iOS下的一种实现，众多常用类，如NSString，NSArray，NSDictionary，NSNumber都运作在这一模式下，它是接口简单性和扩展性的权衡体现，在我们完全不知情的情况下，偷偷隐藏了很多具体的实现类，只暴露出简单的接口。</div><div class="line"></div><div class="line">虽然官方文档中拿NSNumber说事儿，但Foundation并没有像图中描述的那样为每个number都弄一个子类，于是研究下NSArray类簇的实现方式。</div><div class="line"></div><div class="line">### __NSPlacehodlerArray</div><div class="line">熟悉这个模式的同学很可能看过下面的测试代码，将原有的alloc+init拆开写：</div></pre></td></tr></table></figure></p>
<p>id obj1 = [NSArray alloc]; // <strong>NSPlacehodlerArray *<br>id obj2 = [NSMutableArray alloc];  // </strong>NSPlacehodlerArray <em><br>id obj3 = [obj1 init];  // __NSArrayI </em><br>id obj4 = [obj2 init];  // __NSArrayM *<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">发现+ alloc后并非生成了我们期望的类实例，而是一个__NSPlacehodlerArray的中间对象，后面的- init或- initWithXXXXX消息都是发送给这个中间对象，再由它做工厂，生成真的对象。这里的__NSArrayI和__NSArrayM分别对应Immutable和Mutable（后面的I和M的意思）</div><div class="line"></div><div class="line">于是顺着思路猜实现，__NSPlacehodlerArray必定用某种方式存储了它是由谁alloc出来的这个信息，才能在init的时候知道要创建的是可变数组还是不可变数组</div><div class="line"></div><div class="line">经过研究发现，Foundation用了一个很贱的比较静态实例地址方式来实现，伪代码如下：</div></pre></td></tr></table></figure></p>
<p>static <strong>NSPlacehodlerArray *GetPlaceholderForNSArray() {<br>    static </strong>NSPlacehodlerArray *instanceForNSArray;<br>    if (!instanceForNSArray) {<br>        instanceForNSArray = [[__NSPlacehodlerArray alloc] init];<br>    }<br>    return instanceForNSArray;<br>}</p>
<p>static <strong>NSPlacehodlerArray *GetPlaceholderForNSMutableArray() {<br>    static </strong>NSPlacehodlerArray *instanceForNSMutableArray;<br>    if (!instanceForNSMutableArray) {<br>        instanceForNSMutableArray = [[__NSPlacehodlerArray alloc] init];<br>    }<br>    return instanceForNSMutableArray;<br>}<br>// NSArray实现</p>
<ul>
<li>(id)alloc {<br>  if (self == [NSArray class]) {<pre><code>return GetPlaceholderForNSArray()
</code></pre>  }<br>}<br>// NSMutableArray实现</li>
<li>(id)alloc {<br>  if (self == [NSMutableArray class]) {<pre><code>return GetPlaceholderForNSMutableArray()
</code></pre>  }<br>}<br>// __NSPlacehodlerArray实现</li>
</ul>
<ul>
<li>(id)init {<br>  if (self == GetPlaceholderForNSArray()) {<pre><code>self = [[__NSArrayI alloc] init];
</code></pre>  }<br>  else if (self == GetPlaceholderForNSMutableArray()) {<pre><code>self = [[__NSArrayM alloc] init];
</code></pre>  }<br>  return self;<br>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Foundation不是开源的，所以上面的代码是猜测的，思路大概就是这样，可以这样验证下：</div></pre></td></tr></table></figure>
</li>
</ul>
<p>id obj1 = [NSArray alloc];<br>id obj2 = [NSArray alloc];<br>id obj3 = [NSMutableArray alloc];<br>id obj4 = [NSMutableArray alloc];<br>// 1和2地址相同，3和4地址相同，无论多少次都相同，且地址相差16位<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"># 状态模式(State Pattern)</div><div class="line">## 简介</div><div class="line">状态模式，当一个对象在内在状态改变时，允许改变起行为，这个对象看起来像是改变了其类。</div><div class="line"></div><div class="line">状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂的情况。把状态的判断逻辑转移到表示不同状态的一系列类中，可以把复杂的判断逻辑简化。</div><div class="line"></div><div class="line">## 简例</div><div class="line"></div><div class="line">### 工作状态－分类板</div></pre></td></tr></table></figure></p>
<p>public class Work<br>{<br>    private int hour;<br>    public int Hour<br>    {<br>        get {return hour;}<br>        set {hour = value;}<br>    }</p>
<pre><code>private bool finish = false;
public bool TaskFinished
{
    get {return finish;}
    set { finish = value;}
}

public void WriteProgram()
{

    if (hour &lt; 12)
    {
        Console.WriteLine(&quot;当前时间:{0}点，上午&quot;，hour);
    } else if (hour &lt; 13)
    {
        Console.WriteLine(&quot;当前时间:{0}点，午饭&quot;，hour);
    } else if (hour &lt; 17) 
    {
        Console.WriteLine(&quot;当前时间:{0}点，下午&quot;，hour);
    } else {
        if (finish) {
        Console.WriteLine(&quot;当前时间:{0}点，下班回家&quot;，hour);
        } else {
            if (hour &lt; 21)
            {
                Console.WriteLine(&quot;当前时间:{0}点，加班哦，疲累之极&quot;，hour);
            } else {
                Console.WriteLine(&quot;当前时间:{0}点，不行了，睡着了&quot;，hour);
            }
        }
    }
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">客户端程序如下</div></pre></td></tr></table></figure></p>
<p>static void Main(string[[] args)<br>{<br>    //紧急项目<br>    Work emergencyProjects = new Work();<br>    emergencyProjects.Hour = 9;<br>    emergencyProjects.WriteProgram();<br>    emergencyProjects.Hour = 10;<br>    emergencyProjects.WriteProgram();<br>    emergencyProjects.Hour = 12;<br>    emergencyProjects.WriteProgram();<br>    emergencyProjects.Hour = 13;<br>    emergencyProjects.WriteProgram();<br>    emergencyProjects.Hour = 14;<br>    emergencyProjects.WriteProgram();<br>    emergencyProjects.Hour = 17;<br>    emergencyProjects.WriteProgram();    </p>
<pre><code>//emergencyProjects.WorkFinished = true;
emergencyProjects.TaskFinished = false;

emergencyProjects.WriteProgram();
emergencyProjects.Hour = 19;
emergencyProjects.WriteProgram();
emergencyProjects.Hour = 22;
emergencyProjects.WriteProgram();    

Console.Read();
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">### 结果</div><div class="line">此段代码有很大的问题。MartinFowler曾在《重构》中写过一个很重要的代码味道，叫做&apos;Long Method&apos;,方法如果过长其实极有可能有坏味道了。</div><div class="line"></div><div class="line">&apos;Work&apos;类的&apos;WriteProgram&apos;方法很长，而且有很多判断的分支，这也就意味着它的责任过大了。无论是任何状态，都需要通过它来改变，这实际上是很糟糕的。</div><div class="line"></div><div class="line">***面对对象设计其实就是希望做到代码的责任分解。***这个类违背了&apos;单一职责原则&apos;。而且由于&apos;WriteProgram&apos;的方法里面有这么多判断，使得任何需求的改动或增加，都需要更改这个方法。又违背了&apos;开放－封闭原则&apos;。这类有个解决方案，就是&apos;状态模式&apos;。</div><div class="line"></div><div class="line">***状态模式的好处是将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。***</div><div class="line"></div><div class="line">***将特定的状态相关的行为都放入一个对象中，由于所有与状态相关的代码都存在于摸个ConcreteState中，所以通过定义新的字类可以很容易地增加新的状态与转换。这样做的目的就是为了消除庞大的条件分支语句。状态模式通过把各种状态转移逻辑分布到State的子类之间，来减少相互间的依赖。***</div><div class="line"></div><div class="line">***当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为时，就可以考虑使用状态模式了。***</div><div class="line">	</div><div class="line">	</div><div class="line">	</div><div class="line">### 工作状态－状态模式板</div></pre></td></tr></table></figure></p>
<p>//抽象状态</p>
<p>public abstract class State<br>{<br>    public abstract void WriteProgram(Work w);<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">上午工作状态</div></pre></td></tr></table></figure>
<p>public class ForenoonState: State<br>{<br>    public override void WriteProgram (Work w)<br>    {<br>        if (w.hour &lt; 12)<br>        {<br>            Console.WriteLine(“当前时间:{0}点 上午”，w.Hour);<br>        } else<br>        {<br>            w.SetState(new NoonState());<br>            w.WriteProgram();<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">中午工作状态</div></pre></td></tr></table></figure></p>
<p>public class NoonState: State<br>{<br>    public override void WriteProgram (Work w)<br>    {<br>        if (w.hour &lt; 13)<br>        {<br>            Console.WriteLine(“当前时间:{0}点 中午”，w.Hour);<br>        } else<br>        {<br>            w.SetState(new AfterNoonState());<br>            w.WriteProgram();<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">下午工作状态</div></pre></td></tr></table></figure></p>
<p>public class AfterNoonState: State<br>{<br>    public override void WriteProgram (Work w)<br>    {<br>        if (w.hour &lt; 13)<br>        {<br>            Console.WriteLine(“当前时间:{0}点 下午”，w.Hour);<br>        } else<br>        {<br>            w.SetState(new EveningState());<br>            w.WriteProgram();<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">晚间工作状态</div></pre></td></tr></table></figure></p>
<p>public class EveningState: State<br>{<br>    public override void WriteProgram (Work w)<br>    {<br>        if (w.TaskFinished)<br>        {<br>            w.SetState(new RestState());<br>            w.WriteProgeam();<br>        } else<br>        {<br>            if (w.Hour &lt; 21)<br>            {<br>                Console.WriteLine(“当前时间:{0}点 加班哦，疲累”，w.Hour);<br>            } else<br>            {<br>                w.SetState(new SleepState());<br>                w.WriteProgram();<br>            }</p>
<pre><code>    }

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">睡眠状态</div></pre></td></tr></table></figure></p>
<p>public class SleepingState: State<br>{<br>    public override void WriteProgram (Work w)<br>    {<br>        if (w.hour &lt; 13)<br>        {<br>                Console.WriteLine(“当前时间:{0}点 不行了，睡着了。”，w.Hour);<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">下班休息状态</div></pre></td></tr></table></figure></p>
<p>public class RestState: State<br>{<br>    public override void WriteProgram(Work w)<br>    {<br>        Console.WriteLine(“当前时间:{0}点 下班回家了。”，w.Hour);<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">工作类，此时没有了过长的分支判断语句</div></pre></td></tr></table></figure></p>
<p>public class Work<br>{<br>    private State current;<br>    public Work()<br>    {<br>        current = new ForenoonState();<br>    }</p>
<pre><code>private double hour;
public double Hour
{
    get {return hour;}
    set {hour = value;}
}

private bool finish = false;
public bool TaskFinshed
{
    get { return finsh;}
    set { finished = value;}
}

public void SetState(State s)
{
    current = s;
}

public void WriteProgram()
{
    current.WriteProgram(this);
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">客户端代码，没有任何改动。但我们的程序却更加灵活易变了。</div></pre></td></tr></table></figure></p>
<p>static void Main(string[[] args)<br>{<br>    //紧急项目<br>    Work emergencyProjects = new Work();<br>    emergencyProjects.Hour = 9;<br>    emergencyProjects.WriteProgram();<br>    emergencyProjects.Hour = 10;<br>    emergencyProjects.WriteProgram();<br>    emergencyProjects.Hour = 12;<br>    emergencyProjects.WriteProgram();<br>    emergencyProjects.Hour = 13;<br>    emergencyProjects.WriteProgram();<br>    emergencyProjects.Hour = 14;<br>    emergencyProjects.WriteProgram();<br>    emergencyProjects.Hour = 17;<br>    emergencyProjects.WriteProgram();    </p>
<pre><code>//emergencyProjects.WorkFinished = true;
emergencyProjects.TaskFinished = false;

emergencyProjects.WriteProgram();
emergencyProjects.Hour = 19;
emergencyProjects.WriteProgram();
emergencyProjects.Hour = 22;
emergencyProjects.WriteProgram();    

Console.Read();
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 总结与分析</div><div class="line"></div><div class="line">  状态模式的主要优点在于封装了转换规则，并枚举可能的状态，它将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为，还可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数；其缺点在于使用状态模式会增加系统类和对象的个数，且状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，对于可以切换状态的状态模式不满足“开闭原则”的要求。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"># 适配器模式(Adapter Pattern)</div><div class="line">## 简介</div><div class="line">在设计模式中，适配器模式有时候也称包装样式或者包装(wrapper)。将一个类的接口转接成用户所期待的。一个适配使得因接口不兼容而不能在一起工作的类工作在一起，做法是将类自己的接口包裹在一个已存在的类中。</div><div class="line"></div><div class="line">适配器模式包含两种，一种是类适配器，另一种是对象适配器。`类适配器`是通过类的继承实现的适配，而`对象适配器`是通过对象间的关联关系，组合关系实现的适配。二者在实际项目中都会经常用到，由于对象适配器是通过类间的关联关系进行耦合的，因此在设计时就可以做到比较灵活，而类适配器就只能通过覆写源角色的方法进行拓展，在实际项目中，对象适配器使用到的场景相对较多。在iOS开发中也推荐多使用组合关系，而尽量减少继承关系，这是一种很好的编程习惯，因此我在这里只介绍对象适配器，想了解更多的关于类适配器的话，请自行Google之。</div></pre></td></tr></table></figure></p>
<p>Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces.<br>将一个类的接口变成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 简例</div><div class="line"></div><div class="line">### 适配器模式说明</div><div class="line"></div><div class="line">* Target目标角色 该角色定义把其他类转换为何种接口，也就是我们的期望接口。</div><div class="line">* Adaptee源角色 你想把“谁”转换成目标角色，这个“谁”就是源角色，它是已经存在的、运行良好的类或对象。</div><div class="line">* Adapter适配器角色 适配器模式的核心角色，其他两个角色都是已经存在的角色，而适配器角色是需要新建立的，他的职责非常简单：把源角色转换为目标角色。</div><div class="line"></div><div class="line">### 适配器模式优点</div><div class="line"></div><div class="line">* 适配器模式可以让两个没有任何关系的类在一起运行，只要适配器这个角色能够搞定他们就成。</div><div class="line">* 增加了类的透明性。我们访问的是目标角色，但是实现却在源角色里。</div><div class="line">* 提高了类的复用度。源角色在原有系统中还是可以正常使用的。</div><div class="line">* 灵活性非常好。不想要适配器时，删掉这个适配器就好了，其他代码不用改。</div><div class="line"></div><div class="line"></div><div class="line">Target</div></pre></td></tr></table></figure></p>
<p>#import <foundation foundation.h=""></foundation></p>
<p>@protocol Target <nsobject></nsobject></p>
<ul>
<li>(void)userExpectInterface;</li>
</ul>
<p>@end<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Adaptee</div></pre></td></tr></table></figure></p>
<p>#import <foundation foundation.h=""></foundation></p>
<p>@interface Adaptee : NSObject</p>
<ul>
<li>(void)doSometing;</li>
</ul>
<p>@end</p>
<p>@implementation Adaptee</p>
<ul>
<li>(void)doSometing<br>{<br>  NSLog(@”adaptee doing something!”);<br>}</li>
</ul>
<p>@end<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Adapter</div></pre></td></tr></table></figure></p>
<p>#import “Target.h”</p>
<p>#import “Adaptee.h”</p>
<p>@interface Adapter : NSObject<target></target></p>
<p>@property (strong, nonatomic) Adaptee *adaptee;</p>
<ul>
<li>(id)initWithAdaptee:(Adaptee *)adaptee;</li>
</ul>
<p>@end</p>
<p>@implementation Adapter</p>
<p>@synthesize adaptee = _adaptee;</p>
<ul>
<li><p>(id)initWithAdaptee:(Adaptee *)adaptee<br>{<br>  if (self = [super init]) {</p>
<pre><code>_adaptee = adaptee;
</code></pre><p>  }<br>  return self;<br>}</p>
</li>
<li><p>(void)userExpectInterface<br>{<br>  [self.adaptee doSometing];<br>}</p>
</li>
</ul>
<p>@end<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">main</div></pre></td></tr></table></figure></p>
<p>#import <foundation foundation.h=""></foundation></p>
<p>#import “Adapter.h”</p>
<p>#import “Adaptee.h”</p>
<p>#import “Target.h”</p>
<p>int main(int argc, const char * argv[])<br>{</p>
<pre><code>@autoreleasepool {

    Adaptee *adaptee = [[Adaptee alloc]init];
    id&lt;Target&gt; object = [[Adapter alloc]initWithAdaptee:adaptee];

    [object userExpectInterface];

}
return 0;
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">何时用适配器模式？两个类所做的事情相同或者相似，但是具有不同的接口时要使用它。 客户端代码可以统一调用接口就行了，这样应该可以更简单，更直接，更紧凑。***在双方都不太容易修改的时候再食用适配器模式适配。***</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"># 备忘录模式(Memento Pattern)</div><div class="line">## 简介</div><div class="line"></div><div class="line"></div><div class="line">备忘录模式有两个目标：</div><div class="line"></div><div class="line">* 储存系统关键对象的重要状态；</div><div class="line">* 维护关键对象的封装。</div><div class="line"></div><div class="line">单一职责原则告诉我们，设计时不要把保持状态的工作和关键对象混在一起。这个专门掌握状态的对象，就称为备忘录。</div><div class="line"></div><div class="line">备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用存储起来的备忘录将状态复原，当前很多软件都提供了Undo（撤销）操作功能，就使用了备忘录模式。 </div><div class="line"></div><div class="line">![</div><div class="line">][9]</div><div class="line"></div><div class="line">Originator(发起人)：负责创建一个备忘录Memeto，用以记录当前时刻它的内部状态，并可以使用备忘录恢复内部状态。Originator可根据需要决定Memento储存Originator的哪些状态。</div><div class="line"></div><div class="line">Memeto(备忘录)：负责存储Originator对象的内部状态，并可防止Originator意外的其它对象访问备忘录Memeto。备忘录有两个接口，Creataker只能看到备忘录的窄接口，它只能将备忘录传递给其它对象。Originator只能看到一个窄接口，允许它访问返回到先前状态所需的所有数据。</div><div class="line"></div><div class="line">Caretaker(管理者)：负责保存好备忘录Memeto，不能对备忘录的内容进行操作或检查。</div><div class="line"></div><div class="line">发起人(Originator)类</div></pre></td></tr></table></figure></p>
<p>class Originator<br>{<br>    private string state;<br>    public string State<br>    {<br>        get {return state;}<br>        set {state = value;}<br>    }</p>
<pre><code>public Memnto CreateMemento()
{
    return (new Memeto(state));
}
public void SetMemento(Memento memento)
{
    state = memento.state
}
public void show()
{
    Console.WriteLine(&quot;State=&quot;+ state);
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">备忘录(Memento)类</div></pre></td></tr></table></figure></p>
<p>class Memento<br>{<br>    private string state;<br>    public Memento(string state)<br>    {<br>        this.state = state;<br>    }<br>    public string State<br>    {<br>        get {return state;}<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">管理者(Caretaker)类</div></pre></td></tr></table></figure></p>
<p>class Caretaker<br>{<br>    private Memento memento;</p>
<pre><code>public Memento Memento
{
    get {return memento;}
    set {memento = value;}
}    
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">客户端程序</div></pre></td></tr></table></figure></p>
<p>static void Main(string[] args)<br>{<br>    Originator o = new Originator();<br>    o.State = “On”;<br>    o.show();</p>
<pre><code>Caretaker c = new Caretaker();
c.Memento = o.CreateMemento();

o.State = &quot;Off&quot;;
o.Show();

o.SetMemento(c.Memento);
o.Show();

Console.Read();
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Memento模式比较适用于功能比较复杂的，但是需要维护或者纪录属性历史的类，或者需要保存的属性只是众多属性中的一小部分时，Originator可以根据保存的Memento信息还原到前一状态。</div><div class="line"></div><div class="line">如果在某个系统中使用命令模式时，需要实现命令的撤销功能，那么命令模式可以使用备忘录模式来储存可撤销操作的状态。</div><div class="line"></div><div class="line">当角色状态改变的时候，有可能这个状态无效，这时候就可以使用暂时存储起来的备忘录将状态复原。</div><div class="line"></div><div class="line">游戏角色类</div></pre></td></tr></table></figure></p>
<p>class 游戏角色<br>{<br>    ……</p>
<pre><code>//保存角色状态
public RoleStateMemento SaveState()
{
    return (new RoleStateMemento(vit, atk, def));
}

//恢复角色状态
public void RecoveryState(RoleStateMemento memento)
{
    this.vit = memento.Vitality;
    this.atk = memento.Attack;
    this.def = memento.Defense;
}
......
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">角色状态储存箱类</div></pre></td></tr></table></figure></p>
<p>class RoleStateMemento<br>{<br>    private int vit;<br>    private int atk;<br>    private int def;<br>    public RoleStateMemento(int vit, int atk, int def)<br>    {<br>        this.vit = vit;<br>        this.atk = atk;<br>        this.def = def;<br>    }<br>    //生命力<br>    public int Vtality<br>    {<br>        get {return vit;}<br>        set {vit = value;}<br>    }<br>    //攻击力<br>    public int Attack<br>    {<br>        get {return atk;}<br>        set {vit = value;}<br>    }<br>    //防御力<br>    public int Defense<br>    {<br>        get {return def;}<br>        set {def = value;}<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">角色状态管理者</div></pre></td></tr></table></figure></p>
<p>class RoleStateCaretaker<br>{<br>    private RoleStateMemeto memento;</p>
<pre><code>public RoleStateMemento Memento
{
    get {return memento;}
    set {memento = value;}
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">客户端代码</div></pre></td></tr></table></figure></p>
<p>static void Main(string[] args)<br>{<br>    //大战Boss前<br>    GameRole lixiaoyao = new GameRole();<br>    lixiaoyao.GetInitState();<br>    lixiaoyao.StateDisplay();</p>
<pre><code>//保存进度
RoleStateCaretaker stateAdmin = new RoleStateCaretaker();
stateAdmin.memento = lixiaoyao.SaveState();

//大战Boss时，损耗严重
lixiaoyao.Fight();
lixiaoyao.StateDisplay();

//恢复之前状态
lixiaoyao.RecoveryState(stateAdmin.Memento);
lixiaoyao.StateDisplay();

Console.Read();
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># 组合模式(Composite Pattern)</div><div class="line"></div><div class="line">## 简介</div><div class="line">有个项目，是为一家在全国许多城市都有分销机构的大公司做办公管理系统，总部有人力资源，财务，运营等部门。但是总公司的人力资源部，财务部等办公管理功能在所有的分公司或办事处都需要有。我们可能希望人力资源部，财务部的管理功能可以复用于分公司。这其实就是整体与部分可以被一致对待的问题。</div><div class="line"></div><div class="line">***组合模式:将对象组合成树形结构以表示&apos;部分-整体&apos;的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。***</div><div class="line"></div><div class="line">***当你发现需求中是体现部分与整体层次的结构时，以及你希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑使用组合模式了。***</div><div class="line"></div><div class="line">### 公司管理系统</div><div class="line"></div><div class="line">公司类，抽象类或接口</div></pre></td></tr></table></figure></p>
<p>abstract class Company<br>{<br>    protected string name;</p>
<pre><code>public Company(string name)
{
    this.name = name;
}
public abstract void Add(Company c);//增加
public abstract void Remove(Company c);//移除
public abstract void Display(Company c);//显示    public abstract void LineOfDuty(Company c);//履行职责
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">具体公司类 实现接口树枝节点</div></pre></td></tr></table></figure></p>
<p>class ConcreteCompany: Company<br>{<br>    private List<company>children = new List<company>();</company></company></p>
<pre><code>public ConcreteCompany(string name)
{
    : base(name);
}

public override void Add(Company c)
{
    children.Add(c);
}
public override void Remove(Company c)
{
    children. Remove(c);
}
public override void Display(int depth)
{
    Console.WriteLine(new string(&apos;-&apos;, depth) + name);

    foreach(Company component in children)
    {
        component.Display(depth + 2);
    }
}    

public override void LineOfDuty()
{
    foreach(Company component in children)
    {
        component.LineofDuty();
    }
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">人力资源部与财务部类 树叶节点</div></pre></td></tr></table></figure></p>
<p>class HRDepartment: Company<br>{<br>    public HRDepartment(string name)<br>    {<br>        : base(name);<br>    }</p>
<pre><code>public override void Add(Company c)
{}

public override void Remove(Company c)
{}

public override void Display(int depth)
{
    Console.WriteLine(new string(&apos;-&apos;, depth) + name);
}

public override void LineOfDuty()
{
    Console.WriteLine(&quot;{0} 员工招聘培训管理&quot;，name);
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">财务部</div></pre></td></tr></table></figure></p>
<p>class FinanceDepartment: Company<br>{<br>    public FinanceDepartment(string name)<br>    {<br>        : base(name);<br>    }</p>
<pre><code>public override void Add(Company c)
{}

public override void Remove(Company c)
{}

public override void Display(int depth)
{
    Console.WriteLine(new string(&apos;-&apos;, depth) + name);
}

public override void LineOfDuty()
{
    Console.WriteLine(&quot;{0} 公司财务收支管理&quot;，name);
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">客户端调用</div></pre></td></tr></table></figure></p>
<p>static void Main(string[] args)<br>{<br>    ConcreteCompany root = new ConcreteCompany(“北京总公司”);<br>    root.Add(new HRDepartment(“总公司人力资源部”));<br>    root.Add(new FinanceDepartment(“总公司财务部”));</p>
<pre><code>ConcreteCompany comp = new ConcreteCompany(&quot;上海华东分公司&quot;);
comp.Add(new HRDepartment(&quot;总公司人力资源部&quot;));
comp.Add(new FinanceDepartment(&quot;总公司财务部&quot;));
root.Add(comp);

    ConcreteCompany comp1 = new ConcreteCompany(&quot;南京办事处&quot;);
comp1.Add(new HRDepartment(&quot;南京办事处人力资源部&quot;));
comp1.Add(new FinanceDepartment(&quot;南京办事处财务部&quot;));
comp.Add(comp1);

root.Display(1);
root.LineOfDuty();
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 透明方式与安全方式</div><div class="line"></div><div class="line">透明方式，也就是说在Component中声明所有用来管理子对象的方法，其中包括Add,Remove等。这样实现Component接口的所有子类都具备了Add和RFemove。这样做的好处就是叶节点和枝节点对于外界没有区别，它们具备完全一致的行为接口。但是问题也很明显，因为Leaf类本身不具备Add(),Remove()方法的功能，所以实现也是没意义的。</div><div class="line"></div><div class="line">安全方式，也就是在Component接口中不去声明Add和Remove方法，那么字类的Leaf也不需要实现它，而是在Composite声明所有用来管理字类对象的方法。不过由于不透明，所以树枝类和树叶不具有相同的接口，客户端的调用需要做相应的判断，带来了不便。</div><div class="line"></div><div class="line"></div><div class="line">***组合模式有时候又叫做部分-整体模式，它使我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素,从而使得客户程序与复杂元素的内部结构解耦。***</div><div class="line"></div><div class="line"></div><div class="line"># 单例模式(Singleton Pattern)</div><div class="line"></div><div class="line">## 简介</div><div class="line">单例模式，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。</div><div class="line"></div><div class="line">实现单例模式的思路是：一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。</div><div class="line"></div><div class="line">单例模式在多线程的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(虽然这样会降低效率)</div><div class="line"></div><div class="line">JAVA的单例实现</div></pre></td></tr></table></figure></p>
<p>  public class Singleton {<br>    private static volatile Singleton INSTANCE = null;</p>
<pre><code>// Private constructor suppresses 
// default public constructor
private Singleton() {}

//thread safe and performance  promote 
public static  Singleton getInstance() {
    if(INSTANCE == null){
         synchronized(Singleton.class){
             //when more than two threads run into the first null check same time, to avoid instanced more than one time, it needs to be checked again.
             if(INSTANCE == null){ 
                 INSTANCE = new Singleton();
              }
          } 
    }
    return INSTANCE;
}
</code></pre><p>  }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 避免单例的滥用</div><div class="line">单例模式固然好用，但感觉有点过度，将接口设计成单例入口前需要考虑一下：</div><div class="line"></div><div class="line">* 这个类表达的含义真的只能有一个实例么？（如UIApplication）还是只是为了好调用而已？</div><div class="line">* 这个单例持有的内存一直存在</div><div class="line">* 是否能用类方法代替？</div><div class="line">* 这个单例对象是否能成为另一个单例对象的属性？如果是，应该作为属性</div><div class="line"></div><div class="line"></div><div class="line">## 实例</div><div class="line">***单例模式:保证一个类仅有一个实例，并提供一个访问它的全局访问点。***</div><div class="line"></div><div class="line">单例是整个 Cocoa 中被广泛使用的核心设计模式之一。事实上，苹果开发者库把单例作为 &quot;Cocoa 核心竞争力&quot; 之一。作为一个iOS开发者，我们经常和单例打交道，比如 UIApplication 和 NSFileManager 等等。我们在开源项目、苹果示例代码和 StackOverflow 中见过了无数使用单例的例子。Xcode 甚至有一个默认的 &quot;Dispatch Once&quot; 代码片段，可以使我们非常简单地在代码中添加一个单例：</div></pre></td></tr></table></figure></p>
<ul>
<li>(instancetype)sharedInstance<br>{<br>  static dispatch_once_t once;<br>  static id sharedInstance;<br>  dispatch_once(&amp;once, ^{<pre><code>sharedInstance = [[self alloc] init];
</code></pre>  });<br>  return sharedInstance;<br>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">由于这些原因，单例在 iOS 开发中随处可见。问题是，它们很容易被滥用。</div><div class="line"></div><div class="line">尽管有些人认为单例是 &apos;反模式&apos;， &apos;魔鬼&apos; 以及 &apos;病态的说谎者&apos;，我不会去完全否认单例所带来的的好处，而是会展示一些使用单例所带来的问题，这样下一次在使用 dispatch_once 代码片段的自动补全功能时，你可以对它的影响进行评估，三思而行。</div><div class="line"></div><div class="line">### 全局状态</div><div class="line">大多数的开发者都认同使用全局可变的状态是不好的行为。太多状态使得程序难以理解，难以调试。我们这些面向对象的程序员在最小化代码的状态复杂程度的方面，有很多需要向函数式编程学习的地方。</div></pre></td></tr></table></figure>
</li>
</ul>
<p>@implementation SPMath {<br>    NSUInteger _a;<br>    NSUInteger _b;<br>}</p>
<ul>
<li>(NSUInteger)computeSum<br>{<br>  return _a + _b;<br>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">在上面这个简单的数学库的实现中，程序员需要在调用 `computeSum` 前正确的设置实例变量 `_a` 和 `_b`。这样有以下问题：</div><div class="line"></div><div class="line">* computeSum 没有显式地通过使用参数的形式声明它依赖于 _a 和 _b 的状态。与仅仅通过查看函数声明就可以知道这个函数的输出依赖于哪些变量不同的是，另一个开发者必须查看这个函数的具体实现才能明白这个函数依赖那些变量。隐藏依赖是不好的。</div><div class="line">* 当为调用 `computeSum` 做准备而修改 `_a` 和 `_b` 的数值时，程序员需要保证这些修改不会影响任何其他依赖于这两个变量的代码的正确性。而这在多线程的环境中是尤其困难的。</div><div class="line"></div><div class="line">把下面的代码和上面的例子做对比：</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>(NSUInteger)computeSumOf:(NSUInteger)a plus:(NSUInteger)b<br>{<br>  return a + b;<br>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这里，对变量 `a` 和 `b` 的依赖被显式地声明了。我们不需要为了调用这个方法而去改变实例变量的状态。并且我们也不需要担心调用这个函数会留下持久的副作用。我们甚至可以把这个方法声明为类方法，这样就告诉了代码的阅读者这个方法不会修改任何实例的状态。</div><div class="line"></div><div class="line">那么，这个例子和单例又有什么关系呢？用 Miško Hevery 的话来说，[单例就是披着羊皮的全局状态](http://misko.hevery.com/2008/08/25/root-cause-of-singletons/)。一个单例可以被使用在任何地方，而不需要显式地声明依赖。就像变量 `_a` 和 `_b` 在 `computeSum` 内部被使用了，却没有被显式声明一样，程序的任意模块都可以调用 `[SPMySingleton sharedInstance]` 并且访问这个单例。***这意味着任何和这个单例交互产生的副作用都会影响程序其他地方的任意代码。***</div></pre></td></tr></table></figure>
</li>
</ul>
<p>@interface SPSingleton : NSObject</p>
<ul>
<li>(instancetype)sharedInstance;</li>
</ul>
<ul>
<li>(NSUInteger)badMutableState;</li>
<li>(void)setBadMutableState:(NSUInteger)badMutableState;</li>
</ul>
<p>@end</p>
<p>@implementation SPConsumerA</p>
<ul>
<li>(void)someMethod<br>{<br>  if ([[SPSingleton sharedInstance] badMutableState]) {<pre><code>// ...
</code></pre>  }<br>}</li>
</ul>
<p>@end</p>
<p>@implementation SPConsumerB</p>
<ul>
<li>(void)someOtherMethod<br>{<br>  [[SPSingleton sharedInstance] setBadMutableState:0];<br>}</li>
</ul>
<p>@end<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">在上面的例子中，`SPConsumerA` 和 `SPConsumerB` 是两个完全独立的模块。但是 `SPConsumerB` 可以通过使用单例提供的共享状态来影响 `SPConsumerA` 的行为。这种情况应该只能发生在 `consumer B` 显式引用了 A，并表明了两者之间的关系时。这里使用了单例，由于其具有全局和多状态的特性，导致隐式地在两个看起来完全不相关的模块之间建立了耦合。</div><div class="line"></div><div class="line">让我们来看一个更具体的例子，并且暴露一个使用全局可变状态的额外问题。比如我们想要在我们的应用中构建一个网页查看器。为了支持这个查看器，我们构建了一个简单的 URL cache：</div></pre></td></tr></table></figure></p>
<p>@interface SPURLCache</p>
<ul>
<li>(SPCache *)sharedURLCache;</li>
</ul>
<ul>
<li>(void)storeCachedResponse:(NSCachedURLResponse <em>)cachedResponse forRequest:(NSURLRequest </em>)request;</li>
</ul>
<p>@end<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这个开发者开始写一些单元测试来保证代码在一些不同的情况下都能达到预期。首先，他写了一个测试用例来保证网页查看器在设备没有连接时能够展示出错误信息。然后他写了一个测试用例来保证网页查看器能够正确的处理服务器错误。最后，他为成功情况时写了一个测试用例，来保证返回的网络内容能够被正确的显示出来。这个开发者运行了所有的测试用例，并且它们都如预期一样正确。赞！</div><div class="line"></div><div class="line">几个月以后，这些测试用例开始出现失败，尽管网页查看器的代码从它写完后就从来没有再改动过！到底发生了什么？</div><div class="line"></div><div class="line">原来，有人改变了测试的顺序。处理成功的那个测试用例首先被运行，然后再运行其他两个。处理错误的那两个测试用例现在竟然成功了，和预期不一样，因为 URL cache 这个单例把不同测试用例之间的 response 缓存起来了。</div><div class="line"></div><div class="line">持久化状态是单元测试的敌人，因为单元测试在各个测试用例相互独立的情况下才有效。如果状态从一个测试用例传递到了另外一个，这样就和测试用例的执行顺序就有关系了。有 bug 的测试用例，尤其是那些本来不应该通过的测试用例，是非常糟糕的事情。</div><div class="line"></div><div class="line">### 对象的生命周期</div><div class="line"></div><div class="line">另外一个关键问题就是单例的生命周期。当你在程序中添加一个单例时，很容易会认为 “永远只会有一个实例”。但是在很多我看到过的 iOS 代码中，这种假定都可能被打破。</div><div class="line"></div><div class="line">比如，假设我们正在构建一个应用，在这个应用里用户可以看到他们的好友列表。他们的每个朋友都有一张个人信息的图片，并且我们想使我们的应用能够下载并且在设备上缓存这些图片。 使用 dispatch_once 代码片段，我们可以写一个 SPThumbnailCache 单例：</div></pre></td></tr></table></figure></p>
<p>@interface SPThumbnailCache : NSObject</p>
<ul>
<li>(instancetype)sharedThumbnailCache;</li>
</ul>
<ul>
<li>(void)cacheProfileImage:(NSData <em>)imageData forUserId:(NSString </em>)userId;</li>
<li>(NSData <em>)cachedProfileImageForUserId:(NSString </em>)userId;</li>
</ul>
<p>@end<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">我们继续构建我们的应用，一切看起来都很正常，直到有一天，我们决定去实现‘注销’功能，这样用户可以在应用中进行账号切换。突然我们发现我们将要面临一个讨厌的问题：用户相关的状态存储在全局单例中。当用户注销后，我们希望能够清理掉所有的硬盘上的持久化状态。否则，我们将会把这些被遗弃的数据残留在用户的设备上，浪费宝贵的硬盘空间。对于用户登出又登录了一个新的账号这种情况，我们也想能够对这个新用户使用一个全新的 SPThumbnailCache 实例。</div><div class="line"></div><div class="line">问题在于按照定义单例被认为是“创建一次，永久有效”的实例。你可以想到一些对于上述问题的解决方案。或许我们可以在用户登出时移除这个单例：</div></pre></td></tr></table></figure></p>
<p>static SPThumbnailCache *sharedThumbnailCache;</p>
<ul>
<li><p>(instancetype)sharedThumbnailCache<br>{<br>  if (!sharedThumbnailCache) {</p>
<pre><code>sharedThumbnailCache = [[self alloc] init];
</code></pre><p>  }<br>  return sharedThumbnailCache;<br>}</p>
</li>
<li><p>(void)tearDown<br>{<br>  // The SPThumbnailCache will clean up persistent states when deallocated<br>  sharedThumbnailCache = nil;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">这是一个明显的对单例模式的滥用，但是它可以工作，对吧？</div><div class="line"></div><div class="line">我们当然可以使用这种方式去解决，但是代价实在是太大了。我们不能使用简单的的 `dispatch_once` 方案了，而这个方案能够保证线程安全以及所有调用 `[SPThumbnailCache sharedThumbnailCache]` 的地方都能访问到同一个实例。现在我们需要对使用缩略图 cache 的代码的执行顺序非常小心。假设当用户正在执行登出操作时，有一些后台任务正在执行把图片保存到缓存中的操作:</div></pre></td></tr></table></figure>
</li>
</ul>
<p>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{<br>    [[SPThumbnailCache sharedThumbnailCache] cacheProfileImage:newImage forUserId:userId];<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">我们需要保证在所有的后台任务完成前， tearDown 一定不能被执行。这确保了 newImage 数据可以被正确的清理掉。或者，我们需要保证在缩略图 cache 被移除时，后台缓存任务一定要被取消掉。否则，一个新的缩略图 cache 的实例将会被延迟创建，并且之前用户的数据 (newImage 对象) 会被存储在它里面。</div><div class="line"></div><div class="line">由于对于单例实例来说它没有明确的所有者，(因为单例自己管理自己的生命周期)，“关闭”一个单例变得非常的困难。</div><div class="line"></div><div class="line">分析到这里，我希望你能够意识到，“这个缩略图 cache 从来就不应该作为一个单例！”。问题在于一个对象得生命周期可能在项目的最初阶段没有被很好得考虑清楚。举一个具体的例子，Dropbox 的 iOS 客户端曾经只支持一个账号登录。它以这样的状态存在了数年，直到有一天我们希望能够同时支持多个用户账号登录 (同时登陆私人账号和工作账号)。突然之间，我们以前的的假设“只能够同时有一个用户处于登录状态”就不成立了。如果假定了一个对象的生命周期和应用的生命周期一致，那你的代码的灵活扩展就受到了限制，早晚有一天当产品的需求产生变化时，你会为当初的这个假定付出代价的。</div><div class="line"></div><div class="line">这里我们得到的教训是，单例应该只用来保存全局的状态，并且不能和任何作用域绑定。如果这些状态的作用域比一个完整的应用程序的生命周期要短，那么这个状态就不应该使用单例来管理。用一个单例来管理用户绑定的状态，是代码的坏味道，你应该认真的重新评估你的对象图的设计。</div><div class="line"></div><div class="line">### 避免使用单例</div><div class="line">既然单例对局部作用域的状态有这么多的坏处，那么我们应该怎样避免使用它们呢？</div><div class="line"></div><div class="line"></div><div class="line">让我们来重温一下上面的例子。既然我们的缩略图 cache 的缓存状态是和具体的用户绑定的，那么让我们来定义一个user对象吧：</div></pre></td></tr></table></figure></p>
<p>@interface SPUser : NSObject</p>
<p>@property (nonatomic, readonly) SPThumbnailCache *thumbnailCache;</p>
<p>@end</p>
<p>@implementation SPUser</p>
<ul>
<li><p>(instancetype)init<br>{<br>  if ((self = [super init])) {</p>
<pre><code>_thumbnailCache = [[SPThumbnailCache alloc] init];

// Initialize other user-specific state...
</code></pre><p>  }<br>  return self;<br>}</p>
</li>
</ul>
<p>@end<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">我们现在用一个对象来作为一个经过认证的用户会话的模型类，并且我们可以把所有和用户相关的状态存储在这个对象中。现在假设我们有一个view controller来展现好友列表：</div></pre></td></tr></table></figure></p>
<p>@interface SPFriendListViewController : UIViewController</p>
<ul>
<li>(instancetype)initWithUser:(SPUser *)user;</li>
</ul>
<p>@end<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">我们可以显式地把经过认证的 user 对象作为参数传递给这个 view controller。这种把依赖性传递给依赖对象的技术正式的叫法是依赖注入，它有很多优点：</div><div class="line"></div><div class="line">1. 对于阅读这个 SPFriendListViewController 头文件的读者来说，可以很清楚的知道它只有在有登录用户的情况下才会被展示。</div><div class="line">2. 这个 SPFriendListViewController 只要还在使用中，就可以强引用 user 对象。举例来说，对于前面的例子，我们可以像下面这样在后台任务中保存一个图片到缩略图 cache 中：</div></pre></td></tr></table></figure></p>
<p>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{<br>    [_user.thumbnailCache cacheProfileImage:newImage forUserId:userId];<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">就算后台任务还没有完成，应用其他地方的代码也可以创建和使用一个全新的 SPUser 对象，而不会在清理第一个实例时阻塞用户交互。</div><div class="line"></div><div class="line">	</div><div class="line"></div><div class="line"></div><div class="line">***这一切的关键点是，在面向对象编程中我们想要最小化可变状态的作用域。但是单例却因为使可变的状态可以被程序中的任何地方访问，而站在了对立面。下一次你想使用单例时，我希望你能够好好考虑一下使用依赖注入作为替代方案。***</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"># 桥接模式(Bridge Pattern)</div><div class="line"></div><div class="line">## 简介</div><div class="line">桥接模式把事物对象和其具体行为、具体特征分离开来，使它们可以各自独立的变化。事物对象仅是一个抽象的概念。如“圆形”、“三角形”归于抽象的“形状”之下，而“画圆”、“画三角”归于实现行为的“画图”类之下，然后由“形状”调用“画图”。</div><div class="line"></div><div class="line">如果有一个N品牌的手机，它有个小游戏，我要玩游戏，程序应该如何写？</div></pre></td></tr></table></figure></p>
<p>//N品牌的手机中的游戏<br>class HandSetNGame<br>{<br>    public void Run()<br>    {<br>        Console.WriteLine(“运行N品牌”);<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">客户端</div></pre></td></tr></table></figure>
<p>HandSetNGame game = new HandSetGame();<br>game.run();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">现在又有一个M品牌的手机，也是小游戏，客户端也可以调用，如何做？</div></pre></td></tr></table></figure></p>
<p>class HandSetGame<br>{<br>    public virtual void Run()<br>    {<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">M品牌手机游戏和N品牌手机游戏</div></pre></td></tr></table></figure></p>
<p>class HandSetMGame : HandSetGanme<br>{<br>    public override void Run()<br>    {<br>        Console.WriteLine(“运行M品牌手机游戏”);<br>    }<br>}</p>
<p>class HandSetNGame : HandSetGanme<br>{<br>    public override void Run()<br>    {<br>        Console.WriteLine(“运行N品牌手机游戏”);<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">然后，由于手机都需要通讯录功能，于是N品牌和M品牌都增加了通讯录的增删该查功能，如何处理？</div></pre></td></tr></table></figure>
<p>//手机品牌<br>class HandSetBrand<br>{<br>    public virtual void run()<br>    {<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>//手机品牌M<br>class HandSetBrandM:HandsetBrand<br>{<br>}</p>
<p>//手机品牌N<br>class HandSetBrandM:HandsetBrand<br>{<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">下属的各自通讯录类和游戏类</div></pre></td></tr></table></figure>
<p>//手机品牌M的游戏<br>class HandSetBrandMGame:HandSetBrandM<br>{<br>    public override void Run()<br>    {<br>        Console.WriteLine(“运行M品牌手机游戏”);<br>    }<br>}</p>
<p>//手机品牌N的游戏<br>class HandSetBrandMGame:HandSetBrandM<br>{<br>    public override void Run()<br>    {<br>        Console.WriteLine(“运行N品牌手机游戏”);<br>    }<br>}</p>
<p>//手机品牌M的通讯录<br>class HandSetBrandMAddressList:HandSetBrandM<br>{<br>    public override void Run()<br>    {<br>        Console.WriteLine(“运行M品牌手机通讯录”);<br>    }<br>}</p>
<p>//手机品牌N的<br>class HandSetBrandMAddressList:HandSetBrandM<br>{<br>    public override void Run()<br>    {<br>        Console.WriteLine(“运行N品牌手机通讯录”);<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">客户端调用代码</div></pre></td></tr></table></figure>
<p>static void Main(strring[] args)<br>{<br>    HandSetBrand ab;</p>
<pre><code>ab = new HandSetBrandMAddressList();
ab.Run();

ab = new HandSetBrandNAddressList();
ab.Run();

ab = new HandSetBrandMGame();
ab.Run();

ab = new HandSetBrandNGame();
ab.Run();

Console.Read();
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">如果我现在需要每个品牌都增加一个MP3音乐功能，如何做？还增加子类？</div><div class="line"></div><div class="line">***对象的继承关系是在编译时就定义好的，所以无法在运行时改变从父类继承的实现，子类的实现与它的父类有非常紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化。当你需要复用子类时，如果继承下来的实现不适合解决新的问题，则父类必须重写或被其它更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。***</div><div class="line"></div><div class="line">***</div><div class="line"></div><div class="line">***合成(Composition)／聚合(Aggregation)复用原则,尽量使用合成／聚合，尽量不要使用类继承。***</div><div class="line"></div><div class="line">***</div><div class="line"></div><div class="line">聚合表示一种弱的&apos;拥有&apos;关系，体现的是A对象可以包含B对象，但是B对象不是A对象的一部分。合成则是一种强的&apos;拥有&apos;关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。</div><div class="line"></div><div class="line">比如说 大雁有翅膀，大雁和翅膀是部分和整体的关系，并且它们生命周期是一样的，于是它们就是合成关系。而大雁是群居动物，所以每只大雁都属于一个雁群，一个雁群可以有很多大雁，所以大雁和雁群是聚合关系。</div><div class="line"></div><div class="line">***优先使用对象的合成／聚合将有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。***</div><div class="line"></div><div class="line">像&apos;游戏&apos;，&apos;通讯录&apos;，&apos;MP3音乐&apos;，如果我们可以让其分离与手机的耦合，那么可以大大减少面对新需求改动过大的不合理情况。</div><div class="line"></div><div class="line">松耦合的程序</div></pre></td></tr></table></figure></p>
<p>//手机软件<br>abstract class HandsetSoft<br>{<br>    public abstract void Run();<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">游戏，通讯录等具体类</div></pre></td></tr></table></figure></p>
<p>//手机游戏<br>class HandsetGame : HandSetSoft<br>{<br>    public override void Run()<br>    {<br>        Console.WriteLine(“运行手机游戏”);<br>    }<br>}</p>
<p>//手机通讯录<br>class HandsetAddressList : HandSetSoft<br>{<br>    public override void Run()<br>    {<br>        Console.WriteLine(“运行手机通讯录”);<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>//手机品牌<br>abstract class HandsetBrand<br>{<br>    protected HandsetSoft soft;</p>
<pre><code>//设置手机软件
public void SetHandSetSoft(HandSetSoft soft)
{
    this.soft = soft;
}
//运行
public abtract void run();
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">品牌N品牌M具体类</div></pre></td></tr></table></figure></p>
<p>//手机品牌N<br>class HandSetBrandN: HandBrand<br>{<br>    public override void Run()<br>    {<br>        soft.Run();<br>    }<br>}</p>
<p>//手机品牌M<br>class HandSetBrandM: HandBrand<br>{<br>    public override void Run()<br>    {<br>        soft.Run();<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">客户端代码</div></pre></td></tr></table></figure>
<p>static void Mian(string[] args)<br>{<br>    HandSetBrand ab;<br>    ab = new HandSetBrandN();</p>
<pre><code>ab.setHandSetSoft(new HandSetGame());
ab.run();

ab.setHandSetSoft(new HandSetAddressList());
ab.run();

ab = new HandSetBrandM();

ab.setHandSetSoft(new HandSetGame());
ab.run();

ab.setHandSetSoft(new HandSetAddressList());
ab.run();

Console.Read();
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">现在我们要再加个功能 比如说MP3功能，只要增加这个类就好了，不会影响其它任何类。</div></pre></td></tr></table></figure></p>
<p>//手机MP3播放<br>class HandsetMP3 : HandSetSoft<br>{<br>    public override void Run()<br>    {<br>        Console.WriteLine(“运行手机MP3”);<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">如果要增加S品牌，只需要增加一个品牌子类就可以了。</div></pre></td></tr></table></figure></p>
<p>//手机品牌S<br>class HandSetBrand: HandSetBrand<br>{<br>    public override void Run()<br>    {<br>        soft.Run();<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 桥接模式</div><div class="line"></div><div class="line">桥接模式:将抽象部分与它的实现部分分离，使它们都可以独立地变化。</div><div class="line"></div><div class="line">什么叫抽象与它的实现分离，这并不是说，让抽象与其派生类分离，因为这没有任何意义。实现指的是抽象类和它的派生类用来实现自己的对象。</div><div class="line"></div><div class="line">![</div><div class="line">][10]</div><div class="line"></div><div class="line"></div><div class="line">桥接模式基本代码</div><div class="line"></div><div class="line">![</div><div class="line">][11]</div><div class="line"></div><div class="line"> 桥接模式把两个角色之间的继承关系改为聚合关系，从而使二者可以各自独立的变化。把原来在基类的实现化细节抽象出来，再构造到一个实现化的结构中，然后把原来的基类改造成一个抽象化的等级结构，这样就实现了系统在多个维度上的独立变化。</div><div class="line"> </div><div class="line"> </div><div class="line"> # 命令模式(Command Pattern)</div><div class="line"></div><div class="line">## 简介</div><div class="line">在面向对象程式设计的范畴中，命令模式是一种设计模式，它尝试以物件来代表实际行动。命令物件可以把行动(action) 及其参数封装起来，于是这些行动可以被：</div><div class="line"></div><div class="line">* 重复多次</div><div class="line">* 取消（如果该物件有实作的话）</div><div class="line">* 取消后又再重做</div><div class="line"></div><div class="line">这些都是现代大型应用程序所必须的功能，即“复原”及“重复”。除此之外，可以用命令模式来实作的功能例子还有：</div><div class="line"></div><div class="line">* 交易行为</div><div class="line">* 进度列</div><div class="line">* 精灵</div><div class="line">* 使用者界面按钮及功能表项目</div><div class="line">* 执行绪 pool</div><div class="line">* 宏收录</div><div class="line"></div><div class="line">![</div><div class="line">][12]</div><div class="line"></div><div class="line">JavaScript</div></pre></td></tr></table></figure></p>
<p>/<em> The Invoker function </em>/<br>var Switch = function(){<br>    var _commands = [];<br>    this.storeAndExecute = function(command){<br>        _commands.push(command);<br>        command.execute();<br>    }<br>}</p>
<p>/<em> The Receiver function </em>/<br>var Light = function(){<br>    this.turnOn = function(){ console.log (‘turn on’)};<br>    this.turnOff = function(){ console.log (‘turn off’) };<br>}</p>
<p>/<em> The Command for turning on the light - ConcreteCommand #1 </em>/<br>var FlipUpCommand = function(light){<br>    this.execute = light.turnOn;<br>}</p>
<p>/<em> The Command for turning off the light - ConcreteCommand #2 </em>/<br>var FlipDownCommand = function(light){<br>    this.execute = light.turnOff;<br>}</p>
<p>var light = new Light();<br>var switchUp = new FlipUpCommand(light);<br>var switchDown = new FlipDownCommand(light);<br>var s = new Switch();</p>
<p>s.storeAndExecute(switchUp);<br>s.storeAndExecute(switchDown);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Java</div></pre></td></tr></table></figure></p>
<p>import java.util.List;<br>import java.util.ArrayList;</p>
<p>/<em> The Command interface </em>/<br>public interface Command {<br>   void execute();<br>}</p>
<p>/<em> The Invoker class </em>/<br>public class Switch {<br>   private List<command> history = new ArrayList<command>();</p>
<p>   public Switch() {<br>   }</p>
<p>   public void storeAndExecute(Command cmd) {<br>      this.history.add(cmd); // optional<br>      cmd.execute();<br>   }<br>}</p>
<p>/<em> The Receiver class </em>/<br>public class Light {<br>   public Light() {<br>   }</p>
<p>   public void turnOn() {<br>      System.out.println(“The light is on”);<br>   }</p>
<p>   public void turnOff() {<br>      System.out.println(“The light is off”);<br>   }<br>}</p>
<p>/<em> The Command for turning on the light - ConcreteCommand #1 </em>/<br>public class FlipUpCommand implements Command {<br>   private Light theLight;</p>
<p>   public FlipUpCommand(Light light) {<br>      this.theLight = light;<br>   }</p>
<p>   public void execute(){<br>      theLight.turnOn();<br>   }<br>}</p>
<p>/<em> The Command for turning off the light - ConcreteCommand #2 </em>/<br>public class FlipDownCommand implements Command {<br>   private Light theLight;</p>
<p>   public FlipDownCommand(Light light) {<br>      this.theLight = light;<br>   }</p>
<p>   public void execute() {<br>      theLight.turnOff();<br>   }<br>}</p>
<p>/<em> The test class or client </em>/<br>public class PressSwitch {<br>   public static void main(String[] args){<br>      Light lamp = new Light();<br>      Command switchUp = new FlipUpCommand(lamp);<br>      Command switchDown = new FlipDownCommand(lamp);</p>
<pre><code>Switch mySwitch = new Switch();

try {
   if (&quot;ON&quot;.equalsIgnoreCase(args[0])) {
      mySwitch.storeAndExecute(switchUp);
   }
   else if (&quot;OFF&quot;.equalsIgnoreCase(args[0])) {
      mySwitch.storeAndExecute(switchDown);
   }
   else {
      System.out.println(&quot;Argument \&quot;ON\&quot; or \&quot;OFF\&quot; is required.&quot;);
   }
} catch (Exception e) {
   System.out.println(&quot;Arguments required.&quot;);
}
</code></pre><p>   }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 实例</div><div class="line">### 模拟烧烤</div><div class="line"></div><div class="line">#### 紧耦合设计</div></pre></td></tr></table></figure></p>
<p>//烤肉串者<br>public class Barbecuer<br>{<br>    //烤羊肉<br>    public void BakeMutton()<br>    {<br>        Console.WriteMutton(“烤羊肉串”);<br>    }<br>    //烤鸡翅<br>    public void BakeChikenWing()<br>    {<br>        Console.WriteMutton(“烤鸡翅”);<br>    }</p>
<p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">客户端调用</div></pre></td></tr></table></figure></p>
<p>static void Main(string[] args)<br>{<br>    Barbecuer boy = new Barbecuew();<br>    boy.BakeMutton();<br>    boy.BakeMutton();<br>    boy.BakeMutton();<br>    boy.BakeChickenWing();<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 松耦合设计</div><div class="line"></div><div class="line">抽象命令类</div></pre></td></tr></table></figure></p>
<p>//抽象命令<br>public abstract class Command<br>{<br>    protected Barbecuer receiver;</p>
<pre><code>public Command(Barbecuer receiver)
{
    this.receiver = receiver;
}

//执行命令
abstract public ExcuteCommand();
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">具体命令类</div></pre></td></tr></table></figure></p>
<p>//烤羊肉命令<br>class BakeMuttonCommand: Command<br>{<br>    public BakeMuttonCommand(Barbecuer receiver)<br>    {<br>        :base(receiver)<br>    }</p>
<pre><code>public override void EccuteCommand()
{
    receiver.BakeMutton();
}
</code></pre><p>}</p>
<p>//烤鸡翅命令<br>class BakeMuttonCommand: Command<br>{<br>    public BakeMuttonCommand(Barbecuer receiver)<br>    {<br>        :base(receiver)<br>    }</p>
<pre><code>public override void EccuteCommand()
{
    receiver.BakeChickenWing();
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">服务员类</div></pre></td></tr></table></figure>
<p>//服务员<br>public class Waiter<br>{<br>    private Command command;</p>
<pre><code>//设置订单
public void setOrder(Command command)
{
    this.command
}

//通知执行
public void Notify()
{
    command.ExcuteCommand();
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>//烤肉串者<br>public class Barbecuer<br>{<br>    //烤羊肉<br>    public void BakeMutton()<br>    {<br>        Console.WriteMutton(“烤羊肉串”);<br>    }<br>    //烤鸡翅<br>    public void BakeChikenWing()<br>    {<br>        Console.WriteMutton(“烤鸡翅”);<br>    }</p>
<p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">客户端实现</div></pre></td></tr></table></figure></p>
<p>static void Main(string[] args)<br>{<br>    //开店前的准备<br>    Barbecuer boy = new Barbecuer();<br>    Command BakeMuttonCommand1 = new BakeMuttonCommand(boy);<br>    Command BakeMuttonCommand2 = new BakeMuttonCommand(boy);<br>    Command BakeChickenWingCommand1 = new BakeMuttonCommand(boy);</p>
<pre><code>Waiter girl = new Waiter();

//开门营业
girl.SetOrder(BakeMuttonCommand1);
girl.Notify();

girl.SetOrder(BakeMuttonCommand2);
girl.Notify();    

girl.SetOrder(BakeChickenWingCommand1);
girl.Notify();    

COnsole.Read();
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 松耦合后</div></pre></td></tr></table></figure>
<p>//服务员<br>public class Waiter<br>{<br>    private IList<command> orders = new List<command>();</p>
<pre><code>//设置订单
public void SetOrder(Command command)
{
    if (command.ToString() == &quot;命令模式.BakeChikenWingCommand&quot;)
    {
        Console.WriteLine(&quot;服务员：鸡翅没有了，请点别的烧烤。&quot;);
    } 
    else
    {
        orders.Add(command);
        Console.WriteLine(&quot;增加订单：&quot;+ command.ToString() + &quot;时间&quot; + DateTime.Now.ToString());
    }
}

//取消订单
public void CancelOrder(Command command)
{
    orders.Remove(command);
    Console.WriteLine(&quot;取消订单&quot; + command.ToString() + &quot;时间&quot; + DateTime.Now.ToString());
}

//通知全部执行
public void Notify()
{
    foreach(Command cmd in orders)
    {
        cmd.ExcuteCommand();
    }
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">客户端代码实现</div></pre></td></tr></table></figure></p>
<p>static void Main(string[] args)<br>{</p>
<pre><code>Barbecuer boy = new Barbecuer();
Command BakeMuttonCommand1 = new BakeMuttonCommand(boy);
Command BakeMuttonCommand2 = new BakeMuttonCommand(boy);
Command BakeChickenWingCommand1 = new BakeMuttonCommand(boy);

Waiter girl = new Waiter();

girl.setOrder(bakeMuttonCommand1);
girl.setOrder(bakeMuttonCommand1);
girl.setOrder(BakeChickenWingCommand1);

girl.Notify();

Console.Read();
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">***命令模式:将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数话；对请求排队或者纪录请求日志，以及支持可撤销的操作。***</div><div class="line"></div><div class="line">命令模式的优点:</div><div class="line"></div><div class="line">* 容易地设计一个命令队列。</div><div class="line">* 在需求的情况下，比较容易地将命令记入日志。</div><div class="line">* 允许接受请求的一方决定是否要回绝请求。</div><div class="line">* 很容易对请求撤销或者重做。</div><div class="line">* 加入新的命令类不影响其它的类。</div><div class="line">* 把请求一个操作的对象与知道怎么执行一个操作的对象分割开。</div><div class="line"></div><div class="line"></div><div class="line"># 责任链模式(Chain-of-responsibility pattern)</div><div class="line"></div><div class="line">## 简介</div><div class="line">责任链模式在面向对象程式设计里是一种软件设计模式，它包含了一些命令对象和一系列的处理对象。每一个处理对象决定它能处理哪些命令对象，它也知道如何将它不能处理的命令对象传递给该链中的下一个处理对象。该模式还描述了往该处理链的末尾添加新的处理对象的方法。</div><div class="line"></div><div class="line">以下的日志类(logging)例子演示了该模式。 每一个logging handler首先决定是否需要在该层做处理，然后将控制传递到下一个logging handler。程序的输出是:</div></pre></td></tr></table></figure></p>
<p>  Writing to debug output: Entering function y.<br>  Writing to debug output: Step1 completed.<br>  Sending via e-mail:      Step1 completed.<br>  Writing to debug output: An error has occurred.<br>  Sending via e-mail:      An error has occurred.<br>  Writing to stderr:       An error has occurred.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">注意：该例子不是日志类的推荐实现方式。</div><div class="line"></div><div class="line">同时，需要注意的是，通常在责任链模式的实现中，如果在某一层已经处理了这个logger，那么这个logger就不会传递下去。在我们这个例子中，消息会一直传递到最底层不管它是否已经被处理。</div></pre></td></tr></table></figure></p>
<p>import java.util.*;</p>
<p>abstract class Logger<br>{<br>    public static int ERR = 3;<br>    public static int NOTICE = 5;<br>    public static int DEBUG = 7;<br>    protected int mask;</p>
<pre><code>// The next element in the chain of responsibility
protected Logger next;
public Logger setNext( Logger l)
{
    next = l;
    return this;
}

public final void message( String msg, int priority )
{
    if ( priority &lt;= mask ) 
    {
        writeMessage( msg );
        if ( next != null )
        {
            next.message( msg, priority );
        }
    }
}

protected abstract void writeMessage( String msg );
</code></pre><p>}</p>
<p>class StdoutLogger extends Logger<br>{</p>
<pre><code>public StdoutLogger( int mask ) { this.mask = mask; }

protected void writeMessage( String msg )
{
    System.out.println( &quot;Writting to stdout: &quot; + msg );
}
</code></pre><p>}</p>
<p>class EmailLogger extends Logger<br>{</p>
<pre><code>public EmailLogger( int mask ) { this.mask = mask; }

protected void writeMessage( String msg )
{
    System.out.println( &quot;Sending via email: &quot; + msg );
}
</code></pre><p>}</p>
<p>class StderrLogger extends Logger<br>{</p>
<pre><code>public StderrLogger( int mask ) { this.mask = mask; }

protected void writeMessage( String msg )
{
    System.out.println( &quot;Sending to stderr: &quot; + msg );
}
</code></pre><p>}</p>
<p>public class ChainOfResponsibilityExample<br>{<br>    public static void main( String[] args )<br>    {<br>        // Build the chain of responsibility<br>        Logger l = new StdoutLogger( Logger.DEBUG).setNext(<br>                            new EmailLogger( Logger.NOTICE ).setNext(<br>                            new StderrLogger( Logger.ERR ) ) );</p>
<pre><code>    // Handled by StdoutLogger
    l.message( &quot;Entering function y.&quot;, Logger.DEBUG );

    // Handled by StdoutLogger and EmailLogger
    l.message( &quot;Step1 completed.&quot;, Logger.NOTICE );

    // Handled by all three loggers
    l.message( &quot;An error has occurred.&quot;, Logger.ERR );
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 加薪代码初步</div></pre></td></tr></table></figure></p>
<p>//申请<br>class Request<br>{<br>    //申请类别<br>    private string requestType;<br>    public string RequestType<br>    {<br>        get {return requestType;}<br>        set {requestType = value;}<br>    }</p>
<pre><code>//申请内容
private string requestContent;
public string RequestContent
{
    get {return RequestContent;}
    set {RequestContent = value;}
}

//数量
private int number;
public int Number
{
    get {return number;}
    set {number = value;}
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>//管理者<br>class Manager<br>{<br>    protected string name;<br>    public Manager(string name)<br>    {<br>        this.name = name;<br>    }</p>
<pre><code>//得到结果
public void GetResult(string managerLevel, Request request)
{
    if (request.RequestType==&quot;经理&quot;) {
        if (request.RequestType == &quot;请假&quot; &amp;&amp; request.Number &lt;= 2)
        {
            Console.WriteLine(&quot;被批准&quot;);
        } else
        {
            Console.WriteLine(&quot;我无权处理&quot;);
        }
    } else if (request.RequestType==&quot;总监&quot;) {
        if (request.RequestType == &quot;请假&quot; &amp;&amp; request.Number &lt;= 5)
        {
            Console.WriteLine(&quot;被批准&quot;);
        } else
        {
            Console.WriteLine(&quot;我无权处理&quot;);
        }
    } else if (request.RequestType==&quot;总经理&quot;) {
        if (request.RequestType == &quot;请假“) {
            Console.WriteLine(&quot;被批准&quot;);
        } else if (request.RequestType == &quot;加薪&quot; &amp;&amp; request.Number &lt;= 500) {
            Console.WriteLine(&quot;被批准&quot;);
        } else if (request.RequestType == &quot;加薪&quot; &amp;&amp; request.Number &gt; 500) {
            Console.WriteLine(&quot;再说&quot;);
        }
    }
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">客户端代码如下</div></pre></td></tr></table></figure></p>
<p>static void Main(string[] args)<br>{<br>    Manager jinli = new Manager(“金利”);<br>    Manager zongjian = new Manager(“宗剑”);<br>    Manager zhongjingli = new Manager(“钟精励”);</p>
<pre><code>Request request = new Reuqest();
request.RequestType = &quot;加薪&quot;;
request.RequestContent = &quot;小菜请求加薪&quot;;
request.Number = 1000;

Request request2 = new Reuqest();
request2.RequestType = &quot;请假&quot;;
request2.RequestContent = &quot;小菜请假&quot;;
request2.Number = 3;    

jinli.GetResult(&quot;经理&quot;,request2);
zongjian.GetResult(&quot;总监&quot;,request2);
zhongjingli.GetResult(&quot;总经理&quot;,request2);

Console.Read();
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">代码评判:&apos;管理者&apos;类里面的&apos;结果&apos;方法比较长，加上有太多的分支判断，这种设计很不好。而且会不会增加其它的管理类别，比如说项目经理，部门经理，那就意味者需要去更改这个类，这个类承担了太多的责任，这违背了哪些设计原则？</div><div class="line"></div><div class="line">类有太多的责任，这违背了单一职责原则，增加新的管理类别，需要修改这个类，违背了开放－封闭原则。</div><div class="line"></div><div class="line">子类化加多太改善。</div><div class="line"></div><div class="line">职责链模式:使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系，将这个对象连成一条链，并沿着个链传递请求，直到有一个对象处理为止。</div><div class="line"></div><div class="line">### 加薪代码重构</div></pre></td></tr></table></figure></p>
<p>//管理者<br>abstract class Manager<br>{<br>    protected Manager superior;</p>
<pre><code>public Manager(string name)
{
    this.name = name;
}

//设置管理者的上级
public void setSuperior(Manager superior)
{
    this.superior = superior;
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">经理类就可以去继承这个&apos;管理者&apos;类，只需重写&apos;申请要求&apos;的方法就可以了。</div></pre></td></tr></table></figure></p>
<p>class CommonManager : Manager<br>{<br>    public CommonManager(string name) :base(name)<br>    {}</p>
<pre><code>public override void RequestApplications(Request request)
{
    if (request.RequestType == &quot;请假&quot; &amp;&amp; request.Number &lt;= 2)
    {
        Console.WriteLine(&quot;被批准&quot;);
    } else
    {
        if (superior != null) superior.RequestApplications(request);
    }
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">总监类同样继承&apos;管理者类&apos;。</div></pre></td></tr></table></figure></p>
<p>//总监<br>class Majordomo :Manager<br>{<br>    public Major(string name): base(name)<br>    {}<br>    public override void RequestApplications(Request request)<br>    {<br>        if (request.RequestType == “请假” &amp;&amp; request.Number &lt;= 2)<br>        {<br>            Console.WriteLine(“被批准”);<br>        } else<br>        {<br>            if (superior != null) superior.RequestApplications(request);<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">总经理类的权限就是全部都需要处理。</div></pre></td></tr></table></figure></p>
<p>//总经理<br>class GeneralManager :Manager<br>{<br>    public GeneralManager(string name): base(name)<br>    {}<br>    public override void RequestApplications(Request request)<br>    {<br>        if (request.RequestType == “请假”)<br>        {<br>            Console.WriteLine(“被批准”);<br>        } else if (request.RequestType == “加薪” &amp;&amp; request.Number &lt;= 500)<br>        {<br>            Console.WriteLine(“被批准”);<br>        } else if (request.RequestType == “加薪” &amp;&amp; request.Number &gt; 500)<br>        {<br>            Console.WriteLine(“再说吧”);<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">由于我们把你原来的一个&apos;管理者&apos;类改成了一个抽象类和三个具体类，此时类之间的灵活性就大大的增加了，如果我们需要扩展新的管理类别，只需要增加子类就可以。当然，还有一个关键，那就是客户端如何编写。</div></pre></td></tr></table></figure></p>
<p>static void Main(string[] args)<br>{<br>    CommonManager jinli = new CommonManger(“金利”);<br>    Majordomo zongjian = new Majordomo(“宗建”);<br>    GeneralManager zhongjingli = newGeneralManager(“钟精利”);</p>
<pre><code>//设置上级
jinli.SetSuperior(zongjian);
zongjian.SetSuperior(zhongjingli);

Request request = new Request();
request.RequestType = &quot;请假&quot;;
request.RequestContent = &quot;小菜请假&quot;;
request.Number = 1;
//客户端的申请都是有‘经理’发起，但是实际谁来决策都是由具体管理类处理，客户端不知道
jinli.requestApplications(request);

Request request1 = new Request();
request1.RequestType = &quot;请假&quot;;
request1.RequestContent = &quot;小菜请假&quot;;
request1.Number = 4;
jinli.requestApplications(request1);    

Request request2 = new Request();
request2.RequestType = &quot;请求加薪&quot;;
request2.RequestContent = &quot;小菜请加薪&quot;;
request2.Number = 400;
jinli.requestApplications(request2);    

Console.Read();
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">责任链模式是一种对象的行为模式【GOF95】。在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。</div><div class="line"></div><div class="line">### 门框夹核桃</div><div class="line"></div><div class="line">职责链模式想要做到的事情其实就是把多个函数链起来调用。</div><div class="line"></div><div class="line">该模式提出的时候FP并不如今日盛行，其作者选用类来包装需要被链接的多个函数，这无可厚非。</div><div class="line"></div><div class="line">无论是class，还是function，都是为程序员提供抽象的手段。当我们想要链接的东西就是多个function，选择直接用function而非class就会显得更加自然，也更加轻量且合适。</div></pre></td></tr></table></figure>
<p>object Loggers {<br>  val ERR = 3<br>  val NOTICE = 5<br>  val DEBUG = 7</p>
<p>  case class Event(message: String, priority: Int)</p>
<p>  type Logger = Event =&gt; Event</p>
<p>  def stdOutLogger(mask: Int): Logger = event =&gt; handleEvent(event, mask) {<br>    println(s”Writing to stdout: ${event.message}”)<br>  }</p>
<p>  def emailLogger(mask: Int): Logger = event =&gt; handleEvent(event, mask) {<br>    println(s”Sending via e-mail: ${event.message}”)<br>  }</p>
<p>  def stdErrLogger(mask: Int): Logger = event =&gt; handleEvent(event, mask) {<br>    System.err.println(s”Sending to stderr: ${event.message}”)<br>  }</p>
<p>  private def handleEvent(event: Event, mask: Int)(handler: =&gt; Unit) = {<br>    if (event.priority &lt;= mask) handler<br>    event<br>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">三个log的的等级ERR，NOTICE和DEBUG和之前Java的实现是一样的。</div><div class="line"></div><div class="line">一个case class Event，用来包裹需要被log的事件。</div><div class="line"></div><div class="line">type Logger则是声明了一个函数签名，凡是符合这个签名的函数都可以作为logger被使用。</div><div class="line"></div><div class="line">然后便是三个函数实现，它们将mask通过闭包封进函数内。这三个函数共同依赖一个私有handleEvent函数，其作用和Java代码中的message类似，判断mask和正在发生的事件之间优先级大小关系，并以此决定当前logger是否需要处理该事件。</div><div class="line"></div><div class="line">哎？等一下，这个是职责链模式啊，那个啥，链在哪儿呢？</div></pre></td></tr></table></figure></p>
<p>object ChainRunner {</p>
<p>  import chain.Loggers._</p>
<p>  def main(args: Array[String]) {<br>    val chain = stdOutLogger(DEBUG) andThen emailLogger(NOTICE) andThen stdErrLogger(ERR)</p>
<pre><code>chain(Event(&quot;Entering function y.&quot;, DEBUG))
chain(Event(&quot;Step1 completed.&quot;, NOTICE))
chain(Event(&quot;An error has occurred.&quot;, ERR))
</code></pre><p>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">以上代码中的andThen就可以把三个logger链在一起。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"># 中介者模式(Mediator Pattern)</div><div class="line"></div><div class="line">## 简介</div><div class="line">在用户与用户直接聊天的设计方案中，用户对象之间存在很强的关联性，将导致系统出现如下问题：</div><div class="line"></div><div class="line">* 系统结构复杂：对象之间存在大量的相互关联和调用，若有一个对象发生变化，则需要跟踪和该对象关联的其他所有对象，并进行适当处理。</div><div class="line">* 对象可重用性差：由于一个对象和其他对象具有很强的关联，若没有其他对象的支持，一个对象很难被另一个系统或模块重用，这些对象表现出来更像一个不可分割的整体，职责较为混乱。</div><div class="line">* 系统扩展性低：增加一个新的对象需要在原有相关对象上增加引用，增加新的引用关系也需要调整原有对象，系统耦合度很高，对象操作很不灵活，扩展性差。</div><div class="line">* 在面向对象的软件设计与开发过程中，根据“单一职责原则”，我们应该尽量将对象细化，使其只负责或呈现单一的职责。</div><div class="line">* 对于一个模块，可能由很多对象构成，而且这些对象之间可能存在相互的引用，为了减少对象两两之间复杂的引用关系，使之成为一个松耦合的系统，我们需要使用中介者模式，这就是中介者模式的模式动机。</div><div class="line"></div><div class="line">***中介者模式(Mediator Pattern)定义：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。***</div><div class="line"></div><div class="line"></div><div class="line">## 案例</div><div class="line">安理会做中介</div></pre></td></tr></table></figure></p>
<p>//联合国机构<br>abstract class UnitedNations<br>{<br>    //声明<br>    public abstract void Declare(string message,Country colleagues);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">国家类 相当于Colleague类</div></pre></td></tr></table></figure></p>
<p>abstract class Country<br>{<br>    protected UnitedNations mediator;</p>
<pre><code>public Country(UnitedNations mediator)
{
    this.mediator = mediator;
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">美国类 相当于ConcreteColleague1类</div></pre></td></tr></table></figure></p>
<p>class USA: Country<br>{<br>    public USA(UnitedNations mediator): base(mediator)<br>    {}<br>    //声明<br>    public void Declare(string message)<br>    {<br>        mediator.Declare(message, this);<br>    }</p>
<pre><code>//获得消息
public void GetMessage(string message)
{
    Console.WriteLine(&quot;美国获得对方消息&quot; + message);
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">伊拉克类 相当于ConcreteColleague2类</div></pre></td></tr></table></figure></p>
<p>class Iraq: Country<br>{<br>    public Iraq(UnitedNations mediator): base(mediator)<br>    {}<br>    //声明<br>    public void Declare(string message)<br>    {<br>        mediator.Declare(message, this);<br>    }</p>
<pre><code>//获得消息
public void GetMessage(string message)
{
    Console.WriteLine(&quot;美国获得对方消息&quot; + message);
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">联合国安理会 相当于ConcreteMediator类</div></pre></td></tr></table></figure></p>
<p>//联合国安全理事会<br>class UnitedNationsSecurityCouncil: UnitedNations<br>{<br>    private USA colleague1;<br>    private Iraq colleague2;</p>
<pre><code>//美国
public USA Colleague1
{
    set {colleague1 = value;}
}

//伊拉克
    public Iraq Colleague2
{
    set {colleague2 = value;}
}

//声明
public override void Declare(string message, Country colleague)
{
    if(colleague == colleague1)
    {
        colleague2.GetMessage(message);
    }else
    {
        colleague1.GetMessage(message);
    }
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">客户端调用</div></pre></td></tr></table></figure></p>
<p>static void Main(string[] args)<br>{<br>    UnitedNationsSecurityCouncil UNSC = new UnitedNationsSecurityCouncil();</p>
<pre><code>USA c1 = new USA(UNSC);
Iraq c2 = new Iraq(UNSC);

UNSC.Colleague1 = c1;
UNSC.Colleague2 = c2;

c1.Declare(&quot;不准研发核武器&quot;);
c2.Declare(&quot;我们没有，但我们不怕侵略&quot;);

Console.Read();    
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">中介者模式的优点首先是Mediator的出现减少了各个Colleague的耦合,可以毒瘤地改变和复用各个Colleague类和Mediator。其次由于把对象如何协作进行类抽象，将中介作为一个独立的概念并且将其封装在一个对象中，这样关注的对象就从对象本身的行为转移到它们的交互上来，也就是站在一个更宏观的角度去看待系统。</div><div class="line"></div><div class="line">但是，由于ConcreyeMediator控制了集中化，于是就把交互复杂性变为了中介者的复杂性，这就使得中介者会变得比任何一个ConcreteColleague都复杂。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"># 享元模式(Flyweight Pattern)</div><div class="line"></div><div class="line">## 简介</div><div class="line">享元模式（英语：Flyweight Pattern）是一种软件设计模式。它使用共享物件，用来尽可能减少内存使用量以及分享资讯给尽可能多的相似物件；它适合用于当大量物件只是重复因而导致无法令人接受的使用大量内存。通常物件中的部分状态是可以分享。常见做法是把它们放在外部数据结构，当需要使用时再将它们传递给享元。</div><div class="line"></div><div class="line"></div><div class="line">典型的享元模式的例子为文书处理器中以图形结构来表示字符。一个做法是，每个字形有其字型外观, 字模 metrics, 和其它格式资讯，但这会使每个字符就耗用上千字节。取而代之的是，每个字符参照到一个共享字形物件，此物件会被其它有共同特质的字符所分享；只有每个字符（文件中或页面中）的位置才需要另外储存。</div><div class="line"></div><div class="line">示例</div></pre></td></tr></table></figure></p>
<p>public enum FontEffect {<br>    BOLD, ITALIC, SUPERSCRIPT, SUBSCRIPT, STRIKETHROUGH<br>}</p>
<p>public final class FontData {<br>    /**</p>
<pre><code> * A weak hash map will drop unused references to FontData.
 * Values have to be wrapped in WeakReferences, 
 * because value objects in weak hash map are held by strong references.
 */
private static final WeakHashMap&lt;FontData, WeakReference&lt;FontData&gt;&gt; FLY_WEIGHT_DATA =
    new WeakHashMap&lt;FontData, WeakReference&lt;FontData&gt;&gt;();
private final int pointSize;
private final String fontFace;
private final Color color;
private final Set&lt;FontEffect&gt; effects;

private FontData(int pointSize, String fontFace, Color color, EnumSet&lt;FontEffect&gt; effects) {
    this.pointSize = pointSize;
    this.fontFace = fontFace;
    this.color = color;
    this.effects = Collections.unmodifiableSet(effects);
}

public static FontData create(int pointSize, String fontFace, Color color,
    FontEffect... effects) {
    EnumSet&lt;FontEffect&gt; effectsSet = EnumSet.noneOf(FontEffect.class);
    for (FontEffect fontEffect : effects) {
        effectsSet.add(fontEffect);
    }
    // We are unconcerned with object creation cost, we are reducing overall memory consumption
    FontData data = new FontData(pointSize, fontFace, color, effectsSet);

    // Retrieve previously created instance with the given values if it (still) exists
    WeakReference&lt;FontData&gt; ref = FLY_WEIGHT_DATA.get(data);
    FontData result = (ref != null) ? ref.get() : null;

    // Store new font data instance if no matching instance exists
    if (result == null) {
        FLY_WEIGHT_DATA.put(data, new WeakReference&lt;FontData&gt; (data));
        result = data;
    }
    // return the single immutable copy with the given values
    return result;
}

@Override
public boolean equals(Object obj) {
    if (obj instanceof FontData) {
        if (obj == this) {
            return true;
        }
        FontData other = (FontData) obj;
        return other.pointSize == pointSize &amp;&amp; other.fontFace.equals(fontFace)
            &amp;&amp; other.color.equals(color) &amp;&amp; other.effects.equals(effects);
    }
    return false;
}

@Override
public int hashCode() {
    return (pointSize * 37 + effects.hashCode() * 13) * fontFace.hashCode();
}

// Getters for the font data, but no setters. FontData is immutable.
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">结构图</div><div class="line">![</div><div class="line">][13]</div><div class="line"></div><div class="line">时序图</div><div class="line">![enter description here][14]</div><div class="line"></div><div class="line"></div><div class="line">## 实例</div><div class="line"></div><div class="line">### 第一版</div></pre></td></tr></table></figure></p>
<p>//网站<br>class WebSite<br>{<br>    private string name = “”;<br>    private WebSite(string name)<br>    {<br>        this.name = name;<br>    }<br>    public void Use()<br>    {<br>        Console.WriteLine(“网站分类” + name);<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">客户端代码</div></pre></td></tr></table></figure></p>
<p>static void Main(string args)<br>{<br>    WebSite fx = new WebSite(“产品展示”);<br>    fx.Use();</p>
<pre><code>WebSite fy = new WebSite(&quot;产品展示&quot;);
fy.Use();

WebSite f1 = new WebSite(&quot;博客&quot;);
f1.Use();    

WebSite f2 = new WebSite(&quot;博客&quot;);
f2.Use();    

Console.Read();
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 第二版</div><div class="line"></div><div class="line">网站抽象类</div></pre></td></tr></table></figure></p>
<p>abstract class WebSite<br>{<br>    public abstract void Use();<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">具体网站类</div></pre></td></tr></table></figure></p>
<p>class ConcreteWebSite :WebSite<br>{<br>    private string name = “”;<br>    public ConcreteWebSite(string name)<br>    {<br>        this.name =name;<br>    }<br>    public override void Use()<br>    {<br>        Console.WriteLine(“网站分类:” + name);<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">网站工厂类</div></pre></td></tr></table></figure></p>
<p>//网站工厂<br>class WebSiteFactory<br>{<br>    private HashTable flyweights = new Hashtable();</p>
<pre><code>//获得网站分类
public WebSite GetWebSiteCategory(string key)
{
    if (!flyweight.ContainKey(key))
    flyweights.Add(key, new ConcreteWebSite(key));
    return ((WebSite)flyweights[key]);
}
//获得网站分类总数
public int GetWebSiteCount()
{
    return flyweights.Count;
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">客户端代码</div></pre></td></tr></table></figure></p>
<p>static void Main(string[] args)<br>{<br>    WebSiteFactory f = new WebSiteFactory();</p>
<pre><code>WebSite fx = f.GetWebSiteCategory(&quot;产品展示&quot;);
fx.Use();

WebSite fy = f.GetWebSiteCategory(&quot;产品展示&quot;);
fy.Use();

WebSite f1 = f.GetWebSiteCategory(&quot;博客&quot;);
f1.Use();

WebSite f2 = f.GetWebSiteCategory(&quot;博客&quot;);
f2.Use();
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">***实际上，享元模式可以避免大量非常详细类的开销。在程序设计中，有时需要生成大量细力度的类实例来表示数据。如果能发现这些实例除了几个参数外基本上都是相同的，有时就能够受大幅度地减少需要实例化的类的数量。如果能把这些蚕食移到类实例的外面，在方法调用时将它们传递进来，就可以通过共享大幅度地减少单个实例的数目。***</div><div class="line"></div><div class="line">### 第三版</div><div class="line"></div><div class="line">用户类，用于网站的客户端账号，是&quot;网站&quot;类的外部状态</div></pre></td></tr></table></figure></p>
<p>//用户<br>public class User<br>{<br>    private string name;<br>    public User(string name)<br>    {<br>        this.name = name;<br>    }<br>    public string name<br>    {<br>        get {return name;}<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">网站抽象类</div></pre></td></tr></table></figure></p>
<p>abstract class WebSite<br>{<br>    public abstract void Use(User user);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">具体网站类</div></pre></td></tr></table></figure></p>
<p>class ConcreteWebSite: WebSite<br>{<br>    private string name = “”;<br>    public ConcreteWebSite(string name)<br>    {<br>        this.name = name;<br>    }</p>
<pre><code>public override void Use(Use user)
{
    Console.WriteLine(&quot;网站分类:&quot; ＋ name + &quot;用户:&quot; + user.name);
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">网站工厂类</div></pre></td></tr></table></figure></p>
<p>class WebSiteFactory<br>{<br>    private Hashtable flyweights = new HashTable();</p>
<pre><code>//获得网站分类
public WebSite GetWebSiteCateegory(string key)
{
    if (!flyweights.ContainsKey(key))
    flyweights.Add(key, new ConcreteWebSite(key));
    return ((webSite)flyweightskey[key]);
}

//获得网站分类总数
public int GetWebSiteCount
{
    return flyweights.Count;
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">客户端代码</div></pre></td></tr></table></figure></p>
<p>static void Main(string[] args)<br>{<br>    WebSiteFactory f = new WebSiteFactory();</p>
<pre><code>WebSite fx = f.GetWebSiteCategory(&quot;产品展示&quot;);
fx.Use(new User(&quot;小菜&quot;));

WebSite fy = f.GetWebSiteCategory(&quot;产品展示&quot;);
fy.Use(new User(&quot;小白&quot;));

WebSite f1 = f.GetWebSiteCategory(&quot;博客&quot;);
f1.Use(new User(&quot;小黑&quot;));

WebSite f2 = f.GetWebSiteCategory(&quot;博客&quot;);
f2.Use(new User(&quot;小绿&quot;));

Console.Read();
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">***如果一个应用程序使用了大量的对象，而大量哒这些对象造成了很大的储存开销时就应该考虑使用；还有就是对象的大多数状态可以外部状态，如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象，此时可以考虑使用享元模式。***</div><div class="line"></div><div class="line"></div><div class="line">## 经典案例 </div><div class="line"></div><div class="line">### Cell的重用</div><div class="line"></div><div class="line"></div><div class="line">![</div><div class="line">][15]</div><div class="line"></div><div class="line">在使用UITableView的时候我们应该熟悉这样的接口：</div></pre></td></tr></table></figure>
<ul>
<li>(id)dequeueReusableCellWithIdentifier:(NSString *)identifier</li>
</ul>
<p>//ios6</p>
<ul>
<li><p>(id)dequeueReusableCellWithIdentifier:(NSString <em>)identifier forIndexPath:(NSIndexPath </em>)indexPath</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">在要使用一个Cell的时候我们先去看看tableView中有没有可以重用的cell，如果有就用这个可以重用的cell，只有在没有的时候才去创建一个Cell。这就是享元模式。</div><div class="line"></div><div class="line">享元模式可以理解成，当细粒度的对象数量特别多的时候运行的代价会相当大，此时运用共享的技术来大大降低运行成本。比较突出的表现就是内容有效的抑制内存抖动的情况发生，还有控制内存增长。它的英文名字是flyweight，让重量飞起来。哈哈。名副其实，在一个TableView中Cell是一个可重复使用的元素，而且往往需要布局的cell数量很大。如果每次使用都创建一个Cell对象，系统的内容抖动会非常明显，而且系统的内存消耗也是比较大的。突然一想，享元模式只是给对象实例共享提供了一个比较霸道的名字吧。</div></pre></td></tr></table></figure>
</li>
<li><p>(DZTableViewCell<em>) dzTableView:(DZTableView </em>)tableView cellAtRow:(NSInteger)row<br>{<br>  static NSString<em> const cellIdentifiy = @”detifail”;<br>  DZTypeCell</em> cell = (DZTypeCell*)[tableView dequeueDZTalbeViewCellForIdentifiy:cellIdentifiy];<br>  if (!cell) {</p>
<pre><code>cell = [[DZTypeCell alloc] initWithIdentifiy:cellIdentifiy];
</code></pre><p>  }<br>  NSString* text = _timeTypes[row];<br>  return cell;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"># 解释器模式(Interpreter Pattern)</div><div class="line"></div><div class="line">## 简介</div><div class="line">解释器模式:给定一个语言，定义它的语法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</div><div class="line"></div><div class="line">解释器模式需要解决的是，如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。</div><div class="line"></div><div class="line">比如说，我们常常会在字符串中搜索匹配字符或判断一个字符串是否符合我们规定的格式，此时一般我们会用正则表达式匹配。解释器为正则表达式定义了一个文法，如何表示一个特定的正则表达式，以及如何解释这个正则表达式。</div><div class="line"></div><div class="line">***当有一个语言需要解释执行，并且你可以将该语言中的句子表示为一个抽象语法树时，可以使用解释器模式。***</div><div class="line"></div><div class="line">用了解释器模式，就意味着可以很容易地改变和扩展文法，因为该模式使用类来表示文法规则，你可以使用继承来改变或者扩展该文法。也比较容易实现文法，因为定义抽象语法树中各个节点的类的实现大体类似，这些类都易于直接编写。</div><div class="line"></div><div class="line">***解释器模式也有不足的，解释器模式为文法中的每一条规则至少定义了一个类，因此包含了许多规则的文法可能难以管理和维护。建议当文法非常复杂时，使用其它的技术如语法分析程序或编译器生成器来处理。***</div><div class="line"></div><div class="line"></div><div class="line">## 实例</div><div class="line">### 音乐解释器</div><div class="line"></div><div class="line"></div><div class="line">演奏内容类(context)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>//演奏内容<br>class PlayContext<br>{<br>    //演奏文本<br>    private string text;<br>    public string PlayText<br>    {<br>        get {return text;}<br>        set {text = value;}<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">表达式类(AbstractExpression)</div></pre></td></tr></table></figure></p>
<p>abstract class Expression<br>{<br>    //解释器<br>    public void Interpret(PlayContext context)<br>    {<br>        if (context.PlayText.Length == 0)<br>        {<br>            return;<br>        }<br>        else<br>        {<br>            //此方法用于将当前演奏文本第一条命令获得命令字母和其参数值。例如”O 3 E 0.5 G 0.5 A 3”则playKey为O而playValue为3<br>            string playKey = context.Playtext.subText.subString(0,1);<br>            context.PlayText = context. PlayText.subString(2);<br>            doublePlayValue = Convert.ToDouble(context.PlayText.SubString(0, context.PlayText.IndexOf(“”)));<br>            context.PlayText = context.PlayText.substring(context.PlayText.IndexOf(“”) + 1);</p>
<pre><code>        Excute(playKey, playValue);
    }
}
//执行
public abstract void Excute(string key, doubel value);
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">音符类(TerminalExpression)</div></pre></td></tr></table></figure></p>
<p>class Note: Expression<br>{<br>    public override void Excute(string key, double value)<br>    {<br>        string note =””;<br>        switch (key)<br>        {<br>            case: “C”:<br>                note = “1”;<br>                break;<br>            case: “D”:<br>                note = “2”;<br>                break;<br>            case: “E”:<br>                note = “3”;<br>                break;<br>            case: “F”:<br>                note = “4”;<br>                break;<br>            case: “G”:<br>                note = “5”;<br>                break;<br>            case: “A”:<br>                note = “6”;<br>                break;<br>            case: “B”:<br>                note = “7”;<br>                break;<br>        }<br>        Console.Write(“{0}”, note);<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">音符类(TerminalExpression)</div></pre></td></tr></table></figure></p>
<p>class Scale: Expression<br>{<br>    public override void Excute(string key, double value)<br>    {<br>        string scale = “”;<br>        switch (Convert.ToInt32(value))<br>        {<br>            case 1:<br>                scale = “低音”;<br>                break;<br>            case 2:<br>                scale = “中音”;<br>                break;<br>            case 3:<br>                scale = “高音”;<br>                break;<br>        }<br>        Console.Write(“{0}”,scale);<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">客户端代码</div></pre></td></tr></table></figure></p>
<p>static void Main(string[] args)<br>{<br>    PlayContext context = new PlayContext();<br>    //音乐-上海滩<br>    Console.WriteLine(“上海滩:”);<br>    context.PlayText = “O 2 E 0.5 G 0.5 A 3 E 0.5 G 0.5 D 3 E 0.5”;<br>    Expression expression = null;<br>    try<br>    {<br>        while (context.PlayText.Length &gt; 0)<br>        {<br>            string str = context.PlayText.Substring(0.1);<br>            switch (str)<br>            {<br>                case “O”:<br>                    expression = new Scale();<br>                    break;<br>                case “C”:<br>                case “D”:<br>                case “E”:<br>                case “F”:<br>                case “G”:<br>                case “A”:<br>                case “A”:<br>                case “B”:<br>                case “P”:<br>                    expression = new Note();<br>                    break;<br>            }<br>            expression.Interpret(context);</p>
<pre><code>    }
}
catch (Exception ex)
{
    Console.WriteLine(ex.Message);
}
Console.Read();
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">比如说 我现在要增加一个文法，就是演奏速度。</div><div class="line"></div><div class="line">音速类</div></pre></td></tr></table></figure></p>
<p>class Speed :Expression<br>{<br>    public override void Excute(string key, double value)<br>    {<br>        string speed;<br>        if (value &lt; 500) {<br>            speed = “快速”;<br>        } else if (value &gt;= 1000)<br>        {<br>            speed = “慢速”;<br>        } else {<br>            speed = “快速”;<br>        }<br>        Console.Write(“{0}”,speed);<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">客户端代码(局部)</div></pre></td></tr></table></figure></p>
<pre><code>context.PlayText = &quot;T 500 O 2 E 0.5 G 0.5 A 3 E 0.5 G 0.5 D 3 E 0.5&quot;;
Expression expression = null;
try
{
    while (context.PlayText.Length &gt; 0)
    {
        string str = context.PlayText.Substring(0.1);
        switch (str)
        {
            case &quot;O&quot;:
                expression = new Scale();
                break;
                case &quot;T&quot;:
                expression = new Speed();
                break;
            case &quot;C&quot;:
            case &quot;D&quot;:
            case &quot;E&quot;:
            case &quot;F&quot;:
            case &quot;G&quot;:
            case &quot;A&quot;:
            case &quot;A&quot;:
            case &quot;B&quot;:
            case &quot;P&quot;:
                expression = new Note();
                break;
        }
        expression.Interpret(context);

    }
}
catch (Exception ex)
{
    Console.WriteLine(ex.Message);
}
Console.Read();
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"># 访问者模式(Visitor Pattern)</div><div class="line"></div><div class="line">## 简介</div><div class="line"></div><div class="line">访问者模式是一种将算法与对象结构分离的软件设计模式。</div><div class="line"></div><div class="line">这个模式的基本想法如下：首先我们拥有一个由许多对象构成的对象结构，这些对象的类都拥有一个accept方法用来接受访问者对象；访问者是一个接口，它拥有一个visit方法，这个方法对访问到的对象结构中不同类型的元素作出不同的反应；在对象结构的一次访问过程中，我们遍历整个对象结构，对每一个元素都实施accept方法，在每一个元素的accept方法中回调访问者的visit方法，从而使访问者得以处理对象结构的每一个元素。我们可以针对对象结构设计不同的实在的访问者类来完成不同的操作。</div><div class="line"></div><div class="line">访问者模式使得我们可以在传统的单分派语言（如Smalltalk、Java和C++）中模拟双分派技术。对于支持多分派的语言（如CLOS），访问者模式已经内置于语言特性之中了，从而不再重要。</div><div class="line"></div><div class="line">```Java</div><div class="line"> interface Visitor &#123;</div><div class="line">     void visit(Wheel wheel);</div><div class="line">     void visit(Engine engine);</div><div class="line">     void visit(Body body);</div><div class="line">     void visit(Car car);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> class Wheel &#123;</div><div class="line">     private String name;</div><div class="line">     Wheel(String name) &#123;</div><div class="line">         this.name = name;</div><div class="line">     &#125;</div><div class="line">     String getName() &#123;</div><div class="line">         return this.name;</div><div class="line">     &#125;</div><div class="line">     void accept(Visitor visitor) &#123;</div><div class="line">         visitor.visit(this);</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line">  </div><div class="line"> class Engine &#123;</div><div class="line">     void accept(Visitor visitor) &#123;</div><div class="line">         visitor.visit(this);</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> class Body &#123;</div><div class="line">     void accept(Visitor visitor) &#123;</div><div class="line">         visitor.visit(this);</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> class Car &#123;</div><div class="line">     private Engine  engine = new Engine();</div><div class="line">     private Body    body   = new Body();</div><div class="line">     private Wheel[] wheels </div><div class="line">         = &#123; new Wheel(&quot;front left&quot;), new Wheel(&quot;front right&quot;),</div><div class="line">             new Wheel(&quot;back left&quot;) , new Wheel(&quot;back right&quot;)  &#125;;</div><div class="line">     void accept(Visitor visitor) &#123;</div><div class="line">         visitor.visit(this);</div><div class="line">         engine.accept(visitor);</div><div class="line">         body.accept(visitor);</div><div class="line">         for (int i = 0; i &lt; wheels.length; ++ i)</div><div class="line">             wheels[i].accept(visitor);</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> class PrintVisitor implements Visitor &#123;</div><div class="line">     public void visit(Wheel wheel) &#123;</div><div class="line">         System.out.println(&quot;Visiting &quot; + wheel.getName()</div><div class="line">                             + &quot; wheel&quot;);</div><div class="line">     &#125;</div><div class="line">     public void visit(Engine engine) &#123;</div><div class="line">         System.out.println(&quot;Visiting engine&quot;);</div><div class="line">     &#125;</div><div class="line">     public void visit(Body body) &#123;</div><div class="line">         System.out.println(&quot;Visiting body&quot;);</div><div class="line">     &#125;</div><div class="line">     public void visit(Car car) &#123;</div><div class="line">         System.out.println(&quot;Visiting car&quot;);</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> public class VisitorDemo &#123;</div><div class="line">     static public void main(String[] args) &#123;</div><div class="line">         Car car = new Car();</div><div class="line">         Visitor visitor = new PrintVisitor();</div><div class="line">         car.accept(visitor);</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><h3 id="男人和女人"><a href="#男人和女人" class="headerlink" title="男人和女人"></a>男人和女人</h3><p>‘人’类，是’男人’和’女人’类的抽象类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">abstract class person</div><div class="line">&#123;</div><div class="line">	protected string action;</div><div class="line">	public string Action</div><div class="line">	&#123;</div><div class="line">		get &#123;return action;&#125;</div><div class="line">		set &#123;action = value&#125;;</div><div class="line">	&#125;</div><div class="line">	//得到结论或者反应</div><div class="line">	public abstract void GetConclusion();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>“男人”类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class Man: Person</div><div class="line">&#123;</div><div class="line">	//得到结论或反应</div><div class="line">	public override void GetConclusion()</div><div class="line">	&#123;</div><div class="line">		if (action == &quot;成功&quot;)</div><div class="line">		&#123;</div><div class="line">			Console.WriteLine(&quot;&#123;0&#125;&#123;1&#125;时，背后多半有一个伟大的女人&quot;,this.GetType().name,action);</div><div class="line">		&#125;</div><div class="line">		else if (action == &quot;失败&quot;)</div><div class="line">		&#123;</div><div class="line">			Console.WriteLine(&quot;&#123;0&#125;&#123;1&#125;时，&quot;蒙头喝酒，谁也不用劝&quot;,this.GetType().name,action);</div><div class="line">		&#125;</div><div class="line">		else if (action == &quot;恋爱&quot;)</div><div class="line">		&#123;</div><div class="line">			Console.WriteLine(&quot;&#123;0&#125;&#123;1&#125;时，&quot;凡事不懂也要装懂&quot;,this.GetType().name,action);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>“女人”类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class Woman: Person</div><div class="line">&#123;</div><div class="line">	//得到结论或反应</div><div class="line">	public override void GetConclusion()</div><div class="line">	&#123;</div><div class="line">		if (action == &quot;成功&quot;)</div><div class="line">		&#123;</div><div class="line">			Console.WriteLine(&quot;&#123;0&#125;&#123;1&#125;时，背后多半有一个不成功的男人&quot;,this.GetType().name,action);</div><div class="line">		&#125;</div><div class="line">		else if (action == &quot;失败&quot;)</div><div class="line">		&#123;</div><div class="line">			Console.WriteLine(&quot;&#123;0&#125;&#123;1&#125;时，&quot;泪眼汪汪，谁也劝不了&quot;,this.GetType().name,action);</div><div class="line">		&#125;</div><div class="line">		else if (action == &quot;恋爱&quot;)</div><div class="line">		&#123;</div><div class="line">			Console.WriteLine(&quot;&#123;0&#125;&#123;1&#125;时，&quot;凡事懂也要装不懂&quot;,this.GetType().name,action);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>客户端代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">static void Main(string[] args)</div><div class="line">&#123;</div><div class="line">	IList&lt;Person&gt; persons = new List&lt;Person&gt;();</div><div class="line">	</div><div class="line">	Person man1 = new Man();</div><div class="line">	man1.Action = &quot;成功&quot;;</div><div class="line">	persons.add(man1);</div><div class="line">	Person woman1 = new Woman();</div><div class="line">	woman1.Action = &quot;成功&quot;;</div><div class="line">	persons.add(woman1);</div><div class="line">	</div><div class="line">	Person man2 = new Man();</div><div class="line">	man2.Action = &quot;失败&quot;;</div><div class="line">	persons.add(man2);</div><div class="line">	Person woman2 = new Woman();</div><div class="line">	woman2.Action = &quot;失败&quot;;</div><div class="line">	persons.add(woman2);</div><div class="line">	</div><div class="line">	Person man3 = new Man();</div><div class="line">	man3.Action = &quot;恋爱&quot;;</div><div class="line">	persons.add(man3);</div><div class="line">	Person woman3 = new Woman();</div><div class="line">	woman3.Action = &quot;恋爱&quot;;</div><div class="line">	persons.add(woman3);</div><div class="line">	</div><div class="line">	foreach (Person item in persons)</div><div class="line">	&#123;</div><div class="line">		item.GetConclusion();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	Console.Read();</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个算是面向对象编程，但是’男人’和’女人’类当中的那些if….else….很是碍眼。而且如果我们增加一个’结婚状态’,怎么改？</p>
<h3 id="用模式实现"><a href="#用模式实现" class="headerlink" title="用模式实现"></a>用模式实现</h3><p>‘状态’的抽象和’人’的抽象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">abstract class Action</div><div class="line">&#123;</div><div class="line">	//得到男人结论或反应</div><div class="line">	public abstract void GetManConclusion(Man concreteElementA);</div><div class="line">	public abstract void GetWomanConclusion(Woman concreteElementB);</div><div class="line">&#125;</div><div class="line"></div><div class="line">abstract class Person</div><div class="line">&#123;</div><div class="line">	//接受</div><div class="line">	public abstract void Accept(Action visitor);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体”状态”类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">//成功</div><div class="line">class Success: Action</div><div class="line">&#123;</div><div class="line">	public override void GetManConclusion(Man concreteElementA)</div><div class="line">	&#123;</div><div class="line">		Console.WriteLine(&quot;&#123;0&#125;&#123;1&#125;时，背后多半有一个伟大的女人&quot;,this.GetType().name,action);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public abstract void GetWomanConclusion(Woman concreteElementB)</div><div class="line">	&#123;</div><div class="line">		Console.WriteLine(&quot;&#123;0&#125;&#123;1&#125;时，背后多半有一个不成功的男人&quot;,this.GetType().name,action);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//失败</div><div class="line">class Falling: Action</div><div class="line">&#123;</div><div class="line">	public override void GetManConclusion(Man concreteElementA)</div><div class="line">	&#123;</div><div class="line">		Console.WriteLine(&quot;&#123;0&#125;&#123;1&#125;时，&quot;蒙头喝酒，谁也不用劝&quot;,this.GetType().name,action);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public abstract void GetWomanConclusion(Woman concreteElementB)</div><div class="line">	&#123;</div><div class="line">		Console.WriteLine(&quot;&#123;0&#125;&#123;1&#125;时，&quot;泪眼汪汪，谁也劝不了&quot;,this.GetType().name,action);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//恋爱</div><div class="line">class Amativeness: Action</div><div class="line">&#123;</div><div class="line">	public override void GetManConclusion(Man concreteElementA)</div><div class="line">	&#123;</div><div class="line">		Console.WriteLine(&quot;&#123;0&#125;&#123;1&#125;时，&quot;凡事不懂也要装懂&quot;,this.GetType().name,action);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public abstract void GetWomanConclusion(Woman concreteElementB)</div><div class="line">	&#123;</div><div class="line">		Console.WriteLine(&quot;&#123;0&#125;&#123;1&#125;时，&quot;凡事懂也要装不懂&quot;,this.GetType().name,action);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>“男人”类和”女人”类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//男人</div><div class="line">class Man : Person</div><div class="line">&#123;</div><div class="line">	public override void Accept(Action visitor)</div><div class="line">	&#123;</div><div class="line">		//***</div><div class="line">		visitor.GetManConclusion(this);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//女人</div><div class="line">class Woman : Person</div><div class="line">&#123;</div><div class="line">	public override void Accept(Action visitor)</div><div class="line">	&#123;</div><div class="line">		//***</div><div class="line">		visitor.GetWomanConclusion(this);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里需要讲下双派技术，首先客户端将具体状态作为参数传递给”男人”完成了一次分派，然后男人类调用方法”男人反应”,同时将自己作为参数传递进去。这便完成了第二次分派。双分派意味着得到执行的操作决定于请求的种类和两种接受者的类型。”接受”方法就是一个双分派的操作，它得到执行的操作不仅决定于’状态’类的具体状态，还决定于它访问的’人’的类别。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//对象结构</div><div class="line">class ObjectStructure</div><div class="line">&#123;</div><div class="line">	private IList&lt;Person&gt;elements = new List&lt;Person&gt;();</div><div class="line">	</div><div class="line">	//增加</div><div class="line">	public void Attach(Person element)</div><div class="line">	&#123;</div><div class="line">		elements.Add(element);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//移除</div><div class="line">	public void Detach(Person element)</div><div class="line">	&#123;</div><div class="line">		elements.Remove(element);</div><div class="line">	&#125;	</div><div class="line">	</div><div class="line">	//查看显示</div><div class="line">	public void Display(Action visitor)</div><div class="line">	&#123;</div><div class="line">		foreach(Person e in elements)</div><div class="line">		&#123;</div><div class="line">			e.Accept(visitor);</div><div class="line">		&#125;</div><div class="line">	&#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>客户端代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">static void Main(string[] args)</div><div class="line">&#123;</div><div class="line">	ObjectStructure o = new ObjectStructure();</div><div class="line">	o.Attach(new Man());</div><div class="line">	o.Attach(new Man());</div><div class="line">	</div><div class="line">	//成功时反应</div><div class="line">	Success v1 = new Success();</div><div class="line">	o.Display(v1);</div><div class="line"></div><div class="line">	//失败时反应</div><div class="line">	Success v1 = new Success();</div><div class="line">	o.Display(v1);</div><div class="line"></div><div class="line">	//恋爱时反应</div><div class="line">	Success v1 = new Success();</div><div class="line">	o.Display(v1);</div><div class="line">	</div><div class="line">	Console.Read();</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>访问者适合于数据结构相对稳定的系统。它把数据结构和作用于结构之上的操作之间的耦合解脱开来，使得操作集合可以相对自由地y演化。</em></strong></p>
<p><strong><em>访问者模式的目的是要把处理从数据结构分离出来。如果这样的系统有比较稳定的数据结构，又有易于变化的算法的话，使用访问者模式就是比较适合的，因为访问者模式使得算法操作的增加变得容易。</em></strong></p>
<p><strong><em>那其实访问者模式的优点就是增加新的操作很容易，因为增加新的操作就意味着增加一个新的访问者,访问者模式将有关的行为集中到一个访问者对象中。</em></strong></p>
<p><strong><em>那访问者的缺点其实也就是使得增加新的数据结构变的困难了。</em></strong></p>
<p>正如《设计模式》的作者GoF对访问者模式的描述：大多数情况下，你并需要使用访问者模式，但是当你一旦需要使用它时，那你就是真的需要它了。当然这只是针对真正的大牛而言。在现实情况下（至少是我所处的环境当中），很多人往往沉迷于设计模式，他们使用一种设计模式时，从来不去认真考虑所使用的模式是否适合这种场景，而往往只是想展示一下自己对面向对象设计的驾驭能力。编程时有这种心理，往往会发生滥用设计模式的情况。所以，在学习设计模式时，一定要理解模式的适用性。必须做到使用一种模式是因为了解它的优点，不使用一种模式是因为了解它的弊端；而不是使用一种模式是因为不了解它的弊端，不使用一种模式是因为不了解它的优点。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">设计模式</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/05/20/设计模式/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-面向对象设计原则" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/03/面向对象设计原则/">面向对象设计原则</a>
    </h1>
  

        
        <a href="/2017/05/03/面向对象设计原则/" class="archive-article-date">
  	<time datetime="2017-05-03T00:35:32.794Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-05-03</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="面向对象的三个基本特征：封装，继承，多态"><a href="#面向对象的三个基本特征：封装，继承，多态" class="headerlink" title="面向对象的三个基本特征：封装，继承，多态"></a>面向对象的三个基本特征：封装，继承，多态</h2><h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><ul>
<li><h3 id="迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用"><a href="#迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用" class="headerlink" title="迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用"></a>迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用</h3><blockquote>
<p>又叫最少知道原则。是强调了类之间的松耦合，类之间的耦合越弱,越有利于复用，<br>一个处在弱耦合的类被修改，不会对有关系的类造成影响，也就是说，信息的隐藏促进了软件的复用。</p>
</blockquote>
</li>
<li><h3 id="里氏代换原则：所有引用基类对象的地方能够透明地使用其子类的对象"><a href="#里氏代换原则：所有引用基类对象的地方能够透明地使用其子类的对象" class="headerlink" title="里氏代换原则：所有引用基类对象的地方能够透明地使用其子类的对象"></a>里氏代换原则：所有引用基类对象的地方能够透明地使用其子类的对象</h3><blockquote>
<p>定义1: 如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，<br>使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，<br>程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。</p>
<p>定义2：子类型必须能够替换掉它们的父类型</p>
</blockquote>
</li>
<li><h3 id="开闭原则-软件实体应对扩展开放，而对修改关闭"><a href="#开闭原则-软件实体应对扩展开放，而对修改关闭" class="headerlink" title="开闭原则:  软件实体应对扩展开放，而对修改关闭"></a>开闭原则:  软件实体应对扩展开放，而对修改关闭</h3><blockquote>
<p>开闭原则就是说对扩展开放，对修改关闭。<br>在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。<br>所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。<br>想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p>
</blockquote>
</li>
<li><h3 id="单一职责原则-一个类只负责一个功能领域中的相应职责"><a href="#单一职责原则-一个类只负责一个功能领域中的相应职责" class="headerlink" title="单一职责原则:一个类只负责一个功能领域中的相应职责"></a>单一职责原则:一个类只负责一个功能领域中的相应职责</h3><blockquote>
<p>不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责，<br>应该仅有一个引起它变化的原因。</p>
</blockquote>
<p><strong>遵循单一职责原的优点有：</strong></p>
<ol>
<li>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；</li>
<li>提高类的可读性，提高系统的可维护性；</li>
<li>变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。</li>
</ol>
</li>
<li><h3 id="依赖倒转原则：抽象不应该依赖于细节，细节应该依赖于抽象"><a href="#依赖倒转原则：抽象不应该依赖于细节，细节应该依赖于抽象" class="headerlink" title="依赖倒转原则：抽象不应该依赖于细节，细节应该依赖于抽象"></a>依赖倒转原则：抽象不应该依赖于细节，细节应该依赖于抽象</h3><blockquote>
<p>高层模块不应该依赖低层模块，二者都应该依赖其抽象；<br>抽象不应该依赖细节；细节应该依赖抽象。即针对接口编程，不要针对实现编程。</p>
</blockquote>
<p><strong>在实际编程中，我们一般需要做到如下3点：</strong></p>
<ul>
<li>低层模块尽量都要有抽象类或接口，或者两者都有。</li>
<li>变量的声明类型尽量是抽象类或接口。</li>
<li>使用继承时遵循里氏替换原则。</li>
</ul>
</li>
<li><h3 id="接口隔离原则：使用多个专门的接口，而不使用单一的总接口"><a href="#接口隔离原则：使用多个专门的接口，而不使用单一的总接口" class="headerlink" title="接口隔离原则：使用多个专门的接口，而不使用单一的总接口"></a>接口隔离原则：使用多个专门的接口，而不使用单一的总接口</h3><blockquote>
<p>使用多个隔离的接口，比使用单个接口要好。<br>还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，<br>从大型软件架构出发，为了升级和维护方便。<br>所以上文中多次出现：降低依赖，降低耦合。</p>
</blockquote>
</li>
<li><h3 id="合成复用原则：尽量使用对象组合，而不是继承来达到复用的目的"><a href="#合成复用原则：尽量使用对象组合，而不是继承来达到复用的目的" class="headerlink" title="合成复用原则：尽量使用对象组合，而不是继承来达到复用的目的"></a>合成复用原则：尽量使用对象组合，而不是继承来达到复用的目的</h3><blockquote>
<p>要尽量的使用合成和聚合，而不是继承关系达到复用的目的.<br>  该原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分：<br>  新的对象通过向这些对象的委派达到复用已有功能的目的。</p>
</blockquote>
</li>
</ul>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">设计模式</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/05/03/面向对象设计原则/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-理解ThreadLocal" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/02/理解ThreadLocal/">理解ThreadLocal</a>
    </h1>
  

        
        <a href="/2017/05/02/理解ThreadLocal/" class="archive-article-date">
  	<time datetime="2017-05-02T14:28:08.066Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-05-02</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="理解ThreadLocal"><a href="#理解ThreadLocal" class="headerlink" title="理解ThreadLocal"></a>理解ThreadLocal</h3><p>java中可以使用public static设置一个全局变量，所有线程都共享这个变量。<br>但是有时，我们需要每一个线程都有一个自己的共享变量，ThreadLocal就是一个不错的解决方案。</p>
<p>java8中对ThreadLocal的解释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">This class provides thread-local variables. </div><div class="line">These variables differ from their normal counterparts in that each thread that accesses one </div><div class="line">(via its get or set method)has its own, independently initialized copy of the variable. </div><div class="line">ThreadLocal instances are typically private static fields in classes that wish to associate state with a</div><div class="line"> thread (e.g., a user ID or Transaction ID).</div></pre></td></tr></table></figure></p>
<p>对其理解：</p>
<ul>
<li><p>每个线程单独保存这个变量，对其他线程不可见。</p>
</li>
<li><p>ThreadLocal可以给一个初始值，而每个线程都会获得这个初始化值的一个副本，也可以new的方式为线程创建一个变量。</p>
</li>
<li><p>ThreadLocal 不是用于解决共享变量的问题的，不是为了协调线程同步而存在，而是为了方便每个线程处理自己的状态而引入的一个机制。</p>
</li>
</ul>
<h3 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a>ThreadLocal的使用</h3><ul>
<li><p>ThreadLocal几个主要操作方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public T get() &#123;...&#125;//获取线程变量对象</div><div class="line">public void remove() &#123;...&#125;//移除线程变量对象，将对线程变量对象的引用设置为null</div><div class="line">public void set(T value) &#123;...&#125;//添加线程变量对象</div><div class="line">protected T initialValue() &#123;...&#125;//设置初始化数据，覆盖该方法可以设置初始默认值</div></pre></td></tr></table></figure>
</li>
<li><p>使用的小demo</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; local=() -&gt; <span class="number">0</span>;<span class="comment">//覆盖initialValue方法设置初始值。</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Thread[] threads=<span class="keyword">new</span> Thread[<span class="number">3</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</div><div class="line">            threads[i]=() -&gt; &#123;</div><div class="line">                 <span class="keyword">int</span> mun=local.get();</div><div class="line">                 <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)&#123;</div><div class="line">                     mun=mun+<span class="number">1</span>;</div><div class="line">                 &#125;</div><div class="line">                 local.set(mun);</div><div class="line">                 System.out.println(Thread.currentThread().getName()+<span class="string">"==="</span>+local.get());</div><div class="line">                &#125;;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(Thread t:threads)&#123;</div><div class="line">            t.start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Thread-3===10</div><div class="line">Thread-2===10</div><div class="line">Thread-1===10</div></pre></td></tr></table></figure></p>
<p>可以看出线程之间互不影响。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ol>
<li>ThreadLocal中的静态内部类ThreadLocalMap<br>可以看到Entry 类继承了 WeakReference<threadlocal<?>&gt;，<br>即每个Entry对象都有一个ThreadLocal的弱引用（作为key）。<br>一旦线程结束，key变为一个不可达的对象，这个Entry就可以被GC了。</threadlocal<?></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</div><div class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</div><div class="line">            Object value;</div><div class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</div><div class="line">                <span class="keyword">super</span>(k);</div><div class="line">                value = v;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>ThreadLocal类中有一个静态内部类ThreadLocalMap，用来存放线程变量。</p>
</li>
<li><p>ThreadLocalMap里面有一个Entry数组，根据ThreadLocal变量本身的哈希值将线程变量的值存入散列到数组中。</p>
</li>
</ul>
<ol>
<li>ThreadLocal的set方法及延伸</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span></span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">             Thread t = Thread.currentThread();<span class="comment">//获取当前线程对象</span></div><div class="line">             ThreadLocalMap map = getMap(t);<span class="comment">//获取当前线程内的ThreadLocalMap</span></div><div class="line">             <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">                 map.set(<span class="keyword">this</span>, value);<span class="comment">//如果map已经设置，则直接赋值</span></div><div class="line">             <span class="keyword">else</span></div><div class="line">                 createMap(t, value);<span class="comment">//还没有设置，就实例化一个ThreadLocalMap</span></div><div class="line">      &#125;</div><div class="line">      <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</div><div class="line">              t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</div><div class="line">          &#125;</div><div class="line">          </div><div class="line">     <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span></span>&#123;</div><div class="line">         <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</div><div class="line">        ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</div><div class="line">             table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];<span class="comment">//开辟一个大小为16的数组</span></div><div class="line">             <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</div><div class="line">             table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</div><div class="line">             size = <span class="number">1</span>;</div><div class="line">             setThreshold(INITIAL_CAPACITY);<span class="comment">// 设置扩容的阈值</span></div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreshold</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line">                    threshold = len * <span class="number">2</span> / <span class="number">3</span>;</div><div class="line">        &#125;</div><div class="line">     &#125;</div><div class="line">   <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>ThreadLocalMap的set方法及延伸<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal key, Object value)</span> </span>&#123;</div><div class="line">    Entry[] tab = table;</div><div class="line">    <span class="keyword">int</span> len = tab.length;</div><div class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 使用的是开放地址法解决冲突，如果发生碰撞则向后查找</span></div><div class="line">    <span class="comment">// 如果得到的i位置已经有值，那么就向后一个单位尝试填充</span></div><div class="line">    <span class="keyword">for</span> (Entry e = tab[i];</div><div class="line">         e != <span class="keyword">null</span>;</div><div class="line">         e = tab[i = nextIndex(i, len)]) &#123;</div><div class="line">        ThreadLocal k = e.get();</div><div class="line">        <span class="comment">// 如果是相同的key就替换，说明同一个对象中的</span></div><div class="line">        <span class="comment">// 同一个threadLocal变量</span></div><div class="line">        <span class="keyword">if</span> (k == key) &#123;</div><div class="line">            e.value = value;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 因为是弱引用，ThreadLocal已经被回收，所以key就是null，将value放在这个位置</span></div><div class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</div><div class="line">            replaceStaleEntry(key, value, i);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 直到找到一个元素为空的位置（e == null），</span></div><div class="line">    <span class="comment">// 每新占用一个数组位置（上面都是在替换原来元素或者替换</span></div><div class="line">    <span class="comment">// 已经被移除的元素，size已经加过的）就要判断是否需要进行扩容</span></div><div class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</div><div class="line">    <span class="keyword">int</span> sz = ++size;</div><div class="line">    <span class="comment">// 如果没有清除数组中的元素并且元素个数已经大于等于阈值threshold则进行扩容</span></div><div class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</div><div class="line">        rehash();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 扫描数组清除陈旧的数据，但并不是全部扫描，而是log2(n)对数扫描</span></div><div class="line"><span class="comment">// 在全部扫描和不扫描之间取一个折中</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</div><div class="line">    Entry[] tab = table;</div><div class="line">    <span class="keyword">int</span> len = tab.length;</div><div class="line"></div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        i = nextIndex(i, len);</div><div class="line">        Entry e = tab[i];</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</div><div class="line">            n = len;</div><div class="line">            removed = <span class="keyword">true</span>;</div><div class="line">            i = expungeStaleEntry(i);</div><div class="line">        &#125;</div><div class="line">    <span class="comment">// 无符号右移一位，相当于每次除2取整</span></div><div class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span> removed;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="ThreadLocal内存泄漏"><a href="#ThreadLocal内存泄漏" class="headerlink" title="ThreadLocal内存泄漏"></a>ThreadLocal内存泄漏</h3><p>虽然ThreadLocal的Entry继承自WeakReference，为弱引用，但是依然可能发生内存泄漏。<br>可以参考：<a href="http://www.linkedkeeper.com/detail/blog.action?bid=58" target="_blank" rel="external">http://www.linkedkeeper.com/detail/blog.action?bid=58</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.cnblogs.com/chengxiao/p/6152824.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">http://www.cnblogs.com/chengxiao/p/6152824.html?utm_source=tuicool&amp;utm_medium=referral</a></li>
<li><a href="http://blog.csdn.net/baidu_23086307/article/details/56674454?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">http://blog.csdn.net/baidu_23086307/article/details/56674454?utm_source=tuicool&amp;utm_medium=referral</a></li>
<li><a href="http://qlm.pw/2016/09/22/%E5%85%B3%E4%BA%8Ethreadlocal%E5%AF%B9%E8%B1%A1/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">http://qlm.pw/2016/09/22/%E5%85%B3%E4%BA%8Ethreadlocal%E5%AF%B9%E8%B1%A1/?utm_source=tuicool&amp;utm_medium=referral</a></li>
<li><a href="http://www.cnblogs.com/whoislcj/p/5811989.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">http://www.cnblogs.com/whoislcj/p/5811989.html?utm_source=tuicool&amp;utm_medium=referral</a></li>
<li><a href="http://www.cnblogs.com/sunshine-2015/p/6072184.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">http://www.cnblogs.com/sunshine-2015/p/6072184.html?utm_source=tuicool&amp;utm_medium=referral</a></li>
<li><a href="http://www.sczyh30.com/posts/Java/java-concurrent-threadlocal/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">http://www.sczyh30.com/posts/Java/java-concurrent-threadlocal/?utm_source=tuicool&amp;utm_medium=referral</a></li>
<li><a href="http://www.linkedkeeper.com/detail/blog.action?bid=58" target="_blank" rel="external">http://www.linkedkeeper.com/detail/blog.action?bid=58</a></li>
</ul>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">java</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/05/02/理解ThreadLocal/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-synchronized" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/02/synchronized/">synchronized</a>
    </h1>
  

        
        <a href="/2017/05/02/synchronized/" class="archive-article-date">
  	<time datetime="2017-05-02T14:13:12.023Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-05-02</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="synchronized同步方法"><a href="#synchronized同步方法" class="headerlink" title="synchronized同步方法"></a>synchronized同步方法</h2><ul>
<li><p><strong>方法的变量不存在非线程安全问题，永远都是线程安全的。</strong></p>
</li>
<li><p><strong>实例变量为非线程安全。</strong></p>
</li>
<li><p><strong>多个对象则有多个锁。</strong>非静态同步方法的锁为对象锁，当存在多个对象的时候，JVM就会创建多个锁。</p>
</li>
<li><p><strong>锁对象。</strong></p>
<ol>
<li><p>所有的非静态同步方法用的都是同一把锁——实例对象本身</p>
<blockquote>
<p>也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。</p>
</blockquote>
</li>
<li><p>所有的静态同步方法用的也是同一把锁——类对象本身</p>
<blockquote>
<p>静态同步方法与非静态同步方法之间是不会有竞态条件的。但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！</p>
</blockquote>
</li>
</ol>
</li>
<li><p><strong>只有共享资源的读写访问需要同步化，</strong>如果非共享资源，则根本没有同步化的必要。</p>
</li>
<li><p>A线程先持有对象的Lock锁，B线程可以异步的方式调用该对象的非synchronized方法；A线程先持有对象的Lock锁，B线程此时调用该对象的synchronized方法，则需要等待，也就是同步。</p>
</li>
<li><p><strong>同步不可以继承。</strong>要想子类的方法同步，也需要加上synchronized关键字。</p>
</li>
<li><p><strong>出现异常，自动释放锁。</strong>当一个线程执行的代码出现异常时，其所持有的锁会自动释放。</p>
</li>
<li><p><strong>锁重入。</strong>在一个synchronized方法/块内部调用本类的其他的synchronized方法/块时，是永远可以得到锁的；当存在父子类继承关系时，子类完全可以通过”可重入锁”调用父类的同步方法的。</p>
</li>
<li><p><strong>脏读。</strong>生脏读的情况是在读取实例变量时，此值已经被其他线程更改过了，脏读一定发生在操作实例变量的情况下，这就是不同线程“争抢”实例变量的结果。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">		<span class="comment">//测试synchronized类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PublicVar</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> String username=<span class="string">"A"</span>;</div><div class="line">    <span class="keyword">public</span> String password=<span class="string">"AA"</span>;</div><div class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String username,String password)</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">this</span>.username=username;</div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">            <span class="keyword">this</span>.password=password;</div><div class="line">            System.out.println(<span class="string">"thread:"</span>+Thread.currentThread().getName()+</div><div class="line">                    <span class="string">" username"</span>+<span class="keyword">this</span>.username+<span class="string">" password"</span>+<span class="keyword">this</span>.password);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"thread:"</span>+Thread.currentThread().getName()+</div><div class="line">                <span class="string">" username"</span>+<span class="keyword">this</span>.username+<span class="string">" password"</span>+<span class="keyword">this</span>.password);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//测试线程</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> PublicVar publicVar;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(PublicVar publicVar)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.publicVar = publicVar;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.run();</div><div class="line">        publicVar.setValue(<span class="string">"B"</span>,<span class="string">"BB"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//测试入口</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrMain</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            PublicVar publicVar=<span class="keyword">new</span> PublicVar();</div><div class="line">            ThreadA threadA=<span class="keyword">new</span> ThreadA(publicVar);</div><div class="line">            threadA.start();</div><div class="line">            threadA.sleep(<span class="number">200</span>);</div><div class="line">            publicVar.getValue();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">结果：</div><div class="line">thread:main usernameB passwordAA  //发生了脏读</div><div class="line">thread:Thread-0 usernameB passwordBB</div></pre></td></tr></table></figure>
<h2 id="synchronized同步代码块"><a href="#synchronized同步代码块" class="headerlink" title="synchronized同步代码块"></a>synchronized同步代码块</h2><ul>
<li><p>synchronized方法是对当前对象加锁，而synchronized同步代码块是对某一个对象进行加锁。</p>
</li>
<li><p>在synchronized同步代码块中的就是同步执行，不在就是异步执行。</p>
</li>
<li><p>静态同步synchronized方法和synchronized(class)代码块的锁都是*.java文件对应的Class类进行持锁。</p>
</li>
<li><p>同步synchronized代码块不使用String作为锁对象，因为String的常量池的影响，而改用其他，比如new Object()实例化对象</p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h2><ul>
<li>JAVA多线程编程核心技术</li>
<li>JAVA编程思想</li>
</ul>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">java</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/05/02/synchronized/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-clean-code-js" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/30/clean-code-js/">clean-code-js</a>
    </h1>
  

        
        <a href="/2017/04/30/clean-code-js/" class="archive-article-date">
  	<time datetime="2017-04-30T03:18:30.969Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-04-30</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Original Repository: <a href="https://github.com/ryanmcdermott/clean-code-javascript" target="_blank" rel="external">ryanmcdermott/clean-code-javascript</a></p>
<h1 id="JavaScript-风格指南"><a href="#JavaScript-风格指南" class="headerlink" title="JavaScript 风格指南"></a>JavaScript 风格指南</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li><a href="#介绍">介绍</a></li>
<li><a href="#变量">变量</a></li>
<li><a href="#函数">函数</a></li>
<li><a href="#objects-and-data-structures">对象和数据结构</a></li>
<li><a href="#类">类</a></li>
<li><a href="#测试">测试</a></li>
<li><a href="#并发">并发</a></li>
<li><a href="#错误处理">错误处理</a></li>
<li><a href="#格式化">格式化</a></li>
<li><a href="#注释">注释</a></li>
</ol>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://github.com/ryanmcdermott" target="_blank" rel="external">作者</a>根据 Robert C. Martin <a href="https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882" target="_blank" rel="external"><em>《代码整洁之道》</em></a>总结了适用于 JavaScript 的软件工程原则<a href="https://github.com/ryanmcdermott/clean-code-javascript" target="_blank" rel="external">《Clean Code JavaScript》</a>。</p>
<p>本文是对其的翻译。</p>
<p>不必严格遵守本文的所有原则，有时少遵守一些效果可能会更好，具体应根据实际情况决定。这是根据《代码整洁之道》作者多年经验整理的代码优化建议，但也仅仅只是一份建议。</p>
<p>软件工程已经发展了 50 多年，至今仍在不断前进。现在，把这些原则当作试金石，尝试将他们作为团队代码质量考核的标准之一吧。</p>
<p>最后你需要知道的是，这些东西不会让你立刻变成一个优秀的工程师，长期奉行他们也并不意味着你能够高枕无忧不再犯错。千里之行，始于足下。我们需要时常和同行们进行代码评审，不断优化自己的代码。不要惧怕改善代码质量所需付出的努力，加油。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h2><h3 id="使用有意义，可读性好的变量名"><a href="#使用有意义，可读性好的变量名" class="headerlink" title="使用有意义，可读性好的变量名"></a>使用有意义，可读性好的变量名</h3><p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> yyyymmdstr = moment().format(<span class="string">'YYYY/MM/DD'</span>);</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> yearMonthDay = moment().format(<span class="string">'YYYY/MM/DD'</span>);</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="使用-ES6-的-const-定义常量"><a href="#使用-ES6-的-const-定义常量" class="headerlink" title="使用 ES6 的 const 定义常量"></a>使用 ES6 的 const 定义常量</h3><p>反例中使用”var”定义的”常量”是可变的。</p>
<p>在声明一个常量时，该常量在整个程序中都应该是不可变的。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> FIRST_US_PRESIDENT = <span class="string">"George Washington"</span>;</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> FIRST_US_PRESIDENT = <span class="string">"George Washington"</span>;</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="对功能类似的变量名采用统一的命名风格"><a href="#对功能类似的变量名采用统一的命名风格" class="headerlink" title="对功能类似的变量名采用统一的命名风格"></a>对功能类似的变量名采用统一的命名风格</h3><p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">getUserInfo();</div><div class="line">getClientData();</div><div class="line">getCustomerRecord();</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">getUser();</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="使用易于检索名称"><a href="#使用易于检索名称" class="headerlink" title="使用易于检索名称"></a>使用易于检索名称</h3><p>我们需要阅读的代码远比自己写的要多，使代码拥有良好的可读性且易于检索非常重要。阅读变量名晦涩难懂的代码对读者来说是一种相当糟糕的体验。<br>让你的变量名易于检索。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 525600 是什么?</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">525600</span>; i++) &#123;</div><div class="line">  runCronJob();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Declare them as capitalized `var` globals.</span></div><div class="line"><span class="keyword">var</span> MINUTES_IN_A_YEAR = <span class="number">525600</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; MINUTES_IN_A_YEAR; i++) &#123;</div><div class="line">  runCronJob();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="使用说明变量-即有意义的变量名"><a href="#使用说明变量-即有意义的变量名" class="headerlink" title="使用说明变量(即有意义的变量名)"></a>使用说明变量(即有意义的变量名)</h3><p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> cityStateRegex = <span class="regexp">/^(.+)[,\\s]+(.+?)\s*(\d&#123;5&#125;)?$/</span>;</div><div class="line">saveCityState(cityStateRegex.match(cityStateRegex)[<span class="number">1</span>], cityStateRegex.match(cityStateRegex)[<span class="number">2</span>]);</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> cityStateRegex = <span class="regexp">/^(.+)[,\\s]+(.+?)\s*(\d&#123;5&#125;)?$/</span>;</div><div class="line"><span class="keyword">const</span> match = cityStateRegex.match(cityStateRegex)</div><div class="line"><span class="keyword">const</span> city = match[<span class="number">1</span>];</div><div class="line"><span class="keyword">const</span> state = match[<span class="number">2</span>];</div><div class="line">saveCityState(city, state);</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="不要绕太多的弯子"><a href="#不要绕太多的弯子" class="headerlink" title="不要绕太多的弯子"></a>不要绕太多的弯子</h3><p>显式优于隐式。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> locations = [<span class="string">'Austin'</span>, <span class="string">'New York'</span>, <span class="string">'San Francisco'</span>];</div><div class="line">locations.forEach(<span class="function">(<span class="params">l</span>) =&gt;</span> &#123;</div><div class="line">  doStuff();</div><div class="line">  doSomeOtherStuff();</div><div class="line">  ...</div><div class="line">  ...</div><div class="line">  ...</div><div class="line">  <span class="comment">// l是什么？</span></div><div class="line">  dispatch(l);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> locations = [<span class="string">'Austin'</span>, <span class="string">'New York'</span>, <span class="string">'San Francisco'</span>];</div><div class="line">locations.forEach(<span class="function">(<span class="params">location</span>) =&gt;</span> &#123;</div><div class="line">  doStuff();</div><div class="line">  doSomeOtherStuff();</div><div class="line">  ...</div><div class="line">  ...</div><div class="line">  ...</div><div class="line">  dispatch(location);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="避免重复的描述"><a href="#避免重复的描述" class="headerlink" title="避免重复的描述"></a>避免重复的描述</h3><p>当类/对象名已经有意义时，对其变量进行命名不需要再次重复。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Car = &#123;</div><div class="line">  <span class="attr">carMake</span>: <span class="string">'Honda'</span>,</div><div class="line">  <span class="attr">carModel</span>: <span class="string">'Accord'</span>,</div><div class="line">  <span class="attr">carColor</span>: <span class="string">'Blue'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">paintCar</span>(<span class="params">car</span>) </span>&#123;</div><div class="line">  car.carColor = <span class="string">'Red'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Car = &#123;</div><div class="line">  <span class="attr">make</span>: <span class="string">'Honda'</span>,</div><div class="line">  <span class="attr">model</span>: <span class="string">'Accord'</span>,</div><div class="line">  <span class="attr">color</span>: <span class="string">'Blue'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">paintCar</span>(<span class="params">car</span>) </span>&#123;</div><div class="line">  car.color = <span class="string">'Red'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="避免无意义的条件判断"><a href="#避免无意义的条件判断" class="headerlink" title="避免无意义的条件判断"></a>避免无意义的条件判断</h3><p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createMicrobrewery</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> breweryName;</div><div class="line">  <span class="keyword">if</span> (name) &#123;</div><div class="line">    breweryName = name;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    breweryName = <span class="string">'Hipster Brew Co.'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createMicrobrewery</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> breweryName = name || <span class="string">'Hipster Brew Co.'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h2><h3 id="函数参数-理想情况下应不超过-2-个"><a href="#函数参数-理想情况下应不超过-2-个" class="headerlink" title="函数参数 (理想情况下应不超过 2 个)"></a>函数参数 (理想情况下应不超过 2 个)</h3><p>限制函数参数数量很有必要，这么做使得在测试函数时更加轻松。过多的参数将导致难以采用有效的测试用例对函数的各个参数进行测试。</p>
<p>应避免三个以上参数的函数。通常情况下，参数超过两个意味着函数功能过于复杂，这时需要重新优化你的函数。当确实需要多个参数时，大多情况下可以考虑这些参数封装成一个对象。</p>
<p>JS 定义对象非常方便，当需要多个参数时，可以使用一个对象进行替代。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createMenu</span>(<span class="params">title, body, buttonText, cancellable</span>) </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> menuConfig = &#123;</div><div class="line">  <span class="attr">title</span>: <span class="string">'Foo'</span>,</div><div class="line">  <span class="attr">body</span>: <span class="string">'Bar'</span>,</div><div class="line">  <span class="attr">buttonText</span>: <span class="string">'Baz'</span>,</div><div class="line">  <span class="attr">cancellable</span>: <span class="literal">true</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createMenu</span>(<span class="params">menuConfig</span>) </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="函数功能的单一性"><a href="#函数功能的单一性" class="headerlink" title="函数功能的单一性"></a>函数功能的单一性</h3><p>这是软件功能中最重要的原则之一。</p>
<p>功能不单一的函数将导致难以重构、测试和理解。功能单一的函数易于重构，并使代码更加干净。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">emailClients</span>(<span class="params">clients</span>) </span>&#123;</div><div class="line">  clients.forEach(<span class="function"><span class="params">client</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> clientRecord = database.lookup(client);</div><div class="line">    <span class="keyword">if</span> (clientRecord.isActive()) &#123;</div><div class="line">      email(client);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">emailClients</span>(<span class="params">clients</span>) </span>&#123;</div><div class="line">  clients.forEach(<span class="function"><span class="params">client</span> =&gt;</span> &#123;</div><div class="line">    emailClientIfNeeded(client);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">emailClientIfNeeded</span>(<span class="params">client</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (isClientActive(client)) &#123;</div><div class="line">    email(client);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isClientActive</span>(<span class="params">client</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> clientRecord = database.lookup(client);</div><div class="line">  <span class="keyword">return</span> clientRecord.isActive();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="函数名应明确表明其功能"><a href="#函数名应明确表明其功能" class="headerlink" title="函数名应明确表明其功能"></a>函数名应明确表明其功能</h3><p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dateAdd</span>(<span class="params">date, month</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line"></div><div class="line"><span class="comment">// 很难理解dateAdd(date, 1)是什么意思</span></div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dateAddMonth</span>(<span class="params">date, month</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">dateAddMonth(date, <span class="number">1</span>);</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="函数应该只做一层抽象"><a href="#函数应该只做一层抽象" class="headerlink" title="函数应该只做一层抽象"></a>函数应该只做一层抽象</h3><p>当函数的需要的抽象多于一层时通常意味着函数功能过于复杂，需将其进行分解以提高其可重用性和可测试性。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseBetterJSAlternative</span>(<span class="params">code</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> REGEXES = [</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  ];</div><div class="line"></div><div class="line">  <span class="keyword">let</span> statements = code.split(<span class="string">' '</span>);</div><div class="line">  <span class="keyword">let</span> tokens;</div><div class="line">  REGEXES.forEach(<span class="function">(<span class="params">REGEX</span>) =&gt;</span> &#123;</div><div class="line">    statements.forEach(<span class="function">(<span class="params">statement</span>) =&gt;</span> &#123;</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    &#125;)</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="keyword">let</span> ast;</div><div class="line">  tokens.forEach(<span class="function">(<span class="params">token</span>) =&gt;</span> &#123;</div><div class="line">    <span class="comment">// lex...</span></div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  ast.forEach(<span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</div><div class="line">    <span class="comment">// parse...</span></div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tokenize</span>(<span class="params">code</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> REGEXES = [</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  ];</div><div class="line"></div><div class="line">  <span class="keyword">let</span> statements = code.split(<span class="string">' '</span>);</div><div class="line">  <span class="keyword">let</span> tokens;</div><div class="line">  REGEXES.forEach(<span class="function">(<span class="params">REGEX</span>) =&gt;</span> &#123;</div><div class="line">    statements.forEach(<span class="function">(<span class="params">statement</span>) =&gt;</span> &#123;</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    &#125;)</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> tokens;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">lexer</span>(<span class="params">tokens</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> ast;</div><div class="line">  tokens.forEach(<span class="function">(<span class="params">token</span>) =&gt;</span> &#123;</div><div class="line">    <span class="comment">// lex...</span></div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> ast;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseBetterJSAlternative</span>(<span class="params">code</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> tokens = tokenize(code);</div><div class="line">  <span class="keyword">let</span> ast = lexer(tokens);</div><div class="line">  ast.forEach(<span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</div><div class="line">    <span class="comment">// parse...</span></div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="移除重复的代码"><a href="#移除重复的代码" class="headerlink" title="移除重复的代码"></a>移除重复的代码</h3><p>永远、永远、永远不要在任何循环下有重复的代码。</p>
<p>这种做法毫无意义且潜在危险极大。重复的代码意味着逻辑变化时需要对不止一处进行修改。JS 弱类型的特点使得函数拥有更强的普适性。好好利用这一优点吧。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">showDeveloperList</span>(<span class="params">developers</span>) </span>&#123;</div><div class="line">  developers.forEach(<span class="function"><span class="params">developer</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">var</span> expectedSalary = developer.calculateExpectedSalary();</div><div class="line">    <span class="keyword">var</span> experience = developer.getExperience();</div><div class="line">    <span class="keyword">var</span> githubLink = developer.getGithubLink();</div><div class="line">    <span class="keyword">var</span> data = &#123;</div><div class="line">      <span class="attr">expectedSalary</span>: expectedSalary,</div><div class="line">      <span class="attr">experience</span>: experience,</div><div class="line">      <span class="attr">githubLink</span>: githubLink</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    render(data);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">showManagerList</span>(<span class="params">managers</span>) </span>&#123;</div><div class="line">  managers.forEach(<span class="function"><span class="params">manager</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">var</span> expectedSalary = manager.calculateExpectedSalary();</div><div class="line">    <span class="keyword">var</span> experience = manager.getExperience();</div><div class="line">    <span class="keyword">var</span> portfolio = manager.getMBAProjects();</div><div class="line">    <span class="keyword">var</span> data = &#123;</div><div class="line">      <span class="attr">expectedSalary</span>: expectedSalary,</div><div class="line">      <span class="attr">experience</span>: experience,</div><div class="line">      <span class="attr">portfolio</span>: portfolio</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    render(data);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">showList</span>(<span class="params">employees</span>) </span>&#123;</div><div class="line">  employees.forEach(<span class="function"><span class="params">employee</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">var</span> expectedSalary = employee.calculateExpectedSalary();</div><div class="line">    <span class="keyword">var</span> experience = employee.getExperience();</div><div class="line">    <span class="keyword">var</span> portfolio;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (employee.type === <span class="string">'manager'</span>) &#123;</div><div class="line">      portfolio = employee.getMBAProjects();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      portfolio = employee.getGithubLink();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> data = &#123;</div><div class="line">      <span class="attr">expectedSalary</span>: expectedSalary,</div><div class="line">      <span class="attr">experience</span>: experience,</div><div class="line">      <span class="attr">portfolio</span>: portfolio</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    render(data);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="采用默认参数精简代码"><a href="#采用默认参数精简代码" class="headerlink" title="采用默认参数精简代码"></a>采用默认参数精简代码</h3><p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeForumComment</span>(<span class="params">subject, body</span>) </span>&#123;</div><div class="line">  subject = subject || <span class="string">'No Subject'</span>;</div><div class="line">  body = body || <span class="string">'No text'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeForumComment</span>(<span class="params">subject = <span class="string">'No subject'</span>, body = <span class="string">'No text'</span></span>) </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="使用-Object-assign-设置默认对象"><a href="#使用-Object-assign-设置默认对象" class="headerlink" title="使用 Object.assign 设置默认对象"></a>使用 Object.assign 设置默认对象</h3><p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> menuConfig = &#123;</div><div class="line">  <span class="attr">title</span>: <span class="literal">null</span>,</div><div class="line">  <span class="attr">body</span>: <span class="string">'Bar'</span>,</div><div class="line">  <span class="attr">buttonText</span>: <span class="literal">null</span>,</div><div class="line">  <span class="attr">cancellable</span>: <span class="literal">true</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createMenu</span>(<span class="params">config</span>) </span>&#123;</div><div class="line">  config.title = config.title || <span class="string">'Foo'</span></div><div class="line">  config.body = config.body || <span class="string">'Bar'</span></div><div class="line">  config.buttonText = config.buttonText || <span class="string">'Baz'</span></div><div class="line">  config.cancellable = config.cancellable === <span class="literal">undefined</span> ? config.cancellable : <span class="literal">true</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">createMenu(menuConfig);</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> menuConfig = &#123;</div><div class="line">  <span class="attr">title</span>: <span class="string">'Order'</span>,</div><div class="line">  <span class="comment">// User did not include 'body' key</span></div><div class="line">  buttonText: <span class="string">'Send'</span>,</div><div class="line">  <span class="attr">cancellable</span>: <span class="literal">true</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createMenu</span>(<span class="params">config</span>) </span>&#123;</div><div class="line">  config = <span class="built_in">Object</span>.assign(&#123;</div><div class="line">    <span class="attr">title</span>: <span class="string">'Foo'</span>,</div><div class="line">    <span class="attr">body</span>: <span class="string">'Bar'</span>,</div><div class="line">    <span class="attr">buttonText</span>: <span class="string">'Baz'</span>,</div><div class="line">    <span class="attr">cancellable</span>: <span class="literal">true</span></div><div class="line">  &#125;, config);</div><div class="line"></div><div class="line">  <span class="comment">// config now equals: &#123;title: "Order", body: "Bar", buttonText: "Send", cancellable: true&#125;</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">createMenu(menuConfig);</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="不要使用标记-Flag-作为函数参数"><a href="#不要使用标记-Flag-作为函数参数" class="headerlink" title="不要使用标记(Flag)作为函数参数"></a>不要使用标记(Flag)作为函数参数</h3><p>这通常意味着函数的功能的单一性已经被破坏。此时应考虑对函数进行再次划分。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFile</span>(<span class="params">name, temp</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (temp) &#123;</div><div class="line">    fs.create(<span class="string">'./temp/'</span> + name);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    fs.create(name);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTempFile</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  fs.create(<span class="string">'./temp/'</span> + name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">----------</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFile</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  fs.create(name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="避免副作用"><a href="#避免副作用" class="headerlink" title="避免副作用"></a>避免副作用</h3><p>当函数产生了除了“接受一个值并返回一个结果”之外的行为时，称该函数产生了副作用。比如写文件、修改全局变量或将你的钱全转给了一个陌生人等。</p>
<p>程序在某些情况下确实需要副作用这一行为，如先前例子中的写文件。这时应该将这些功能集中在一起，不要用多个函数/类修改某个文件。用且只用一个 service 完成这一需求。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Global variable referenced by following function.</span></div><div class="line"><span class="comment">// If we had another function that used this name, now it'd be an array and it could break it.</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">'Ryan McDermott'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">splitIntoFirstAndLastName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  name = name.split(<span class="string">' '</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">splitIntoFirstAndLastName();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(name); <span class="comment">// ['Ryan', 'McDermott'];</span></div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">splitIntoFirstAndLastName</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> name.split(<span class="string">' '</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> name = <span class="string">'Ryan McDermott'</span></div><div class="line"><span class="keyword">var</span> newName = splitIntoFirstAndLastName(name);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(name); <span class="comment">// 'Ryan McDermott';</span></div><div class="line"><span class="built_in">console</span>.log(newName); <span class="comment">// ['Ryan', 'McDermott'];</span></div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="不要写全局函数"><a href="#不要写全局函数" class="headerlink" title="不要写全局函数"></a>不要写全局函数</h3><p>在 JS 中污染全局是一个非常不好的实践，这么做可能和其他库起冲突，且调用你的 API 的用户在实际环境中得到一个 exception 前对这一情况是一无所知的。</p>
<p>想象以下例子：如果你想扩展 JS 中的 Array，为其添加一个 <code>diff</code> 函数显示两个数组间的差异，此时应如何去做？你可以将 diff 写入 <code>Array.prototype</code>，但这么做会和其他有类似需求的库造成冲突。如果另一个库对 diff 的需求为比较一个数组中首尾元素间的差异呢？</p>
<p>使用 ES6 中的 class 对全局的 Array 做简单的扩展显然是一个更棒的选择。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype.diff = <span class="function"><span class="keyword">function</span>(<span class="params">comparisonArray</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> values = [];</div><div class="line">  <span class="keyword">var</span> hash = &#123;&#125;;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">of</span> comparisonArray) &#123;</div><div class="line">    hash[i] = <span class="literal">true</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">of</span> <span class="keyword">this</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (!hash[i]) &#123;</div><div class="line">      values.push(i);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> values;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(...args) &#123;</div><div class="line">    <span class="keyword">super</span>(...args);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  diff(comparisonArray) &#123;</div><div class="line">    <span class="keyword">var</span> values = [];</div><div class="line">    <span class="keyword">var</span> hash = &#123;&#125;;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">of</span> comparisonArray) &#123;</div><div class="line">      hash[i] = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">of</span> <span class="keyword">this</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (!hash[i]) &#123;</div><div class="line">        values.push(i);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> values;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="采用函数式编程"><a href="#采用函数式编程" class="headerlink" title="采用函数式编程"></a>采用函数式编程</h3><p>函数式的编程具有更干净且便于测试的特点。尽可能的使用这种风格吧。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> programmerOutput = [</div><div class="line">  &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'Uncle Bobby'</span>,</div><div class="line">    <span class="attr">linesOfCode</span>: <span class="number">500</span></div><div class="line">  &#125;, &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'Suzie Q'</span>,</div><div class="line">    <span class="attr">linesOfCode</span>: <span class="number">1500</span></div><div class="line">  &#125;, &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'Jimmy Gosling'</span>,</div><div class="line">    <span class="attr">linesOfCode</span>: <span class="number">150</span></div><div class="line">  &#125;, &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'Gracie Hopper'</span>,</div><div class="line">    <span class="attr">linesOfCode</span>: <span class="number">1000</span></div><div class="line">  &#125;</div><div class="line">];</div><div class="line"></div><div class="line"><span class="keyword">var</span> totalOutput = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; programmerOutput.length; i++) &#123;</div><div class="line">  totalOutput += programmerOutput[i].linesOfCode;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> programmerOutput = [</div><div class="line">  &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'Uncle Bobby'</span>,</div><div class="line">    <span class="attr">linesOfCode</span>: <span class="number">500</span></div><div class="line">  &#125;, &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'Suzie Q'</span>,</div><div class="line">    <span class="attr">linesOfCode</span>: <span class="number">1500</span></div><div class="line">  &#125;, &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'Jimmy Gosling'</span>,</div><div class="line">    <span class="attr">linesOfCode</span>: <span class="number">150</span></div><div class="line">  &#125;, &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'Gracie Hopper'</span>,</div><div class="line">    <span class="attr">linesOfCode</span>: <span class="number">1000</span></div><div class="line">  &#125;</div><div class="line">];</div><div class="line"></div><div class="line"><span class="keyword">var</span> totalOutput = programmerOutput</div><div class="line">  .map(<span class="function">(<span class="params">programmer</span>) =&gt;</span> programmer.linesOfCode)</div><div class="line">  .reduce(<span class="function">(<span class="params">acc, linesOfCode</span>) =&gt;</span> acc + linesOfCode, <span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="封装判断条件"><a href="#封装判断条件" class="headerlink" title="封装判断条件"></a>封装判断条件</h3><p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (fsm.state === <span class="string">'fetching'</span> &amp;&amp; isEmpty(listNode)) &#123;</div><div class="line">  <span class="comment">/// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shouldShowSpinner</span>(<span class="params">fsm, listNode</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> fsm.state === <span class="string">'fetching'</span> &amp;&amp; isEmpty(listNode);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (shouldShowSpinner(fsmInstance, listNodeInstance)) &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="避免“否定情况”的判断"><a href="#避免“否定情况”的判断" class="headerlink" title="避免“否定情况”的判断"></a>避免“否定情况”的判断</h3><p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isDOMNodeNotPresent</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!isDOMNodeNotPresent(node)) &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isDOMNodePresent</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (isDOMNodePresent(node)) &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="避免条件判断"><a href="#避免条件判断" class="headerlink" title="避免条件判断"></a>避免条件判断</h3><p>这看起来似乎不太可能。</p>
<p>大多人听到这的第一反应是：“怎么可能不用 if 完成其他功能呢？”许多情况下通过使用多态(polymorphism)可以达到同样的目的。</p>
<p>第二个问题在于采用这种方式的原因是什么。答案是我们之前提到过的：保持函数功能的单一性。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span> </span>&#123;</div><div class="line">  <span class="comment">//...</span></div><div class="line">  getCruisingAltitude() &#123;</div><div class="line">    <span class="keyword">switch</span> (<span class="keyword">this</span>.type) &#123;</div><div class="line">      <span class="keyword">case</span> <span class="string">'777'</span>:</div><div class="line">        <span class="keyword">return</span> getMaxAltitude() - getPassengerCount();</div><div class="line">      <span class="keyword">case</span> <span class="string">'Air Force One'</span>:</div><div class="line">        <span class="keyword">return</span> getMaxAltitude();</div><div class="line">      <span class="keyword">case</span> <span class="string">'Cessna'</span>:</div><div class="line">        <span class="keyword">return</span> getMaxAltitude() - getFuelExpenditure();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span> </span>&#123;</div><div class="line">  <span class="comment">//...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boeing777</span> <span class="keyword">extends</span> <span class="title">Airplane</span> </span>&#123;</div><div class="line">  <span class="comment">//...</span></div><div class="line">  getCruisingAltitude() &#123;</div><div class="line">    <span class="keyword">return</span> getMaxAltitude() - getPassengerCount();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirForceOne</span> <span class="keyword">extends</span> <span class="title">Airplane</span> </span>&#123;</div><div class="line">  <span class="comment">//...</span></div><div class="line">  getCruisingAltitude() &#123;</div><div class="line">    <span class="keyword">return</span> getMaxAltitude();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cessna</span> <span class="keyword">extends</span> <span class="title">Airplane</span> </span>&#123;</div><div class="line">  <span class="comment">//...</span></div><div class="line">  getCruisingAltitude() &#123;</div><div class="line">    <span class="keyword">return</span> getMaxAltitude() - getFuelExpenditure();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="避免类型判断-part-1"><a href="#避免类型判断-part-1" class="headerlink" title="避免类型判断(part 1)"></a>避免类型判断(part 1)</h3><p>JS 是弱类型语言，这意味着函数可接受任意类型的参数。</p>
<p>有时这会对你带来麻烦，你会对参数做一些类型判断。有许多方法可以避免这些情况。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">travelToTexas</span>(<span class="params">vehicle</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (vehicle <span class="keyword">instanceof</span> Bicycle) &#123;</div><div class="line">    vehicle.peddle(<span class="keyword">this</span>.currentLocation, <span class="keyword">new</span> Location(<span class="string">'texas'</span>));</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vehicle <span class="keyword">instanceof</span> Car) &#123;</div><div class="line">    vehicle.drive(<span class="keyword">this</span>.currentLocation, <span class="keyword">new</span> Location(<span class="string">'texas'</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">travelToTexas</span>(<span class="params">vehicle</span>) </span>&#123;</div><div class="line">  vehicle.move(<span class="keyword">this</span>.currentLocation, <span class="keyword">new</span> Location(<span class="string">'texas'</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="避免类型判断-part-2"><a href="#避免类型判断-part-2" class="headerlink" title="避免类型判断(part 2)"></a>避免类型判断(part 2)</h3><p>如果需处理的数据为字符串，整型，数组等类型，无法使用多态并仍有必要对其进行类型检测时，可以考虑使用 TypeScript。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">combine</span>(<span class="params">val1, val2</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val1 == <span class="string">"number"</span> &amp;&amp; <span class="keyword">typeof</span> val2 == <span class="string">"number"</span> ||</div><div class="line">      <span class="keyword">typeof</span> val1 == <span class="string">"string"</span> &amp;&amp; <span class="keyword">typeof</span> val2 == <span class="string">"string"</span>) &#123;</div><div class="line">    <span class="keyword">return</span> val1 + val2;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Must be of type String or Number'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">combine</span>(<span class="params">val1, val2</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> val1 + val2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="避免过度优化"><a href="#避免过度优化" class="headerlink" title="避免过度优化"></a>避免过度优化</h3><p>现代的浏览器在运行时会对代码自动进行优化。有时人为对代码进行优化可能是在浪费时间。</p>
<p><a href="https://github.com/petkaantonov/bluebird/wiki/Optimization-killers" target="_blank" rel="external">这里可以找到许多真正需要优化的地方</a></p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 这里使用变量len是因为在老式浏览器中，</span></div><div class="line"><span class="comment">// 直接使用正例中的方式会导致每次循环均重复计算list.length的值，</span></div><div class="line"><span class="comment">// 而在现代浏览器中会自动完成优化，这一行为是没有必要的</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = list.length; i &lt; len; i++) &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="删除无效的代码"><a href="#删除无效的代码" class="headerlink" title="删除无效的代码"></a>删除无效的代码</h3><p>不再被调用的代码应及时删除。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">oldRequestModule</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">newRequestModule</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> req = newRequestModule;</div><div class="line">inventoryTracker(<span class="string">'apples'</span>, req, <span class="string">'www.inventory-awesome.io'</span>);</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">newRequestModule</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> req = newRequestModule;</div><div class="line">inventoryTracker(<span class="string">'apples'</span>, req, <span class="string">'www.inventory-awesome.io'</span>);</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h2 id="对象和数据结构"><a href="#对象和数据结构" class="headerlink" title="对象和数据结构"></a><strong>对象和数据结构</strong></h2><h3 id="使用-getters-和-setters"><a href="#使用-getters-和-setters" class="headerlink" title="使用 getters 和 setters"></a>使用 getters 和 setters</h3><p>JS 没有接口或类型，因此实现这一模式是很困难的，因为我们并没有类似 <code>public</code> 和 <code>private</code> 的关键词。</p>
<p>然而，使用 getters 和 setters 获取对象的数据远比直接使用点操作符具有优势。为什么呢？</p>
<ol>
<li>当需要对获取的对象属性执行额外操作时。</li>
<li>执行 <code>set</code> 时可以增加规则对要变量的合法性进行判断。</li>
<li>封装了内部逻辑。</li>
<li>在存取时可以方便的增加日志和错误处理。</li>
<li>继承该类时可以重载默认行为。</li>
<li>从服务器获取数据时可以进行懒加载。</li>
</ol>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BankAccount</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">	   <span class="keyword">this</span>.balance = <span class="number">1000</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> bankAccount = <span class="keyword">new</span> BankAccount();</div><div class="line"></div><div class="line"><span class="comment">// Buy shoes...</span></div><div class="line">bankAccount.balance = bankAccount.balance - <span class="number">100</span>;</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BankAccount</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">	   <span class="keyword">this</span>.balance = <span class="number">1000</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// It doesn't have to be prefixed with `get` or `set` to be a getter/setter</span></div><div class="line">  withdraw(amount) &#123;</div><div class="line">  	<span class="keyword">if</span> (verifyAmountCanBeDeducted(amount)) &#123;</div><div class="line">  	  <span class="keyword">this</span>.balance -= amount;</div><div class="line">  	&#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> bankAccount = <span class="keyword">new</span> BankAccount();</div><div class="line"></div><div class="line"><span class="comment">// Buy shoes...</span></div><div class="line">bankAccount.withdraw(<span class="number">100</span>);</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="让对象拥有私有成员"><a href="#让对象拥有私有成员" class="headerlink" title="让对象拥有私有成员"></a>让对象拥有私有成员</h3><p>可以通过闭包完成</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> Employee = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Employee.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> employee = <span class="keyword">new</span> Employee(<span class="string">'John Doe'</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Employee name: '</span> + employee.getName()); <span class="comment">// Employee name: John Doe</span></div><div class="line"><span class="keyword">delete</span> employee.name;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Employee name: '</span> + employee.getName()); <span class="comment">// Employee name: undefined</span></div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Employee = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Employee</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> name;</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> Employee;</div><div class="line">&#125;());</div><div class="line"></div><div class="line"><span class="keyword">var</span> employee = <span class="keyword">new</span> Employee(<span class="string">'John Doe'</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Employee name: '</span> + employee.getName()); <span class="comment">// Employee name: John Doe</span></div><div class="line"><span class="keyword">delete</span> employee.name;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Employee name: '</span> + employee.getName()); <span class="comment">// Employee name: John Doe</span></div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a><strong>类</strong></h2><h3 id="单一职责原则-SRP"><a href="#单一职责原则-SRP" class="headerlink" title="单一职责原则 (SRP)"></a>单一职责原则 (SRP)</h3><p>如《代码整洁之道》一书中所述，“修改一个类的理由不应该超过一个”。</p>
<p>将多个功能塞进一个类的想法很诱人，但这将导致你的类无法达到概念上的内聚，并经常不得不进行修改。</p>
<p>最小化对一个类需要修改的次数是非常有必要的。如果一个类具有太多太杂的功能，当你对其中一小部分进行修改时，将很难想象到这一修够对代码库中依赖该类的其他模块会带来什么样的影响。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSettings</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(user) &#123;</div><div class="line">    <span class="keyword">this</span>.user = user;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  changeSettings(settings) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.verifyCredentials(user)) &#123;</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  verifyCredentials(user) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserAuth</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(user) &#123;</div><div class="line">    <span class="keyword">this</span>.user = user;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  verifyCredentials() &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSettings</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(user) &#123;</div><div class="line">    <span class="keyword">this</span>.user = user;</div><div class="line">    <span class="keyword">this</span>.auth = <span class="keyword">new</span> UserAuth(user)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  changeSettings(settings) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.auth.verifyCredentials()) &#123;</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="开-闭原则-OCP"><a href="#开-闭原则-OCP" class="headerlink" title="开/闭原则 (OCP)"></a>开/闭原则 (OCP)</h3><p>“代码实体(类，模块，函数等)应该易于扩展，难于修改。”</p>
<p>这一原则指的是我们应允许用户方便的扩展我们代码模块的功能，而不需要打开 js 文件源码手动对其进行修改。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AjaxRequester</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="comment">// What if we wanted another HTTP Method, like DELETE? We would have to</span></div><div class="line">    <span class="comment">// open this file up and modify this and put it in manually.</span></div><div class="line">    <span class="keyword">this</span>.HTTP_METHODS = [<span class="string">'POST'</span>, <span class="string">'PUT'</span>, <span class="string">'GET'</span>];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  get(url) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AjaxRequester</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.HTTP_METHODS = [<span class="string">'POST'</span>, <span class="string">'PUT'</span>, <span class="string">'GET'</span>];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  get(url) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  addHTTPMethod(method) &#123;</div><div class="line">    <span class="keyword">this</span>.HTTP_METHODS.push(method);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="利斯科夫替代原则-LSP"><a href="#利斯科夫替代原则-LSP" class="headerlink" title="利斯科夫替代原则 (LSP)"></a>利斯科夫替代原则 (LSP)</h3><p>“子类对象应该能够替换其超类对象被使用”。</p>
<p>也就是说，如果有一个父类和一个子类，当采用子类替换父类时不应该产生错误的结果。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.width = <span class="number">0</span>;</div><div class="line">    <span class="keyword">this</span>.height = <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  setColor(color) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render(area) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  setWidth(width) &#123;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  setHeight(height) &#123;</div><div class="line">    <span class="keyword">this</span>.height = height;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  getArea() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.width * <span class="keyword">this</span>.height;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  setWidth(width) &#123;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">    <span class="keyword">this</span>.height = width;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  setHeight(height) &#123;</div><div class="line">    <span class="keyword">this</span>.width = height;</div><div class="line">    <span class="keyword">this</span>.height = height;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderLargeRectangles</span>(<span class="params">rectangles</span>) </span>&#123;</div><div class="line">  rectangles.forEach(<span class="function">(<span class="params">rectangle</span>) =&gt;</span> &#123;</div><div class="line">    rectangle.setWidth(<span class="number">4</span>);</div><div class="line">    rectangle.setHeight(<span class="number">5</span>);</div><div class="line">    <span class="keyword">let</span> area = rectangle.getArea(); <span class="comment">// BAD: Will return 25 for Square. Should be 20.</span></div><div class="line">    rectangle.render(area);</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> rectangles = [<span class="keyword">new</span> Rectangle(), <span class="keyword">new</span> Rectangle(), <span class="keyword">new</span> Square()];</div><div class="line">renderLargeRectangles(rectangles);</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;&#125;</div><div class="line"></div><div class="line">  setColor(color) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render(area) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    <span class="keyword">this</span>.width = <span class="number">0</span>;</div><div class="line">    <span class="keyword">this</span>.height = <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  setWidth(width) &#123;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  setHeight(height) &#123;</div><div class="line">    <span class="keyword">this</span>.height = height;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  getArea() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.width * <span class="keyword">this</span>.height;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    <span class="keyword">this</span>.length = <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  setLength(length) &#123;</div><div class="line">    <span class="keyword">this</span>.length = length;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  getArea() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.length;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderLargeShapes</span>(<span class="params">shapes</span>) </span>&#123;</div><div class="line">  shapes.forEach(<span class="function">(<span class="params">shape</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">switch</span> (shape.constructor.name) &#123;</div><div class="line">      <span class="keyword">case</span> <span class="string">'Square'</span>:</div><div class="line">        shape.setLength(<span class="number">5</span>);</div><div class="line">      <span class="keyword">case</span> <span class="string">'Rectangle'</span>:</div><div class="line">        shape.setWidth(<span class="number">4</span>);</div><div class="line">        shape.setHeight(<span class="number">5</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> area = shape.getArea();</div><div class="line">    shape.render(area);</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> shapes = [<span class="keyword">new</span> Rectangle(), <span class="keyword">new</span> Rectangle(), <span class="keyword">new</span> Square()];</div><div class="line">renderLargeShapes(shapes);</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="接口隔离原则-ISP"><a href="#接口隔离原则-ISP" class="headerlink" title="接口隔离原则 (ISP)"></a>接口隔离原则 (ISP)</h3><p>“客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。”</p>
<p>在 JS 中，当一个类需要许多参数设置才能生成一个对象时，或许大多时候不需要设置这么多的参数。此时减少对配置参数数量的需求是有益的。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DOMTraverser</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(settings) &#123;</div><div class="line">    <span class="keyword">this</span>.settings = settings;</div><div class="line">    <span class="keyword">this</span>.setup();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  setup() &#123;</div><div class="line">    <span class="keyword">this</span>.rootNode = <span class="keyword">this</span>.settings.rootNode;</div><div class="line">    <span class="keyword">this</span>.animationModule.setup();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  traverse() &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> $ = <span class="keyword">new</span> DOMTraverser(&#123;</div><div class="line">  <span class="attr">rootNode</span>: <span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>),</div><div class="line">  <span class="attr">animationModule</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// Most of the time, we won't need to animate when traversing.</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DOMTraverser</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(settings) &#123;</div><div class="line">    <span class="keyword">this</span>.settings = settings;</div><div class="line">    <span class="keyword">this</span>.options = settings.options;</div><div class="line">    <span class="keyword">this</span>.setup();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  setup() &#123;</div><div class="line">    <span class="keyword">this</span>.rootNode = <span class="keyword">this</span>.settings.rootNode;</div><div class="line">    <span class="keyword">this</span>.setupOptions();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  setupOptions() &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.options.animationModule) &#123;</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  traverse() &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> $ = <span class="keyword">new</span> DOMTraverser(&#123;</div><div class="line">  <span class="attr">rootNode</span>: <span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>),</div><div class="line">  <span class="attr">options</span>: &#123;</div><div class="line">    <span class="attr">animationModule</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="依赖反转原则-DIP"><a href="#依赖反转原则-DIP" class="headerlink" title="依赖反转原则 (DIP)"></a>依赖反转原则 (DIP)</h3><p>该原则有两个核心点：</p>
<ol>
<li>高层模块不应该依赖于低层模块。他们都应该依赖于抽象接口。</li>
<li>抽象接口应该脱离具体实现，具体实现应该依赖于抽象接口。</li>
</ol>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">InventoryTracker</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(items) &#123;</div><div class="line">    <span class="keyword">this</span>.items = items;</div><div class="line"></div><div class="line">    <span class="comment">// BAD: We have created a dependency on a specific request implementation.</span></div><div class="line">    <span class="comment">// We should just have requestItems depend on a request method: `request`</span></div><div class="line">    <span class="keyword">this</span>.requester = <span class="keyword">new</span> InventoryRequester();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  requestItems() &#123;</div><div class="line">    <span class="keyword">this</span>.items.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</div><div class="line">      <span class="keyword">this</span>.requester.requestItem(item);</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">InventoryRequester</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.REQ_METHODS = [<span class="string">'HTTP'</span>];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  requestItem(item) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> inventoryTracker = <span class="keyword">new</span> InventoryTracker([<span class="string">'apples'</span>, <span class="string">'bananas'</span>]);</div><div class="line">inventoryTracker.requestItems();</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">InventoryTracker</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(items, requester) &#123;</div><div class="line">    <span class="keyword">this</span>.items = items;</div><div class="line">    <span class="keyword">this</span>.requester = requester;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  requestItems() &#123;</div><div class="line">    <span class="keyword">this</span>.items.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</div><div class="line">      <span class="keyword">this</span>.requester.requestItem(item);</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">InventoryRequesterV1</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.REQ_METHODS = [<span class="string">'HTTP'</span>];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  requestItem(item) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">InventoryRequesterV2</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.REQ_METHODS = [<span class="string">'WS'</span>];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  requestItem(item) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// By constructing our dependencies externally and injecting them, we can easily</span></div><div class="line"><span class="comment">// substitute our request module for a fancy new one that uses WebSockets.</span></div><div class="line"><span class="keyword">let</span> inventoryTracker = <span class="keyword">new</span> InventoryTracker([<span class="string">'apples'</span>, <span class="string">'bananas'</span>], <span class="keyword">new</span> InventoryRequesterV2());</div><div class="line">inventoryTracker.requestItems();</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="使用-ES6-的-classes-而不是-ES5-的-Function"><a href="#使用-ES6-的-classes-而不是-ES5-的-Function" class="headerlink" title="使用 ES6 的 classes 而不是 ES5 的 Function"></a>使用 ES6 的 classes 而不是 ES5 的 Function</h3><p>典型的 ES5 的类(function)在继承、构造和方法定义方面可读性较差。</p>
<p>当需要继承时，优先选用 classes。</p>
<p>但是，当在需要更大更复杂的对象时，最好优先选择更小的 function 而非 classes。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Animal = <span class="function"><span class="keyword">function</span>(<span class="params">age</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Animal)) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Instantiate Animal with `new`"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Animal.prototype.move = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> Mammal = <span class="function"><span class="keyword">function</span>(<span class="params">age, furColor</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Mammal)) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Instantiate Mammal with `new`"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Animal.call(<span class="keyword">this</span>, age);</div><div class="line">    <span class="keyword">this</span>.furColor = furColor;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Mammal.prototype = <span class="built_in">Object</span>.create(Animal.prototype);</div><div class="line">Mammal.prototype.constructor = Mammal;</div><div class="line">Mammal.prototype.liveBirth = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> Human = <span class="function"><span class="keyword">function</span>(<span class="params">age, furColor, languageSpoken</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Human)) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Instantiate Human with `new`"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Mammal.call(<span class="keyword">this</span>, age, furColor);</div><div class="line">    <span class="keyword">this</span>.languageSpoken = languageSpoken;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Human.prototype = <span class="built_in">Object</span>.create(Mammal.prototype);</div><div class="line">Human.prototype.constructor = Human;</div><div class="line">Human.prototype.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(age) &#123;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    move() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mammal</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(age, furColor) &#123;</div><div class="line">        <span class="keyword">super</span>(age);</div><div class="line">        <span class="keyword">this</span>.furColor = furColor;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    liveBirth() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> <span class="keyword">extends</span> <span class="title">Mammal</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(age, furColor, languageSpoken) &#123;</div><div class="line">        <span class="keyword">super</span>(age, furColor);</div><div class="line">        <span class="keyword">this</span>.languageSpoken = languageSpoken;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    speak() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="使用方法链"><a href="#使用方法链" class="headerlink" title="使用方法链"></a>使用方法链</h3><p>这里我们的理解与《代码整洁之道》的建议有些不同。</p>
<p>有争论说方法链不够干净且违反了<a href="https://en.wikipedia.org/wiki/Law_of_Demeter" target="_blank" rel="external">德米特法则</a>，也许这是对的，但这种方法在 JS 及许多库(如 JQuery)中显得非常实用。</p>
<p>因此，我认为在 JS 中使用方法链是非常合适的。在 class 的函数中返回 this，能够方便的将类需要执行的多个方法链接起来。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.make = <span class="string">'Honda'</span>;</div><div class="line">    <span class="keyword">this</span>.model = <span class="string">'Accord'</span>;</div><div class="line">    <span class="keyword">this</span>.color = <span class="string">'white'</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  setMake(make) &#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  setModel(model) &#123;</div><div class="line">    <span class="keyword">this</span>.model = model;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  setColor(color) &#123;</div><div class="line">    <span class="keyword">this</span>.color = color;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  save() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.make, <span class="keyword">this</span>.model, <span class="keyword">this</span>.color);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> car = <span class="keyword">new</span> Car();</div><div class="line">car.setColor(<span class="string">'pink'</span>);</div><div class="line">car.setMake(<span class="string">'Ford'</span>);</div><div class="line">car.setModel(<span class="string">'F-150'</span>)</div><div class="line">car.save();</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.make = <span class="string">'Honda'</span>;</div><div class="line">    <span class="keyword">this</span>.model = <span class="string">'Accord'</span>;</div><div class="line">    <span class="keyword">this</span>.color = <span class="string">'white'</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  setMake(make) &#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="comment">// <span class="doctag">NOTE:</span> Returning this for chaining</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  setModel(model) &#123;</div><div class="line">    <span class="keyword">this</span>.model = model;</div><div class="line">    <span class="comment">// <span class="doctag">NOTE:</span> Returning this for chaining</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  setColor(color) &#123;</div><div class="line">    <span class="keyword">this</span>.color = color;</div><div class="line">    <span class="comment">// <span class="doctag">NOTE:</span> Returning this for chaining</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  save() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.make, <span class="keyword">this</span>.model, <span class="keyword">this</span>.color);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> car = <span class="keyword">new</span> Car()</div><div class="line">  .setColor(<span class="string">'pink'</span>)</div><div class="line">  .setMake(<span class="string">'Ford'</span>)</div><div class="line">  .setModel(<span class="string">'F-150'</span>)</div><div class="line">  .save();</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="优先使用组合模式而非继承"><a href="#优先使用组合模式而非继承" class="headerlink" title="优先使用组合模式而非继承"></a>优先使用组合模式而非继承</h3><p>在著名的<a href="https://en.wikipedia.org/wiki/Design_Patterns" target="_blank" rel="external">设计模式</a>一书中提到，应多使用组合模式而非继承。</p>
<p>这么做有许多优点，在想要使用继承前，多想想能否通过组合模式满足需求吧。</p>
<p>那么，在什么时候继承具有更大的优势呢？这取决于你的具体需求，但大多情况下，可以遵守以下三点：</p>
<ol>
<li>继承关系表现为”是一个”而非”有一个”(如动物-&gt;人 和 用户-&gt;用户细节)</li>
<li>可以复用基类的代码(“Human”可以看成是”All animal”的一种)</li>
<li>希望当基类改变时所有派生类都受到影响(如修改”all animals”移动时的卡路里消耗量)</li>
</ol>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(name, email) &#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.email = email;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Bad because Employees "have" tax data. EmployeeTaxData is not a type of Employee</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmployeeTaxData</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(ssn, salary) &#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    <span class="keyword">this</span>.ssn = ssn;</div><div class="line">    <span class="keyword">this</span>.salary = salary;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(name, email) &#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.email = email;</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  setTaxData(ssn, salary) &#123;</div><div class="line">    <span class="keyword">this</span>.taxData = <span class="keyword">new</span> EmployeeTaxData(ssn, salary);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmployeeTaxData</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(ssn, salary) &#123;</div><div class="line">    <span class="keyword">this</span>.ssn = ssn;</div><div class="line">    <span class="keyword">this</span>.salary = salary;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a><strong>测试</strong></h2><p><a href="http://gotwarlost.github.io/istanbul/" target="_blank" rel="external">一些好的覆盖工具</a>。</p>
<p><a href="http://jstherightway.org/#testing-tools" target="_blank" rel="external">一些好的 JS 测试框架</a>。</p>
<h3 id="单一的测试每个概念"><a href="#单一的测试每个概念" class="headerlink" title="单一的测试每个概念"></a>单一的测试每个概念</h3><p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">'assert'</span>);</div><div class="line"></div><div class="line">describe(<span class="string">'MakeMomentJSGreatAgain'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  it(<span class="string">'handles date boundaries'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> date;</div><div class="line"></div><div class="line">    date = <span class="keyword">new</span> MakeMomentJSGreatAgain(<span class="string">'1/1/2015'</span>);</div><div class="line">    date.addDays(<span class="number">30</span>);</div><div class="line">    date.shouldEqual(<span class="string">'1/31/2015'</span>);</div><div class="line"></div><div class="line">    date = <span class="keyword">new</span> MakeMomentJSGreatAgain(<span class="string">'2/1/2016'</span>);</div><div class="line">    date.addDays(<span class="number">28</span>);</div><div class="line">    assert.equal(<span class="string">'02/29/2016'</span>, date);</div><div class="line"></div><div class="line">    date = <span class="keyword">new</span> MakeMomentJSGreatAgain(<span class="string">'2/1/2015'</span>);</div><div class="line">    date.addDays(<span class="number">28</span>);</div><div class="line">    assert.equal(<span class="string">'03/01/2015'</span>, date);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">'assert'</span>);</div><div class="line"></div><div class="line">describe(<span class="string">'MakeMomentJSGreatAgain'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  it(<span class="string">'handles 30-day months'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> date = <span class="keyword">new</span> MakeMomentJSGreatAgain(<span class="string">'1/1/2015'</span>);</div><div class="line">    date.addDays(<span class="number">30</span>);</div><div class="line">    date.shouldEqual(<span class="string">'1/31/2015'</span>);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  it(<span class="string">'handles leap year'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> date = <span class="keyword">new</span> MakeMomentJSGreatAgain(<span class="string">'2/1/2016'</span>);</div><div class="line">    date.addDays(<span class="number">28</span>);</div><div class="line">    assert.equal(<span class="string">'02/29/2016'</span>, date);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  it(<span class="string">'handles non-leap year'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> date = <span class="keyword">new</span> MakeMomentJSGreatAgain(<span class="string">'2/1/2015'</span>);</div><div class="line">    date.addDays(<span class="number">28</span>);</div><div class="line">    assert.equal(<span class="string">'03/01/2015'</span>, date);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a><strong>并发</strong></h2><h3 id="用-Promises-替代回调"><a href="#用-Promises-替代回调" class="headerlink" title="用 Promises 替代回调"></a>用 Promises 替代回调</h3><p>回调不够整洁并会造成大量的嵌套。ES6 内嵌了 Promises，使用它吧。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>(<span class="string">'request'</span>).get(<span class="string">'https://en.wikipedia.org/wiki/Robert_Cecil_Martin'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, response</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (err) &#123;</div><div class="line">    <span class="built_in">console</span>.error(err);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">require</span>(<span class="string">'fs'</span>).writeFile(<span class="string">'article.html'</span>, response.body, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (err) &#123;</div><div class="line">        <span class="built_in">console</span>.error(err);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'File written'</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>(<span class="string">'request-promise'</span>).get(<span class="string">'https://en.wikipedia.org/wiki/Robert_Cecil_Martin'</span>)</div><div class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">require</span>(<span class="string">'fs-promise'</span>).writeFile(<span class="string">'article.html'</span>, response);</div><div class="line">  &#125;)</div><div class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'File written'</span>);</div><div class="line">  &#125;)</div><div class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.error(err);</div><div class="line">  &#125;)</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="Async-Await-是较-Promises-更好的选择"><a href="#Async-Await-是较-Promises-更好的选择" class="headerlink" title="Async/Await 是较 Promises 更好的选择"></a>Async/Await 是较 Promises 更好的选择</h3><p>Promises 是较回调而言更好的一种选择，但 ES7 中的 async 和 await 更胜过 Promises。</p>
<p>在能使用 ES7 特性的情况下可以尽量使用他们替代 Promises。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>(<span class="string">'request-promise'</span>).get(<span class="string">'https://en.wikipedia.org/wiki/Robert_Cecil_Martin'</span>)</div><div class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">require</span>(<span class="string">'fs-promise'</span>).writeFile(<span class="string">'article.html'</span>, response);</div><div class="line">  &#125;)</div><div class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'File written'</span>);</div><div class="line">  &#125;)</div><div class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.error(err);</div><div class="line">  &#125;)</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getCleanCodeArticle</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">var</span> request = <span class="keyword">await</span> <span class="built_in">require</span>(<span class="string">'request-promise'</span>)</div><div class="line">    <span class="keyword">var</span> response = <span class="keyword">await</span> request.get(<span class="string">'https://en.wikipedia.org/wiki/Robert_Cecil_Martin'</span>);</div><div class="line">    <span class="keyword">var</span> fileHandle = <span class="keyword">await</span> <span class="built_in">require</span>(<span class="string">'fs-promise'</span>);</div><div class="line"></div><div class="line">    <span class="keyword">await</span> fileHandle.writeFile(<span class="string">'article.html'</span>, response);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'File written'</span>);</div><div class="line">  &#125; <span class="keyword">catch</span>(err) &#123;</div><div class="line">    <span class="built_in">console</span>.log(err);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a><strong>错误处理</strong></h2><p>错误抛出是个好东西！这使得你能够成功定位运行状态中的程序产生错误的位置。</p>
<h3 id="别忘了捕获错误"><a href="#别忘了捕获错误" class="headerlink" title="别忘了捕获错误"></a>别忘了捕获错误</h3><p>对捕获的错误不做任何处理是没有意义的。</p>
<p>代码中 <code>try/catch</code> 的意味着你认为这里可能出现一些错误，你应该对这些可能的错误存在相应的处理方案。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  functionThatMightThrow();</div><div class="line">&#125; <span class="keyword">catch</span> (error) &#123;</div><div class="line">  <span class="built_in">console</span>.log(error);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  functionThatMightThrow();</div><div class="line">&#125; <span class="keyword">catch</span> (error) &#123;</div><div class="line">  <span class="comment">// One option (more noisy than console.log):</span></div><div class="line">  <span class="built_in">console</span>.error(error);</div><div class="line">  <span class="comment">// Another option:</span></div><div class="line">  notifyUserOfError(error);</div><div class="line">  <span class="comment">// Another option:</span></div><div class="line">  reportErrorToService(error);</div><div class="line">  <span class="comment">// OR do all three!</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="不要忽略被拒绝的-promises"><a href="#不要忽略被拒绝的-promises" class="headerlink" title="不要忽略被拒绝的 promises"></a>不要忽略被拒绝的 promises</h3><p>理由同 <code>try/catch</code>。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">getdata()</div><div class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</div><div class="line">  functionThatMightThrow(data);</div><div class="line">&#125;)</div><div class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">getdata()</div><div class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</div><div class="line">  functionThatMightThrow(data);</div><div class="line">&#125;)</div><div class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// One option (more noisy than console.log):</span></div><div class="line">  <span class="built_in">console</span>.error(error);</div><div class="line">  <span class="comment">// Another option:</span></div><div class="line">  notifyUserOfError(error);</div><div class="line">  <span class="comment">// Another option:</span></div><div class="line">  reportErrorToService(error);</div><div class="line">  <span class="comment">// OR do all three!</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a><strong>格式化</strong></h2><p>格式化是一件主观的事。如同这里的许多规则一样，这里并没有一定/立刻需要遵守的规则。可以在<a href="http://standardjs.com/rules.html" target="_blank" rel="external">这里</a>完成格式的自动化。</p>
<h3 id="大小写一致"><a href="#大小写一致" class="headerlink" title="大小写一致"></a>大小写一致</h3><p>JS 是弱类型语言，合理的采用大小写可以告诉你关于变量/函数等的许多消息。</p>
<p>这些规则是主观定义的，团队可以根据喜欢进行选择。重点在于无论选择何种风格，都需要注意保持一致性。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> DAYS_IN_WEEK = <span class="number">7</span>;</div><div class="line"><span class="keyword">var</span> daysInMonth = <span class="number">30</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> songs = [<span class="string">'Back In Black'</span>, <span class="string">'Stairway to Heaven'</span>, <span class="string">'Hey Jude'</span>];</div><div class="line"><span class="keyword">var</span> Artists = [<span class="string">'ACDC'</span>, <span class="string">'Led Zeppelin'</span>, <span class="string">'The Beatles'</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">eraseDatabase</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">restore_database</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">animal</span> </span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Alpaca</span> </span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> DAYS_IN_WEEK = <span class="number">7</span>;</div><div class="line"><span class="keyword">var</span> DAYS_IN_MONTH = <span class="number">30</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> songs = [<span class="string">'Back In Black'</span>, <span class="string">'Stairway to Heaven'</span>, <span class="string">'Hey Jude'</span>];</div><div class="line"><span class="keyword">var</span> artists = [<span class="string">'ACDC'</span>, <span class="string">'Led Zeppelin'</span>, <span class="string">'The Beatles'</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">eraseDatabase</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">restoreDatabase</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Alpaca</span> </span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="调用函数的函数和被调函数应放在较近的位置"><a href="#调用函数的函数和被调函数应放在较近的位置" class="headerlink" title="调用函数的函数和被调函数应放在较近的位置"></a>调用函数的函数和被调函数应放在较近的位置</h3><p>当函数间存在相互调用的情况时，应将两者置于较近的位置。</p>
<p>理想情况下，应将调用其他函数的函数写在被调用函数的上方。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PerformanceReview</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(employee) &#123;</div><div class="line">    <span class="keyword">this</span>.employee = employee;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  lookupPeers() &#123;</div><div class="line">    <span class="keyword">return</span> db.lookup(<span class="keyword">this</span>.employee, <span class="string">'peers'</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  lookupMananger() &#123;</div><div class="line">    <span class="keyword">return</span> db.lookup(<span class="keyword">this</span>.employee, <span class="string">'manager'</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  getPeerReviews() &#123;</div><div class="line">    <span class="keyword">let</span> peers = <span class="keyword">this</span>.lookupPeers();</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  perfReview() &#123;</div><div class="line">      getPeerReviews();</div><div class="line">      getManagerReview();</div><div class="line">      getSelfReview();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  getManagerReview() &#123;</div><div class="line">    <span class="keyword">let</span> manager = <span class="keyword">this</span>.lookupManager();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  getSelfReview() &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> review = <span class="keyword">new</span> PerformanceReview(user);</div><div class="line">review.perfReview();</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PerformanceReview</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(employee) &#123;</div><div class="line">    <span class="keyword">this</span>.employee = employee;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  perfReview() &#123;</div><div class="line">      getPeerReviews();</div><div class="line">      getManagerReview();</div><div class="line">      getSelfReview();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  getPeerReviews() &#123;</div><div class="line">    <span class="keyword">let</span> peers = <span class="keyword">this</span>.lookupPeers();</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  lookupPeers() &#123;</div><div class="line">    <span class="keyword">return</span> db.lookup(<span class="keyword">this</span>.employee, <span class="string">'peers'</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  getManagerReview() &#123;</div><div class="line">    <span class="keyword">let</span> manager = <span class="keyword">this</span>.lookupManager();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  lookupMananger() &#123;</div><div class="line">    <span class="keyword">return</span> db.lookup(<span class="keyword">this</span>.employee, <span class="string">'manager'</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  getSelfReview() &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> review = <span class="keyword">new</span> PerformanceReview(employee);</div><div class="line">review.perfReview();</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a><strong>注释</strong></h2><h3 id="只对存在一定业务逻辑复杂性的代码进行注释"><a href="#只对存在一定业务逻辑复杂性的代码进行注释" class="headerlink" title="只对存在一定业务逻辑复杂性的代码进行注释"></a>只对存在一定业务逻辑复杂性的代码进行注释</h3><p>注释并不是必须的，好的代码是能够让人一目了然，不用过多无谓的注释。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hashIt</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">  <span class="comment">// The hash</span></div><div class="line">  <span class="keyword">var</span> hash = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Length of string</span></div><div class="line">  <span class="keyword">var</span> length = data.length;</div><div class="line"></div><div class="line">  <span class="comment">// Loop through every character in data</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</div><div class="line">    <span class="comment">// Get character code.</span></div><div class="line">    <span class="keyword">var</span> char = data.charCodeAt(i);</div><div class="line">    <span class="comment">// Make the hash</span></div><div class="line">    hash = ((hash &lt;&lt; <span class="number">5</span>) - hash) + char;</div><div class="line">    <span class="comment">// Convert to 32-bit integer</span></div><div class="line">    hash = hash &amp; hash;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hashIt</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> hash = <span class="number">0</span>;</div><div class="line">  <span class="keyword">var</span> length = data.length;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</div><div class="line">    <span class="keyword">var</span> char = data.charCodeAt(i);</div><div class="line">    hash = ((hash &lt;&lt; <span class="number">5</span>) - hash) + char;</div><div class="line"></div><div class="line">    <span class="comment">// Convert to 32-bit integer</span></div><div class="line">    hash = hash &amp; hash;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="不要在代码库中遗留被注释掉的代码"><a href="#不要在代码库中遗留被注释掉的代码" class="headerlink" title="不要在代码库中遗留被注释掉的代码"></a>不要在代码库中遗留被注释掉的代码</h3><p>版本控制的存在是有原因的。让旧代码存在于你的 history 里吧。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">doStuff();</div><div class="line"><span class="comment">// doOtherStuff();</span></div><div class="line"><span class="comment">// doSomeMoreStuff();</span></div><div class="line"><span class="comment">// doSoMuchStuff();</span></div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">doStuff();</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="不需要版本更新类型注释"><a href="#不需要版本更新类型注释" class="headerlink" title="不需要版本更新类型注释"></a>不需要版本更新类型注释</h3><p>记住，我们可以使用版本控制。废代码、被注释的代码及用注释记录代码中的版本更新说明都是没有必要的。</p>
<p>需要时可以使用 <code>git log</code> 获取历史版本。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 2016-12-20: Removed monads, didn't understand them (RM)</div><div class="line"> * 2016-10-01: Improved using special monads (JP)</div><div class="line"> * 2016-02-03: Removed type-checking (LI)</div><div class="line"> * 2015-03-14: Added combine with type-checking (JR)</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">combine</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">combine</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="避免位置标记"><a href="#避免位置标记" class="headerlink" title="避免位置标记"></a>避免位置标记</h3><p>这些东西通常只能代码麻烦，采用适当的缩进就可以了。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="comment">// Scope Model Instantiation</span></div><div class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="keyword">let</span> $scope.model = &#123;</div><div class="line">  <span class="attr">menu</span>: <span class="string">'foo'</span>,</div><div class="line">  <span class="attr">nav</span>: <span class="string">'bar'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="comment">// Action setup</span></div><div class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="keyword">let</span> actions = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> $scope.model = &#123;</div><div class="line">  <span class="attr">menu</span>: <span class="string">'foo'</span>,</div><div class="line">  <span class="attr">nav</span>: <span class="string">'bar'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> actions = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>
<h3 id="避免在源文件中写入法律评论"><a href="#避免在源文件中写入法律评论" class="headerlink" title="避免在源文件中写入法律评论"></a>避免在源文件中写入法律评论</h3><p>将你的 <code>LICENSE</code> 文件置于源码目录树的根目录。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">The MIT License (MIT)</div><div class="line"></div><div class="line">Copyright (c) 2016 Ryan McDermott</div><div class="line"></div><div class="line">Permission is hereby granted, free of charge, to any person obtaining a copy</div><div class="line">of this software and associated documentation files (the "Software"), to deal</div><div class="line">in the Software without restriction, including without limitation the rights</div><div class="line">to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</div><div class="line">copies of the Software, and to permit persons to whom the Software is</div><div class="line">furnished to do so, subject to the following conditions:</div><div class="line"></div><div class="line">The above copyright notice and this permission notice shall be included in all</div><div class="line">copies or substantial portions of the Software.</div><div class="line"></div><div class="line">THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</div><div class="line">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</div><div class="line">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</div><div class="line">AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</div><div class="line">LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</div><div class="line">OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</div><div class="line">SOFTWARE</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateBill</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateBill</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><a href="#目录">回到目录</a></strong></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">javascript</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/04/30/clean-code-js/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-HTTP状态码" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/09/HTTP状态码/">HTTP状态码</a>
    </h1>
  

        
        <a href="/2017/04/09/HTTP状态码/" class="archive-article-date">
  	<time datetime="2017-04-09T12:36:27.352Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-04-09</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><ul>
<li><p>100 请求者应继续进行请求。服务器返回此代码以表示，服务器已收到某项请求的第一部分，正等待接收剩余部分。</p>
</li>
<li><p>101 请求者已要求服务器切换协议，服务器已确认并准备切换。</p>
</li>
<li><p>200 服务器已成功处理相应请求。通常，这表示服务器提供了请求的网页。如果您的 robots.txt 文件显示为此状态，则表示 Googlebot 已成功检索到该文件。</p>
</li>
<li><p>201 请求成功且服务器创建了新的资源。</p>
</li>
<li><p>202 服务器已接受相应请求，但尚未对其进行处理。</p>
</li>
<li><p>203 服务器已成功处理相应请求，但返回了可能来自另一来源的信息。</p>
</li>
<li><p>204 服务器已成功处理相应请求，但未返回任何内容。</p>
</li>
<li><p>205 服务器已成功处理相应请求，但未返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如清除表单内容以输入新内容）</p>
</li>
<li><p>206 服务器成功处理了部分 GET 请求。</p>
</li>
<li><p>300 服务器可以根据请求来执行多项操作，例如：按照请求者（用户代理）的要求来选择某项操作或者展示列表以便请求者选择其中某项操作。</p>
</li>
<li><p>301 请求的网页已被永久迁移至新位置。服务器返回此响应（作为对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码通知 Googlebot 某个网页或网站已被永久迁移至新位置。</p>
</li>
<li><p>302 服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置。但由于 Googlebot 会继续抓取原有位置并将其编入索引，因此您不应使用此代码来通知 Googlebot 某个页面或网站已被迁移。</p>
</li>
<li><p>303 当请求者应对不同的位置进行单独的 GET 请求以检索响应时，服务器会返回此代码。对于除 HEAD 请求之外的所有请求，服务器会自动转到其他位置。</p>
</li>
<li><p>304 请求的网页自上次请求后再也没有修改过。当服务器返回此响应时，不会返回相关网页的内容。<br>如果网页自请求者上次请求后再也没有更改过，您应当将服务器配置为返回此响应（称为 If Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。</p>
</li>
<li><p>305 请求者只能使用代理访问请求的网页。如果服务器返回此响应，那么服务器还会指明请求者应当使用的代理。</p>
</li>
<li><p>307 服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置。但由于 Googlebot 会继续抓取原有位置并将其编入索引，因此您不应使用此代码来通知 Googlebot 某个页面或网站已被迁移。</p>
</li>
<li><p>400 服务器不理解请求的语法。</p>
</li>
<li><p>401 请求要求进行身份验证。登录后，服务器可能会返回对页面的此响应。</p>
</li>
<li><p>403 服务器正在拒绝相应请求。如果 Googlebot 在尝试抓取网站的有效网页时收到此状态代码（您可在 Google Search Console 中运行状况下的抓取错误页上进行查看），则可能是因为您的服务器或主机正在阻止 Googlebot 进行访问。</p>
</li>
<li><p>404 服务器找不到请求的网页。例如，如果相应请求是针对服务器上不存在的网页进行的，那么服务器通常会返回此代码。如果您的网站上没有 robots.txt 文件，而您在 Google Search Console 中的已拦截的网址页上看到此状态，那么这就是正确的状态。但是，如果您有 robots.txt 文件而又看到此状态，则说明您的 robots.txt 文件可能命名错误或位于错误的位置（该文件应当位于顶级域名上，且应当名为 robots.txt）。如果您在 Googlebot 尝试抓取的网址上看到此状态，那么这表示 Googlebot 追踪的可能是另一网页中的无效链接（旧链接或输入有误的链接）。</p>
</li>
<li><p>405 禁用请求中所指定的方法。</p>
</li>
<li><p>406 无法使用请求的内容特性来响应请求的网页。</p>
</li>
<li><p>407 此状态代码与 401（未授权）类似，但却指定了请求者应当使用代理进行授权。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的代理。</p>
</li>
<li><p>408 服务器等待请求超时。</p>
</li>
<li><p>409 服务器在完成请求时遇到冲突。服务器必须在响应中包含该冲突的相关信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，同时会提供两个请求的差异列表。</p>
</li>
<li><p>410 如果请求的资源已被永久移除，那么，服务器会返回此响应。该代码与 404（未找到）代码类似，但在资源以前有但现在已经不复存在的情况下，有时会替代 404 代码出现。如果资源已被永久删除，那么，您应当使用 301 代码指定该资源的新位置。</p>
</li>
<li><p>411 服务器不会接受包含无效内容长度标头字段的请求。</p>
</li>
<li><p>412 服务器未满足请求者在请求中设置的其中一个前提条件。</p>
</li>
<li><p>413 服务器无法处理请求，因为请求实体过大，已超出服务器的处理能力。</p>
</li>
<li><p>414 请求的 URI（通常为网址）过长，服务器无法进行处理。</p>
</li>
<li><p>415 请求的格式不受请求页面的支持。 </p>
</li>
<li><p>416 如果相应请求是针对网页的无效范围进行的，那么服务器会返回此状态代码。 </p>
</li>
<li><p>417 服务器未满足“期望”请求标头字段的要求。 </p>
</li>
<li><p>500 服务器遇到错误，无法完成请求。</p>
</li>
<li><p>501 服务器不具备完成相应请求的功能。例如，当服务器无法识别请求方法时，可能便会返回此代码。</p>
</li>
<li><p>502 服务器作为网关或代理，从上游服务器收到了无效的响应。</p>
</li>
<li><p>503 目前无法使用服务器（由于超载或进行停机维护）。通常，这只是一种暂时的状态。</p>
</li>
<li><p>504 服务器作为网关或代理，未及时从上游服务器接收请求。</p>
</li>
<li><p>505 服务器不支持相应请求中所用的 HTTP 协议版本。</p>
</li>
</ul>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">HTTP</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/04/09/HTTP状态码/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Java8 Lambda表达式" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/09/Java8 Lambda表达式/">Java8 Lambda表达式</a>
    </h1>
  

        
        <a href="/2017/04/09/Java8 Lambda表达式/" class="archive-article-date">
  	<time datetime="2017-04-09T12:05:07.732Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-04-09</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Java8-Lambda表达式"><a href="#Java8-Lambda表达式" class="headerlink" title="Java8 Lambda表达式"></a>Java8 Lambda表达式</h3><p><strong>1. 什么是λ表达式</strong></p>
<p>λ表达式本质上是一个匿名方法。让我们来看下面这个例子：</p>
<pre><code>public int add(int x, int y) {
    return x + y;
}
</code></pre><p>转成λ表达式后是这个样子：</p>
<pre><code>(int x, int y) -&gt; x + y;
</code></pre><p>参数类型也可以省略，Java编译器会根据上下文推断出来：</p>
<pre><code>(x, y) -&gt; x + y; //返回两数之和
</code></pre><p>或者</p>
<pre><code>(x, y) -&gt; { return x + y; } //显式指明返回值
</code></pre><p>可见λ表达式有三部分组成：参数列表，箭头（-&gt;），以及一个表达式或语句块。</p>
<p>下面这个例子里的λ表达式没有参数，也没有返回值（相当于一个方法接受0个参数，返回void，其实就是Runnable里run方法的一个实现）：</p>
<pre><code>() -&gt; { System.out.println(&quot;Hello Lambda!&quot;); }
</code></pre><p>如果只有一个参数且可以被Java推断出类型，那么参数列表的括号也可以省略：</p>
<pre><code>c -&gt; { return c.size(); }
</code></pre><p><strong>2. λ表达式的类型（它是Object吗？）</strong></p>
<p>λ表达式可以被当做是一个Object（注意措辞）。λ表达式的类型，叫做“目标类型（target type）”。λ表达式的目标类型是“函数接口（functional interface）”，这是Java8新引入的概念。它的定义是：一个接口，如果只有一个显式声明的抽象方法，那么它就是一个函数接口。一般用@FunctionalInterface标注出来（也可以不标）。举例如下：</p>
<pre><code>@FunctionalInterface
public interface Runnable { void run(); }

public interface Callable&lt;V&gt; { V call() throws Exception; }

public interface ActionListener { void actionPerformed(ActionEvent e); }

public interface Comparator&lt;T&gt; { int compare(T o1, T o2); boolean equals(Object obj); }
</code></pre><p>注意最后这个Comparator接口。它里面声明了两个方法，貌似不符合函数接口的定义，但它的确是函数接口。这是因为equals方法是Object的，所有的接口都会声明Object的public方法——虽然大多是隐式的。所以，Comparator显式的声明了equals不影响它依然是个函数接口。</p>
<p>你可以用一个λ表达式为一个函数接口赋值：</p>
<pre><code>Runnable r1 = () -&gt; {System.out.println(&quot;Hello Lambda!&quot;);};
</code></pre><p>然后再赋值给一个Object：</p>
<pre><code>Object obj = r1;
</code></pre><p>但却不能这样干：</p>
<pre><code>Object obj = () -&gt; {System.out.println(&quot;Hello Lambda!&quot;);}; 
// ERROR! Object is not a functional interface!
</code></pre><p>必须显式的转型成一个函数接口才可以：</p>
<pre><code>Object o = (Runnable) () -&gt; { System.out.println(&quot;hi&quot;); }; // correct
</code></pre><p>一个λ表达式只有在转型成一个函数接口后才能被当做Object使用。所以下面这句也不能编译：</p>
<pre><code>System.out.println( () -&gt; {} ); //错误! 目标类型不明
</code></pre><p>必须先转型:</p>
<pre><code>System.out.println( (Runnable)() -&gt; {} ); // 正确
</code></pre><p>假设你自己写了一个函数接口，长的跟Runnable一模一样：</p>
<pre><code>@FunctionalInterface
public interface MyRunnable {
    public void run();
}
</code></pre><p>那么</p>
<pre><code>Runnable r1 =    () -&gt; {System.out.println(&quot;Hello Lambda!&quot;);};
MyRunnable2 r2 = () -&gt; {System.out.println(&quot;Hello Lambda!&quot;);};
</code></pre><p>JDK预定义了很多函数接口以避免用户重复定义。最典型的是Function：</p>
<pre><code>@FunctionalInterface
public interface Function&lt;T, R&gt; {  
    R apply(T t);
}
</code></pre><p>这个接口代表一个函数，接受一个T类型的参数，并返回一个R类型的返回值。   </p>
<p>另一个预定义函数接口叫做Consumer，跟Function的唯一不同是它没有返回值。</p>
<pre><code>@FunctionalInterface
public interface Consumer&lt;T&gt; {
    void accept(T t);
}
</code></pre><p>还有一个Predicate，用来判断某项条件是否满足。经常用来进行筛滤操作：</p>
<pre><code>@FunctionalInterface
public interface Predicate&lt;T&gt; {
    boolean test(T t);
}
</code></pre><p>综上所述，一个λ表达式其实就是定义了一个匿名方法，只不过这个方法必须符合至少一个函数接口。</p>
<p><strong>3. λ表达式的使用</strong></p>
<p><strong><em>3.1 λ表达式用在何处</em></strong></p>
<p>λ表达式主要用于替换以前广泛使用的内部匿名类，各种回调，比如事件响应器、传入Thread类的Runnable等。看下面的例子：</p>
<pre><code>Thread oldSchool = new Thread( new Runnable () {
    @Override
    public void run() {
        System.out.println(&quot;This is from an anonymous class.&quot;);
    }
} );
Thread gaoDuanDaQiShangDangCi = new Thread( () -&gt; {
    System.out.println(&quot;This is from an anonymous method (lambda exp).&quot;);
} );
</code></pre><p>注意第二个线程里的λ表达式，你并不需要显式地把它转成一个Runnable，因为Java能根据上下文自动推断出来：一个Thread的构造函数接受一个Runnable参数，而传入的λ表达式正好符合其run()函数，所以Java编译器推断它为Runnable。</p>
<p>从形式上看，λ表达式只是为你节省了几行代码。但将λ表达式引入Java的动机并不仅仅为此。Java8有一个短期目标和一个长期目标。短期目标是：配合“集合类批处理操作”的内部迭代和并行处理（下面将要讲到）；长期目标是将Java向函数式编程语言这个方向引导（并不是要完全变成一门函数式编程语言，只是让它有更多的函数式编程语言的特性），也正是由于这个原因，Oracle并没有简单地使用内部类去实现λ表达式，而是使用了一种更动态、更灵活、易于将来扩展和改变的策略（invokedynamic）。</p>
<p><strong><em>3.2 λ表达式与集合类批处理操作（或者叫块操作）</em></strong></p>
<p>上文提到了集合类的批处理操作。这是Java8的另一个重要特性，它与λ表达式的配合使用乃是Java8的最主要特性。集合类的批处理操作API的目的是实现集合类的“内部迭代”，并期望充分利用现代多核CPU进行并行计算。<br>Java8之前集合类的迭代（Iteration）都是外部的，即客户代码。而内部迭代意味着改由Java类库来进行迭代，而不是客户代码。例如：</p>
<pre><code>for(Object o: list) { // 外部迭代
    System.out.println(o);
}
</code></pre><p>可以写成</p>
<pre><code>//forEach函数实现内部迭代
list.forEach(o -&gt; {System.out.println(o);}); 
</code></pre><p>集合类（包括List）现在都有一个forEach方法，对元素进行迭代（遍历），所以我们不需要再写for循环了。forEach方法接受一个函数接口Consumer做参数，所以可以使用λ表达式。</p>
<p>这种内部迭代方法广泛存在于各种语言，如C++的STL算法库、Python、ruby、Scala等。</p>
<p>Java8为集合类引入了另一个重要概念：流（stream）。一个流通常以一个集合类实例为其数据源，然后在其上定义各种操作。流的API设计使用了管道（pipelines）模式。对流的一次操作会返回另一个流。如同IO的API或者StringBuffer的append方法那样，从而多个不同的操作可以在一个语句里串起来。看下面的例子：</p>
<pre><code>List&lt;Shape&gt; shapes = ...
shapes.stream()
  .filter(s -&gt; s.getColor() == BLUE)
  .forEach(s -&gt; s.setColor(RED));
</code></pre><p>首先调用stream方法，以集合类对象shapes里面的元素为数据源，生成一个流。然后在这个流上调用filter方法，挑出蓝色的，返回另一个流。最后调用forEach方法将这些蓝色的物体喷成红色。（forEach方法不再返回流，而是一个终端方法，类似于StringBuffer在调用若干append之后的那个toString）</p>
<p>filter方法的参数是Predicate类型，forEach方法的参数是Consumer类型，它们都是函数接口，所以可以使用λ表达式。</p>
<p>还有一个方法叫parallelStream()，顾名思义它和stream()一样，只不过指明要并行处理，以期充分利用现代CPU的多核特性。</p>
<pre><code>shapes.parallelStream(); // 或shapes.stream().parallel()
</code></pre><p>来看更多的例子。下面是典型的大数据处理方法，Filter-Map-Reduce：</p>
<pre><code>//给出一个String类型的数组，找出其中所有不重复的素数
public void distinctPrimary(String... numbers) {
    List&lt;String&gt; l = Arrays.asList(numbers);
    List&lt;Integer&gt; r = l.stream()
            .map(e -&gt; new Integer(e))
            .filter(e -&gt; Primes.isPrime(e))
            .distinct()
            .collect(Collectors.toList());
    System.out.println(&quot;distinctPrimary result is: &quot; + r);
}
</code></pre><p>第一步：传入一系列String（假设都是合法的数字），转成一个List，然后调用stream()方法生成流。</p>
<p>第二步：调用流的map方法把每个元素由String转成Integer，得到一个新的流。map方法接受一个Function类型的参数，上面介绍了，Function是个函数接口，所以这里用λ表达式。</p>
<p>第三步：调用流的filter方法，过滤那些不是素数的数字，并得到一个新流。filter方法接受一个Predicate类型的参数，上面介绍了，Predicate是个函数接口，所以这里用λ表达式。</p>
<p>第四步：调用流的distinct方法，去掉重复，并得到一个新流。这本质上是另一个filter操作。</p>
<p>第五步：用collect方法将最终结果收集到一个List里面去。collect方法接受一个Collector类型的参数，这个参数指明如何收集最终结果。在这个例子中，结果简单地收集到一个List中。我们也可以用Collectors.toMap(e-&gt;e, e-&gt;e)把结果收集到一个Map中，它的意思是：把结果收到一个Map，用这些素数自身既作为键又作为值。toMap方法接受两个Function类型的参数，分别用以生成键和值，Function是个函数接口，所以这里都用λ表达式。</p>
<p>你可能会觉得在这个例子里，List l被迭代了好多次，map，filter，distinct都分别是一次循环，效率会不好。实际并非如此。这些返回另一个Stream的方法都是“懒（lazy）”的，而最后返回最终结果的collect方法则是“急（eager）”的。在遇到eager方法之前，lazy的方法不会执行。</p>
<p>当遇到eager方法时，前面的lazy方法才会被依次执行。而且是管道贯通式执行。这意味着每一个元素依次通过这些管道。例如有个元素“3”，首先它被map成整数型3；然后通过filter，发现是素数，被保留下来；又通过distinct，如果已经有一个3了，那么就直接丢弃，如果还没有则保留。这样，3个操作其实只经过了一次循环。</p>
<blockquote>
<p>除collect外其它的eager操作还有forEach，toArray，reduce等。</p>
</blockquote>
<p>下面来看一下也许是最常用的收集器方法，groupingBy：</p>
<pre><code>//给出一个String类型的数组，找出其中各个素数，并统计其出现次数
public void primaryOccurrence(String... numbers) {
    List&lt;String&gt; l = Arrays.asList(numbers);
    Map&lt;Integer, Integer&gt; r = l.stream()
        .map(e -&gt; new Integer(e))
        .filter(e -&gt; Primes.isPrime(e))
        .collect( Collectors.groupingBy(p-&gt;p, Collectors.summingInt(p-&gt;1)) );
    System.out.println(&quot;primaryOccurrence result is: &quot; + r);
}
</code></pre><p>注意这一行：</p>
<pre><code>Collectors.groupingBy(p-&gt;p, Collectors.summingInt(p-&gt;1))
</code></pre><p>它的意思是：把结果收集到一个Map中，用统计到的各个素数自身作为键，其出现次数作为值。</p>
<p>下面是一个reduce的例子：</p>
<pre><code>//给出一个String类型的数组，求其中所有不重复素数的和
public void distinctPrimarySum(String... numbers) {
    List&lt;String&gt; l = Arrays.asList(numbers);
    int sum = l.stream()
        .map(e -&gt; new Integer(e))
        .filter(e -&gt; Primes.isPrime(e))
        .distinct()
        .reduce(0, (x,y) -&gt; x+y); // equivalent to .sum()
    System.out.println(&quot;distinctPrimarySum result is: &quot; + sum);
}
</code></pre><p>reduce方法用来产生单一的一个最终结果。</p>
<p>流有很多预定义的reduce操作，如sum()，max()，min()等。</p>
<p>再举个现实世界里的例子比如：</p>
<pre><code>// 统计年龄在25-35岁的男女人数、比例
public void boysAndGirls(List&lt;Person&gt; persons) {
    Map&lt;Integer, Integer&gt; result = persons.parallelStream().filter(p -&gt;
     p.getAge()&gt;=25 &amp;&amp; p.getAge()&lt;=35).
        collect(
            Collectors.groupingBy(p-&gt;p.getSex(), Collectors.summingInt(p-&gt;1))
    );
    System.out.print(&quot;boysAndGirls result is &quot; + result);
    System.out.println(&quot;, ratio (male : female) is &quot; + (float)result.get
    (Person.MALE)/result.get(Person.FEMALE));
}
</code></pre><p><strong><strong>3.3 λ表达式的更多用法</strong></strong></p>
<pre><code>// 嵌套的λ表达式
Callable&lt;Runnable&gt; c1 = () -&gt; () -&gt; { System.out.println(&quot;Nested lambda&quot;); };
c1.call().run();

// 用在条件表达式中
Callable&lt;Integer&gt; c2 = true ? (() -&gt; 42) : (() -&gt; 24);
System.out.println(c2.call());

// 定义一个递归函数，注意须用this限定
protected UnaryOperator&lt;Integer&gt; factorial = i -&gt; i == 0 ? 1 : i * this.factorial.apply( i - 1 );
...
System.out.println(factorial.apply(3));
</code></pre><p>在Java中，随声明随调用的方式是不行的，比如下面这样，声明了一个λ表达式(x, y) -&gt; x + y，同时企图通过传入实参(2, 3)来调用它：</p>
<pre><code>int five = ( (x, y) -&gt; x + y ) (2, 3); // ERROR! try to call a lambda in-place
</code></pre><p>这在C++中是可以的，但Java中不行。Java的λ表达式只能用作赋值、传参、返回值等。</p>
<p><strong>4. 其它相关概念</strong></p>
<p><strong><em>4.1 捕获（Capture）</em></strong></p>
<p>捕获的概念在于解决在λ表达式中我们可以使用哪些外部变量（即除了它自己的参数和内部定义的本地变量）的问题。</p>
<p>答案是：与内部类非常相似，但有不同点。不同点在于内部类总是持有一个其外部类对象的引用。而λ表达式呢，除非在它内部用到了其外部类（包围类）对象的方法或者成员，否则它就不持有这个对象的引用。</p>
<p>在Java8以前，如果要在内部类访问外部对象的一个本地变量，那么这个变量必须声明为final才行。在Java8中，这种限制被去掉了，代之以一个新的概念，“effectively final”。它的意思是你可以声明为final，也可以不声明final但是按照final来用，也就是一次赋值永不改变。换句话说，保证它加上final前缀后不会出编译错误。</p>
<p>在Java8中，内部类和λ表达式都可以访问effectively final的本地变量。λ表达式的例子如下：</p>
<pre><code> ...    
int tmp1 = 1; //包围类的成员变量
static int tmp2 = 2; //包围类的静态成员变量
public void testCapture() {
    int tmp3 = 3; //没有声明为final，但是effectively final的本地变量
    final int tmp4 = 4; //声明为final的本地变量
    int tmp5 = 5; //普通本地变量

    Function&lt;Integer, Integer&gt; f1 = i -&gt; i + tmp1;
    Function&lt;Integer, Integer&gt; f2 = i -&gt; i + tmp2;
    Function&lt;Integer, Integer&gt; f3 = i -&gt; i + tmp3;
    Function&lt;Integer, Integer&gt; f4 = i -&gt; i + tmp4;
    Function&lt;Integer, Integer&gt; f5 = i -&gt; {
        tmp5  += i; // 编译错！对tmp5赋值导致它不是effectively final的
        return tmp5;
    };
    ...
    tmp5 = 9; // 编译错！对tmp5赋值导致它不是effectively final的
}
...
</code></pre><p>Java要求本地变量final或者effectively final的原因是多线程并发问题。内部类、λ表达式都有可能在不同的线程中执行，允许多个线程同时修改一个本地变量不符合Java的设计理念。</p>
<p><strong><em>4.2 方法引用（Method reference）</em></strong></p>
<p>任何一个λ表达式都可以代表某个函数接口的唯一方法的匿名描述符。我们也可以使用某个类的某个具体方法来代表这个描述符，叫做方法引用。例如：</p>
<pre><code>Integer::parseInt //静态方法引用
System.out::print //实例方法引用
Person::new       //构造器引用
</code></pre><p>下面是一组例子，教你使用方法引用代替λ表达式：</p>
<pre><code>//c1 与 c2 是一样的（静态方法引用）
Comparator&lt;Integer&gt; c2 = (x, y) -&gt; Integer.compare(x, y);
Comparator&lt;Integer&gt; c1 = Integer::compare;

//下面两句是一样的（实例方法引用1）
persons.forEach(e -&gt; System.out.println(e));
persons.forEach(System.out::println);

//下面两句是一样的（实例方法引用2）
persons.forEach(person -&gt; person.eat());
persons.forEach(Person::eat);

//下面两句是一样的（构造器引用）
strList.stream().map(s -&gt; new Integer(s));
strList.stream().map(Integer::new);
</code></pre><p>使用方法引用，你的程序会变得更短些。现在distinctPrimarySum方法可以改写如下：</p>
<pre><code>public void distinctPrimarySum(String... numbers) {
    List&lt;String&gt; l = Arrays.asList(numbers);
    int sum = l.stream().map(Integer::new).filter(Primes::isPrime).distinct().sum();
    System.out.println(&quot;distinctPrimarySum result is: &quot; + sum);
}
</code></pre><p>还有一些其它的方法引用:</p>
<pre><code>super::toString //引用某个对象的父类方法
String[]::new //引用一个数组的构造器
</code></pre><p><strong><em>4.3 默认方法（Default method）</em></strong></p>
<p>Java8中，接口声明里可以有方法实现了，叫做默认方法。在此之前，接口里的方法全部是抽象方法。</p>
<pre><code>public interface MyInterf {
    String m1();
    default String m2() {
        return &quot;Hello default method!&quot;;
    }
}
</code></pre><p>这实际上混淆了接口和抽象类，但一个类仍然可以实现多个接口，而只能继承一个抽象类。</p>
<p>这么做的原因是：由于Collection库需要为批处理操作添加新的方法，如forEach()，stream()等，但是不能修改现有的Collection接口——如果那样做的话所有的实现类都要进行修改，包括很多客户自制的实现类。所以只好使用这种妥协的办法。</p>
<p>如此一来，我们就面临一种类似多继承的问题。如果类Sub继承了两个接口，Base1和Base2，而这两个接口恰好具有完全相同的两个默认方法，那么就会产生冲突。这时Sub类就必须通过重载来显式指明自己要使用哪一个接口的实现（或者提供自己的实现）：</p>
<pre><code>public class Sub implements Base1, Base2 {
    public void hello() {
        Base1.super.hello(); //使用Base1的实现
    }
}
</code></pre><p>除了默认方法，Java8的接口也可以有静态方法的实现：</p>
<pre><code>public interface MyInterf {
    String m1();
    default String m2() {
        return &quot;Hello default method!&quot;;
    }
    static String m3() {
        return &quot;Hello static method in Interface!&quot;;
    }
}
</code></pre><p><strong><em>4.4 生成器函数（Generator function）</em></strong></p>
<p>有时候一个流的数据源不一定是一个已存在的集合对象，也可能是个“生成器函数”。一个生成器函数会产生一系列元素，供给一个流。Stream.generate(Supplier<t> s)就是一个生成器函数。其中参数Supplier是一个函数接口，里面有唯一的抽象方法 <t> get()。</t></t></p>
<p>下面这个例子生成并打印5个随机数：</p>
<pre><code>Stream.generate(Math::random).limit(5).forEach(System.out::println);
</code></pre><p>注意这个limit(5)，如果没有这个调用，那么这条语句会永远地执行下去。也就是说这个生成器是无穷的。这种调用叫做终结操作，或者短路（short-circuiting）操作。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">java</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/04/09/Java8 Lambda表达式/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
    </nav>
  


          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 marnner
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		mathjax: false,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true,
		showTags: true
	}
</script>

<script>!function(t){function n(r){if(e[r])return e[r].exports;var o=e[r]={exports:{},id:r,loaded:!1};return t[r].call(o.exports,o,o.exports,n),o.loaded=!0,o.exports}var e={};n.m=t,n.c=e,n.p="./",n(0)}([function(t,n,e){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,n){var e=/\/|index.html/g;return t.replace(e,"")===n.replace(e,"")}function i(){for(var t=document.querySelectorAll(".js-header-menu li a"),n=window.location.pathname,e=0,r=t.length;e<r;e++){var i=t[e];o(n,i.getAttribute("href"))&&(0,p.default)(i,"active")}}function u(t){for(var n=t.offsetLeft,e=t.offsetParent;null!==e;)n+=e.offsetLeft,e=e.offsetParent;return n}function c(t){for(var n=t.offsetTop,e=t.offsetParent;null!==e;)n+=e.offsetTop,e=e.offsetParent;return n}function f(t,n,e,r,o){var i=u(t),f=c(t)-n;if(f-e<=o){var a=t.$newDom;a||(a=t.cloneNode(!0),(0,v.default)(t,a),t.$newDom=a,a.style.position="fixed",a.style.top=(e||f)+"px",a.style.left=i+"px",a.style.zIndex=r||2,a.style.width="100%",a.style.color="#fff"),a.style.visibility="visible",t.style.visibility="hidden"}else{t.style.visibility="visible";var s=t.$newDom;s&&(s.style.visibility="hidden")}}function a(){var t=document.querySelector(".js-overlay"),n=document.querySelector(".js-header-menu");f(t,document.body.scrollTop,-63,2,0),f(n,document.body.scrollTop,1,3,0)}function s(){document.querySelector("#container").addEventListener("scroll",function(t){a()}),window.addEventListener("scroll",function(t){a()}),a()}var l=e(25),p=r(l),d=e(26),y=(r(d),e(96)),v=r(y),h=e(97),b=r(h),x=e(98),m=r(x),g=e(27);!function(){b.default.versions.mobile&&window.screen.width<800&&(i(),s())}(),(0,g.addLoadEvent)(function(){m.default.init()}),t.exports={}},,,,,,,,,,,,,,,,,,,,,,,,,function(t,n){function e(t,n){t.classList?t.classList.add(n):t.className+=" "+n}t.exports=e},function(t,n){function e(t,n){if(t.classList)t.classList.remove(n);else{var e=new RegExp("(^|\\b)"+n.split(" ").join("|")+"(\\b|$)","gi");t.className=t.className.replace(e," ")}}t.exports=e},function(t,n,e){"use strict";var r=e(28),o=function(t){return t&&t.__esModule?t:{default:t}}(r),i=function(){function t(t,n,r){return n||r?String.fromCharCode(n||r):e[t]||t}function n(t){return r[t]}var e={"&quot;":'"',"&lt;":"<","&gt;":">","&amp;":"&","&nbsp;":" "},r={};for(var u in e)r[e[u]]=u;return e["&apos;"]="'",r["'"]="&#39;",{encode:function(t){return t?(""+t).replace(/['<> "&]/g,n).replace(/\r?\n/g,"<br/>").replace(/\s/g,"&nbsp;"):""},decode:function(n){return n?(""+n).replace(/<br\s*\/?>/gi,"\n").replace(/&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g,t).replace(/\u00a0/g," "):""},encodeBase16:function(t){if(!t)return t;t+="";for(var n=[],e=0,r=t.length;r>e;e++)n.push(t.charCodeAt(e).toString(16).toUpperCase());return n.join("")},encodeBase16forJSON:function(t){if(!t)return t;t=t.replace(/[\u4E00-\u9FBF]/gi,function(t){return escape(t).replace("%u","\\u")});for(var n=[],e=0,r=t.length;r>e;e++)n.push(t.charCodeAt(e).toString(16).toUpperCase());return n.join("")},decodeBase16:function(t){if(!t)return t;t+="";for(var n=[],e=0,r=t.length;r>e;e+=2)n.push(String.fromCharCode("0x"+t.slice(e,e+2)));return n.join("")},encodeObject:function(t){if(t instanceof Array)for(var n=0,e=t.length;e>n;n++)t[n]=i.encodeObject(t[n]);else if("object"==(void 0===t?"undefined":(0,o.default)(t)))for(var r in t)t[r]=i.encodeObject(t[r]);else if("string"==typeof t)return i.encode(t);return t},loadScript:function(t){var n=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(n),n.setAttribute("src",t)},addLoadEvent:function(t){var n=window.onload;"function"!=typeof window.onload?window.onload=t:window.onload=function(){n(),t()}}}}();t.exports=i},function(t,n,e){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}n.__esModule=!0;var o=e(29),i=r(o),u=e(80),c=r(u),f="function"==typeof c.default&&"symbol"==typeof i.default?function(t){return typeof t}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":typeof t};n.default="function"==typeof c.default&&"symbol"===f(i.default)?function(t){return void 0===t?"undefined":f(t)}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":void 0===t?"undefined":f(t)}},function(t,n,e){t.exports={default:e(30),__esModule:!0}},function(t,n,e){e(31),e(75),t.exports=e(79).f("iterator")},function(t,n,e){"use strict";var r=e(32)(!0);e(35)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,e=this._i;return e>=n.length?{value:void 0,done:!0}:(t=r(n,e),this._i+=t.length,{value:t,done:!1})})},function(t,n,e){var r=e(33),o=e(34);t.exports=function(t){return function(n,e){var i,u,c=String(o(n)),f=r(e),a=c.length;return f<0||f>=a?t?"":void 0:(i=c.charCodeAt(f),i<55296||i>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):i:t?c.slice(f,f+2):u-56320+(i-55296<<10)+65536)}}},function(t,n){var e=Math.ceil,r=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?r:e)(t)}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n,e){"use strict";var r=e(36),o=e(37),i=e(52),u=e(42),c=e(53),f=e(54),a=e(55),s=e(71),l=e(73),p=e(72)("iterator"),d=!([].keys&&"next"in[].keys()),y=function(){return this};t.exports=function(t,n,e,v,h,b,x){a(e,n,v);var m,g,w,O=function(t){if(!d&&t in P)return P[t];switch(t){case"keys":return function(){return new e(this,t)};case"values":return function(){return new e(this,t)}}return function(){return new e(this,t)}},S=n+" Iterator",_="values"==h,j=!1,P=t.prototype,E=P[p]||P["@@iterator"]||h&&P[h],M=E||O(h),A=h?_?O("entries"):M:void 0,T="Array"==n?P.entries||E:E;if(T&&(w=l(T.call(new t)))!==Object.prototype&&(s(w,S,!0),r||c(w,p)||u(w,p,y)),_&&E&&"values"!==E.name&&(j=!0,M=function(){return E.call(this)}),r&&!x||!d&&!j&&P[p]||u(P,p,M),f[n]=M,f[S]=y,h)if(m={values:_?M:O("values"),keys:b?M:O("keys"),entries:A},x)for(g in m)g in P||i(P,g,m[g]);else o(o.P+o.F*(d||j),n,m);return m}},function(t,n){t.exports=!0},function(t,n,e){var r=e(38),o=e(39),i=e(40),u=e(42),c=function(t,n,e){var f,a,s,l=t&c.F,p=t&c.G,d=t&c.S,y=t&c.P,v=t&c.B,h=t&c.W,b=p?o:o[n]||(o[n]={}),x=b.prototype,m=p?r:d?r[n]:(r[n]||{}).prototype;p&&(e=n);for(f in e)(a=!l&&m&&void 0!==m[f])&&f in b||(s=a?m[f]:e[f],b[f]=p&&"function"!=typeof m[f]?e[f]:v&&a?i(s,r):h&&m[f]==s?function(t){var n=function(n,e,r){if(this instanceof t){switch(arguments.length){case 0:return new t;case 1:return new t(n);case 2:return new t(n,e)}return new t(n,e,r)}return t.apply(this,arguments)};return n.prototype=t.prototype,n}(s):y&&"function"==typeof s?i(Function.call,s):s,y&&((b.virtual||(b.virtual={}))[f]=s,t&c.R&&x&&!x[f]&&u(x,f,s)))};c.F=1,c.G=2,c.S=4,c.P=8,c.B=16,c.W=32,c.U=64,c.R=128,t.exports=c},function(t,n){var e=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=e)},function(t,n){var e=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=e)},function(t,n,e){var r=e(41);t.exports=function(t,n,e){if(r(t),void 0===n)return t;switch(e){case 1:return function(e){return t.call(n,e)};case 2:return function(e,r){return t.call(n,e,r)};case 3:return function(e,r,o){return t.call(n,e,r,o)}}return function(){return t.apply(n,arguments)}}},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n,e){var r=e(43),o=e(51);t.exports=e(47)?function(t,n,e){return r.f(t,n,o(1,e))}:function(t,n,e){return t[n]=e,t}},function(t,n,e){var r=e(44),o=e(46),i=e(50),u=Object.defineProperty;n.f=e(47)?Object.defineProperty:function(t,n,e){if(r(t),n=i(n,!0),r(e),o)try{return u(t,n,e)}catch(t){}if("get"in e||"set"in e)throw TypeError("Accessors not supported!");return"value"in e&&(t[n]=e.value),t}},function(t,n,e){var r=e(45);t.exports=function(t){if(!r(t))throw TypeError(t+" is not an object!");return t}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n,e){t.exports=!e(47)&&!e(48)(function(){return 7!=Object.defineProperty(e(49)("div"),"a",{get:function(){return 7}}).a})},function(t,n,e){t.exports=!e(48)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n,e){var r=e(45),o=e(38).document,i=r(o)&&r(o.createElement);t.exports=function(t){return i?o.createElement(t):{}}},function(t,n,e){var r=e(45);t.exports=function(t,n){if(!r(t))return t;var e,o;if(n&&"function"==typeof(e=t.toString)&&!r(o=e.call(t)))return o;if("function"==typeof(e=t.valueOf)&&!r(o=e.call(t)))return o;if(!n&&"function"==typeof(e=t.toString)&&!r(o=e.call(t)))return o;throw TypeError("Can't convert object to primitive value")}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n,e){t.exports=e(42)},function(t,n){var e={}.hasOwnProperty;t.exports=function(t,n){return e.call(t,n)}},function(t,n){t.exports={}},function(t,n,e){"use strict";var r=e(56),o=e(51),i=e(71),u={};e(42)(u,e(72)("iterator"),function(){return this}),t.exports=function(t,n,e){t.prototype=r(u,{next:o(1,e)}),i(t,n+" Iterator")}},function(t,n,e){var r=e(44),o=e(57),i=e(69),u=e(66)("IE_PROTO"),c=function(){},f=function(){var t,n=e(49)("iframe"),r=i.length;for(n.style.display="none",e(70).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),f=t.F;r--;)delete f.prototype[i[r]];return f()};t.exports=Object.create||function(t,n){var e;return null!==t?(c.prototype=r(t),e=new c,c.prototype=null,e[u]=t):e=f(),void 0===n?e:o(e,n)}},function(t,n,e){var r=e(43),o=e(44),i=e(58);t.exports=e(47)?Object.defineProperties:function(t,n){o(t);for(var e,u=i(n),c=u.length,f=0;c>f;)r.f(t,e=u[f++],n[e]);return t}},function(t,n,e){var r=e(59),o=e(69);t.exports=Object.keys||function(t){return r(t,o)}},function(t,n,e){var r=e(53),o=e(60),i=e(63)(!1),u=e(66)("IE_PROTO");t.exports=function(t,n){var e,c=o(t),f=0,a=[];for(e in c)e!=u&&r(c,e)&&a.push(e);for(;n.length>f;)r(c,e=n[f++])&&(~i(a,e)||a.push(e));return a}},function(t,n,e){var r=e(61),o=e(34);t.exports=function(t){return r(o(t))}},function(t,n,e){var r=e(62);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==r(t)?t.split(""):Object(t)}},function(t,n){var e={}.toString;t.exports=function(t){return e.call(t).slice(8,-1)}},function(t,n,e){var r=e(60),o=e(64),i=e(65);t.exports=function(t){return function(n,e,u){var c,f=r(n),a=o(f.length),s=i(u,a);if(t&&e!=e){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===e)return t||s||0;return!t&&-1}}},function(t,n,e){var r=e(33),o=Math.min;t.exports=function(t){return t>0?o(r(t),9007199254740991):0}},function(t,n,e){var r=e(33),o=Math.max,i=Math.min;t.exports=function(t,n){return t=r(t),t<0?o(t+n,0):i(t,n)}},function(t,n,e){var r=e(67)("keys"),o=e(68);t.exports=function(t){return r[t]||(r[t]=o(t))}},function(t,n,e){var r=e(38),o=r["__core-js_shared__"]||(r["__core-js_shared__"]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n){var e=0,r=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++e+r).toString(36))}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n,e){t.exports=e(38).document&&document.documentElement},function(t,n,e){var r=e(43).f,o=e(53),i=e(72)("toStringTag");t.exports=function(t,n,e){t&&!o(t=e?t:t.prototype,i)&&r(t,i,{configurable:!0,value:n})}},function(t,n,e){var r=e(67)("wks"),o=e(68),i=e(38).Symbol,u="function"==typeof i;(t.exports=function(t){return r[t]||(r[t]=u&&i[t]||(u?i:o)("Symbol."+t))}).store=r},function(t,n,e){var r=e(53),o=e(74),i=e(66)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=o(t),r(t,i)?t[i]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,e){var r=e(34);t.exports=function(t){return Object(r(t))}},function(t,n,e){e(76);for(var r=e(38),o=e(42),i=e(54),u=e(72)("toStringTag"),c=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],f=0;f<5;f++){var a=c[f],s=r[a],l=s&&s.prototype;l&&!l[u]&&o(l,u,a),i[a]=i.Array}},function(t,n,e){"use strict";var r=e(77),o=e(78),i=e(54),u=e(60);t.exports=e(35)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,e=this._i++;return!t||e>=t.length?(this._t=void 0,o(1)):"keys"==n?o(0,e):"values"==n?o(0,t[e]):o(0,[e,t[e]])},"values"),i.Arguments=i.Array,r("keys"),r("values"),r("entries")},function(t,n){t.exports=function(){}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,e){n.f=e(72)},function(t,n,e){t.exports={default:e(81),__esModule:!0}},function(t,n,e){e(82),e(93),e(94),e(95),t.exports=e(39).Symbol},function(t,n,e){"use strict";var r=e(38),o=e(53),i=e(47),u=e(37),c=e(52),f=e(83).KEY,a=e(48),s=e(67),l=e(71),p=e(68),d=e(72),y=e(79),v=e(84),h=e(85),b=e(86),x=e(89),m=e(44),g=e(60),w=e(50),O=e(51),S=e(56),_=e(90),j=e(92),P=e(43),E=e(58),M=j.f,A=P.f,T=_.f,L=r.Symbol,N=r.JSON,C=N&&N.stringify,k=d("_hidden"),F=d("toPrimitive"),q={}.propertyIsEnumerable,I=s("symbol-registry"),B=s("symbols"),D=s("op-symbols"),W=Object.prototype,H="function"==typeof L,K=r.QObject,R=!K||!K.prototype||!K.prototype.findChild,J=i&&a(function(){return 7!=S(A({},"a",{get:function(){return A(this,"a",{value:7}).a}})).a})?function(t,n,e){var r=M(W,n);r&&delete W[n],A(t,n,e),r&&t!==W&&A(W,n,r)}:A,U=function(t){var n=B[t]=S(L.prototype);return n._k=t,n},G=H&&"symbol"==typeof L.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof L},$=function(t,n,e){return t===W&&$(D,n,e),m(t),n=w(n,!0),m(e),o(B,n)?(e.enumerable?(o(t,k)&&t[k][n]&&(t[k][n]=!1),e=S(e,{enumerable:O(0,!1)})):(o(t,k)||A(t,k,O(1,{})),t[k][n]=!0),J(t,n,e)):A(t,n,e)},z=function(t,n){m(t);for(var e,r=b(n=g(n)),o=0,i=r.length;i>o;)$(t,e=r[o++],n[e]);return t},Y=function(t,n){return void 0===n?S(t):z(S(t),n)},Q=function(t){var n=q.call(this,t=w(t,!0));return!(this===W&&o(B,t)&&!o(D,t))&&(!(n||!o(this,t)||!o(B,t)||o(this,k)&&this[k][t])||n)},X=function(t,n){if(t=g(t),n=w(n,!0),t!==W||!o(B,n)||o(D,n)){var e=M(t,n);return!e||!o(B,n)||o(t,k)&&t[k][n]||(e.enumerable=!0),e}},V=function(t){for(var n,e=T(g(t)),r=[],i=0;e.length>i;)o(B,n=e[i++])||n==k||n==f||r.push(n);return r},Z=function(t){for(var n,e=t===W,r=T(e?D:g(t)),i=[],u=0;r.length>u;)!o(B,n=r[u++])||e&&!o(W,n)||i.push(B[n]);return i};H||(L=function(){if(this instanceof L)throw TypeError("Symbol is not a constructor!");var t=p(arguments.length>0?arguments[0]:void 0),n=function(e){this===W&&n.call(D,e),o(this,k)&&o(this[k],t)&&(this[k][t]=!1),J(this,t,O(1,e))};return i&&R&&J(W,t,{configurable:!0,set:n}),U(t)},c(L.prototype,"toString",function(){return this._k}),j.f=X,P.f=$,e(91).f=_.f=V,e(88).f=Q,e(87).f=Z,i&&!e(36)&&c(W,"propertyIsEnumerable",Q,!0),y.f=function(t){return U(d(t))}),u(u.G+u.W+u.F*!H,{Symbol:L});for(var tt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),nt=0;tt.length>nt;)d(tt[nt++]);for(var tt=E(d.store),nt=0;tt.length>nt;)v(tt[nt++]);u(u.S+u.F*!H,"Symbol",{for:function(t){return o(I,t+="")?I[t]:I[t]=L(t)},keyFor:function(t){if(G(t))return h(I,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){R=!0},useSimple:function(){R=!1}}),u(u.S+u.F*!H,"Object",{create:Y,defineProperty:$,defineProperties:z,getOwnPropertyDescriptor:X,getOwnPropertyNames:V,getOwnPropertySymbols:Z}),N&&u(u.S+u.F*(!H||a(function(){var t=L();return"[null]"!=C([t])||"{}"!=C({a:t})||"{}"!=C(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!G(t)){for(var n,e,r=[t],o=1;arguments.length>o;)r.push(arguments[o++]);return n=r[1],"function"==typeof n&&(e=n),!e&&x(n)||(n=function(t,n){if(e&&(n=e.call(this,t,n)),!G(n))return n}),r[1]=n,C.apply(N,r)}}}),L.prototype[F]||e(42)(L.prototype,F,L.prototype.valueOf),l(L,"Symbol"),l(Math,"Math",!0),l(r.JSON,"JSON",!0)},function(t,n,e){var r=e(68)("meta"),o=e(45),i=e(53),u=e(43).f,c=0,f=Object.isExtensible||function(){return!0},a=!e(48)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,r,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!o(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!i(t,r)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[r].i},p=function(t,n){if(!i(t,r)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[r].w},d=function(t){return a&&y.NEED&&f(t)&&!i(t,r)&&s(t),t},y=t.exports={KEY:r,NEED:!1,fastKey:l,getWeak:p,onFreeze:d}},function(t,n,e){var r=e(38),o=e(39),i=e(36),u=e(79),c=e(43).f;t.exports=function(t){var n=o.Symbol||(o.Symbol=i?{}:r.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,e){var r=e(58),o=e(60);t.exports=function(t,n){for(var e,i=o(t),u=r(i),c=u.length,f=0;c>f;)if(i[e=u[f++]]===n)return e}},function(t,n,e){var r=e(58),o=e(87),i=e(88);t.exports=function(t){var n=r(t),e=o.f;if(e)for(var u,c=e(t),f=i.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,e){var r=e(62);t.exports=Array.isArray||function(t){return"Array"==r(t)}},function(t,n,e){var r=e(60),o=e(91).f,i={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return o(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==i.call(t)?c(t):o(r(t))}},function(t,n,e){var r=e(59),o=e(69).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return r(t,o)}},function(t,n,e){var r=e(88),o=e(51),i=e(60),u=e(50),c=e(53),f=e(46),a=Object.getOwnPropertyDescriptor;n.f=e(47)?a:function(t,n){if(t=i(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return o(!r.f.call(t,n),t[n])}},function(t,n){},function(t,n,e){e(84)("asyncIterator")},function(t,n,e){e(84)("observable")},function(t,n){function e(t,n){if("string"==typeof n)return t.insertAdjacentHTML("afterend",n);var e=t.nextSibling;return e?t.parentNode.insertBefore(n,e):t.parentNode.appendChild(n)}t.exports=e},function(t,n){"use strict";var e={versions:function(){var t=window.navigator.userAgent;return{trident:t.indexOf("Trident")>-1,presto:t.indexOf("Presto")>-1,webKit:t.indexOf("AppleWebKit")>-1,gecko:t.indexOf("Gecko")>-1&&t.indexOf("KHTML")==-1,mobile:!!t.match(/AppleWebKit.*Mobile.*/),ios:!!t.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),android:t.indexOf("Android")>-1||t.indexOf("Linux")>-1,iPhone:t.indexOf("iPhone")>-1||t.indexOf("Mac")>-1,iPad:t.indexOf("iPad")>-1,webApp:t.indexOf("Safari")==-1,weixin:t.indexOf("MicroMessenger")==-1}}()};t.exports=e},function(t,n){"use strict";function e(){var t=document.querySelector("#page-nav");if(t&&!document.querySelector("#page-nav .extend.prev")&&(t.innerHTML='<a class="extend prev disabled" rel="prev">&laquo; Prev</a>'+t.innerHTML),t&&!document.querySelector("#page-nav .extend.next")&&(t.innerHTML=t.innerHTML+'<a class="extend next disabled" rel="next">Next &raquo;</a>'),yiliaConfig&&yiliaConfig.open_in_new){document.querySelectorAll(".article-entry a:not(.article-more-a)").forEach(function(t){t.setAttribute("target","_blank")})}var n=document.querySelector("#js-aboutme");n&&0!==n.length&&(n.innerHTML=n.innerText)}t.exports={init:e}}])</script><script src="/./main.ea2298.js"></script><script>!function(){!function(e){var t=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(t),t.setAttribute("src",e)}("/slider.583eaa.js")}()</script>


    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
      
      
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">所有文章</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'friends')"><a href="javascript:void(0)" q-class="active:friends">友链</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">关于我</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">spring</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">spring,springmvc</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">rest with spring</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">git</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">HTTP</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">spring,aop</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">programming</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">java,JPA</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">JVM</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">java</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">springboot mybatis</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">Web开发</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">javascript</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">java,注解</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">springSecurity</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">undertow</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">java,volatile</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">Rxjs</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">Git</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">english learn</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">设计模式</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">微服务</a>
              </li>
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、在博客根目录（注意不是yilia根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            2、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: true
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    
    	<section class="tools-section tools-section-friends" q-show="friends">
  		
        <ul class="search-ul">
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接1</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接2</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接3</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接4</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接5</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接6</a>
            </li>
          
        </ul>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">爱一丹&lt;br&gt;&lt;br&gt; 爱生活</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>